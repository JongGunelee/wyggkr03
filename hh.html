<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>전체 집행 현황 분석</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            padding-top: 180px; /* Adjusted for potentially taller fixed header */
        }
        @media (min-width: 1024px) {
            body {
                 padding-top: 150px; /* Adjust as needed for desktop */
            }
        }

        .fixed-header-container {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 100;
            background-color: #f8fafc; /* bg-slate-50 */
            padding: 1rem;
            box-shadow: 0 2px 4px -1px rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            transition: height 0.3s ease-in-out;
        }

        .main-content-container {
            padding-top: 200px; /* Default, will be adjusted by JS */
            transition: padding-top 0.3s ease-in-out;
        }


        .chart-container { 
            position: relative; 
            width: 100%; 
            margin-left: auto; 
            margin-right: auto; 
            background-color: white; 
            padding: 1rem; 
            border-radius: 0.5rem; 
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); 
            cursor: pointer; 
        }
        .table-container { background-color: white; padding: 1rem; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); overflow-x: auto;}
        table { width: 100%; border-collapse: collapse; }
        th, td { border: 1px solid #e2e8f0; padding: 0.75rem; font-size: 0.875rem; }
        th {
            background-color: #f8fafc; /* bg-slate-50 */
            font-weight: 600;
            text-align: center;
        }
        td {
            text-align: center;
        }
        td.text-left {
            text-align: left;
        }
        td.number-cell {
            text-align: right;
        }
        .filter-select, .data-management-button, #csvUpload, .csv-header-input, .csv-header-select {
            background-color: white;
            border: 1px solid #cbd5e1; /* border-slate-300 */
            border-radius: 0.375rem; /* rounded-md */
            padding: 0.5rem 0.75rem; /* py-2 px-3 */
            font-size: 0.875rem; /* text-sm */
            line-height: 1.25rem;
        }
        select[multiple] {
            padding: 0.5rem;
            height: auto;
            min-height: 60px; /* Or any other suitable height */
        }
        select[multiple] option:disabled {
            color: #9ca3af; /* text-slate-400 */
            background-color: #f3f4f6; /* bg-slate-100 */
        }
        select[multiple] option:not(:disabled) {
            color: #1f2937; /* text-slate-800 */
            background-color: white;
        }
        select[multiple] option.relevant-option {
            font-weight: bold;
            background-color: #f0f9ff; /* light sky blue, e.g., sky-50 */
        }
        .data-management-button {
            background-color: #0284c7; /* bg-sky-600 */
            color: white;
            font-weight: 600;
            transition: background-color 0.15s ease-in-out;
            display: block; /* Make them block elements */
            width: 100%;    /* Make them full width */
            margin-bottom: 0.5rem; /* Add some space between buttons */
            text-align: left; /* Align text to the left */
            padding: 0.5rem 0.75rem; /* Consistent padding */
        }
        .data-management-button:last-child {
            margin-bottom: 0;
        }
        .data-management-button:hover {
            background-color: #0369a1; /* hover:bg-sky-700 */
        }
        #csvUpload { width: 100%; margin-bottom: 0.5rem; }
        .stat-card { background-color: white; padding: 1.5rem; border-radius: 0.5rem; box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1); text-align: left; }
        .stat-card h3 { 
            font-size: 1rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.75rem;
            text-align: center;
        }
        .stat-card .stat-value-multiline { 
            font-size: calc(1.15rem * 1.1); 
            line-height: 1.8; 
            color: #2563eb; 
        }
        .stat-card .year-label { display: inline-block; width: 55px; font-weight: normal; color: #4b5563;} 
        .stat-card .year-label.current-year { font-weight: bold; color: #1e3a8a;} 
        .stat-card .year-label.previous-year { font-size: 0.95em; color: #9ca3af; font-weight: normal;} 
        .stat-card .stat-value {font-weight: 600;}
        .stat-card .stat-value.current-year-value {font-weight: bold; color: #1e3a8a;} 
        .stat-card .stat-value.previous-year-value {font-size: 0.95em; color: #9ca3af; font-weight: normal;} 
        .stat-card .additional-insight { font-size: 0.85rem; color: #4b5563; margin-top: 0.5rem; border-top: 1px solid #e5e7eb; padding-top: 0.5rem;}
        .stat-card .additional-insight p { margin-bottom: 0.25rem; }
        .stat-card .additional-insight strong { color: #1e40af; } 


        .note-box { background-color: #fffbeb; border-left: 4px solid #facc15; padding: 1rem; margin-bottom:1rem; border-radius: 0.25rem; }
        .note-box p, .note-box li { color: #713f12; }
        h1, h2 { color: #1e3a8a; } 
        h3 { 
            color: #1e3a8a; 
        }
        label { color: #334155; } 

        /* Styles for title parts */
        .title-main {
            font-size: 1.1em; 
            font-weight: 700; 
            color: #000000; 
        }
        .title-suffix {
            font-size: 0.9em; 
            font-weight: 400; 
            color: #888888; 
            margin-left: 8px;
        }
        .chart-subtitle-main { 
            font-size: calc(1.1em * 0.9); 
            font-weight: 700;
            color: #808080; 
        }
        .chart-subtitle-suffix { 
            font-size: calc(0.9em * 0.9); 
            font-weight: 400;
            color: #b0b0b0; 
            margin-left: 6px;
        }

        .text-na, .text-zero-as-dash {
            color: #9ca3af; 
            font-size: 0.9em; 
            text-align: center !important; 
        }
        #detailModalBody table td {
            white-space: nowrap;
        }
        #detailModalTable thead th {
            position: sticky;
            top: 0;
            z-index: 10; 
            background-color: #f8fafc; 
        }


        /* Modal Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 150; 
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        .modal-content {
            background-color: white;
            padding: 2rem;
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            width: 90%;
            max-width: 800px; 
            max-height: 90vh; 
            overflow-y: auto; 
        }
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            border-bottom: 1px solid #e5e7eb; 
            padding-bottom: 0.5rem;
        }
        .modal-title {
            font-size: 1.25rem; 
            font-weight: 600;
            color: #1e3a8a; 
        }
        .modal-close-button {
            background: none;
            border: none;
            font-size: 1.5rem; 
            font-weight: bold;
            color: #6b7280; 
            cursor: pointer;
        }
        .modal-close-button:hover {
            color: #1f2937; 
        }
        /* Top bar layout */
        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; 
            margin-bottom: 1rem;
            gap: 1rem; 
        }
        .filter-section-container {
            flex-grow: 1; 
            padding: 1rem;
            background-color: #f0f9ff; 
            border: 1px solid #e0f2fe; 
            border-radius: 0.5rem; 
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.07), 0 1px 2px -1px rgb(0 0 0 / 0.07);
        }
        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .filter-controls { 
            display: flex;
            gap: 0.5rem; 
        }
        .filter-content {
            display: none; 
            margin-top: 0.75rem; 
            max-height: 0px; 
            opacity: 0;
            overflow: hidden; 
            position: relative; 
        }
        .filter-content.active {
            display: grid; 
            opacity: 1;
            overflow: visible; 
        }
        #filterResizeHandle {
            width: 100%;
            height: 10px;
            background-color: #cbd5e1; 
            cursor: ns-resize;
            position: absolute;
            bottom: 0;
            left: 0;
            display: none; 
        }
        .filter-content.active + #filterResizeHandle {
            display: block;
        }

        .data-management-icon-container {
            position: relative; 
            flex-shrink: 0; 
        }
        .data-management-dropdown {
            display: none;
            position: absolute;
            top: 100%; 
            right: 0; 
            background-color: white;
            border: 1px solid #e5e7eb; 
            border-radius: 0.375rem; 
            box-shadow: 0 4px 6px -1px rgba(0,0,0,0.1), 0 2px 4px -1px rgba(0,0,0,0.06);
            z-index: 110; 
            width: 280px; 
            padding: 0.5rem; 
        }
        .data-management-dropdown.active {
            display: block;
        }
        .data-management-icon {
            font-size: 1.75rem; 
            padding: 0.5rem; 
            border-radius: 0.375rem; 
            cursor: pointer;
            background-color: #e0f2fe; 
            color: #0284c7; 
            border: 1px solid #bae6fd; 
        }
         .data-management-icon:hover {
            background-color: #bae6fd; 
         }
         /* Styles for small action buttons in filter headers */
        .action-button { 
            font-size: 0.75rem; 
            padding: 0.25rem 0.5rem; 
            border-radius: 0.25rem; 
            margin-left: 0.25rem; 
            background-color: #e5e7eb; 
            color: #4b5563; 
            cursor: pointer;
            transition: background-color 0.15s ease-in-out, color 0.15s ease-in-out;
        }
        .action-button:hover {
            background-color: #d1d5db; 
        }

        .sort-order-button { 
            color: #9ca3af; 
        }
        .sort-order-button:hover {
            color: #6b7280; 
        }
        .sort-order-button.active-sort {
            background-color: #60a5fa; 
            color: white !important; 
        }

        .selection-action-button.active-selection { 
            background-color: #3b82f6; 
            color: white;
        }

        /* Chart Popup Styles */
        .chart-popup-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.6);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000; 
        }
        .chart-popup-content {
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
            width: 80vw; 
            height: 70vh; 
            min-width: 400px;
            min-height: 300px;
            position: relative;
            display: flex;
            flex-direction: column;
            overflow: hidden; 
        }
        .chart-popup-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 10px;
            margin-bottom: 10px;
            border-bottom: 1px solid #eee;
            cursor: move; /* Draggable header */
        }
        .chart-popup-title {
            font-size: 1.2rem;
            font-weight: 600;
        }
        .chart-popup-close-button {
            font-size: 1.8rem;
            font-weight: bold;
            color: #555;
            background: none;
            border: none;
            cursor: pointer;
            padding: 0 0.5rem;
        }
        .chart-popup-body {
            flex-grow: 1;
            position: relative; 
            overflow: hidden; 
        }
        .chart-popup-body canvas {
            width: 100% !important;
            height: 100% !important;
        }
        .chart-resize-handle {
            position: absolute;
            background-color: #ccc;
            opacity: 0.5;
        }
        .resize-handle-se { bottom: 0; right: 0; width: 15px; height: 15px; cursor: nwse-resize; }
        .resize-handle-s { bottom: 0; left: 50%; transform: translateX(-50%); width: 50px; height: 10px; cursor: ns-resize;}
        .resize-handle-e { top: 50%; right: 0; transform: translateY(-50%); width: 10px; height: 50px; cursor: ew-resize;}

        /* CSV Mapping Modal Styles */
        #csvMappingModal .modal-content, #filterConfigModal .modal-content {
            max-width: 900px; /* Wider for more columns */
        }
        #csvHeaderList li, #activeFiltersList li, #availableCsvColumnsList li {
            display: flex;
            align-items: center;
            padding: 0.5rem 0.25rem; /* Reduced padding */
            border-bottom: 1px solid #eee;
        }
        #csvHeaderList li:last-child, #activeFiltersList li:last-child, #availableCsvColumnsList li:last-child {
            border-bottom: none;
        }
        #csvHeaderList .header-name-input, #filterConfigModal .filter-name-span {
            flex-grow: 1;
            margin-right: 0.5rem;
        }
        #csvHeaderList .header-type-select {
            width: 100px;
            margin-right: 0.5rem;
        }
        #csvHeaderList .header-required-checkbox {
            margin-right: 0.5rem;
        }
        .header-action-button, .filter-action-button {
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            margin-left: 0.25rem;
        }
        .drag-handle {
            cursor: grab;
            padding: 0 0.5rem;
            color: #9ca3af;
        }
        .dragging {
            opacity: 0.5;
            background: #e0f2fe;
        }
        #filterConfigModal .two-panel-container {
            display: flex;
            gap: 1rem;
        }
        #filterConfigModal .panel {
            flex: 1;
            border: 1px solid #ddd;
            padding: 0.75rem;
            border-radius: 0.375rem;
            max-height: 300px;
            overflow-y: auto;
        }


    </style>
</head>
<body class="bg-slate-50 text-slate-800">
    <div class="fixed-header-container" id="fixedHeaderContainer">
        <header class="mb-2 text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-sky-700">전체 집행 현황 분석</h1>
        </header>

        <div class="top-bar">
            <div class="filter-section-container">
                <div id="filterHeader" class="filter-header">
                    <h2 class="text-xl font-semibold text-sky-700">데이터 필터 (클릭하여 펼치기/접기)</h2>
                    <div class="filter-controls">
                         <button id="setInitialStateToCurrent" class="bg-amber-500 hover:bg-amber-600 text-white font-semibold py-1 px-3 text-sm rounded-lg shadow transition duration-150 ease-in-out">업로드 데이터로 초기 상태 설정</button>
                        <button id="resetFilters" class="bg-sky-600 hover:bg-sky-700 text-white font-semibold py-1 px-3 text-sm rounded-lg shadow transition duration-150 ease-in-out">필터 초기화</button>
                    </div>
                </div>
                <div id="filterContent" class="filter-content grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-4">
                    </div>
                <div id="filterResizeHandle"></div>
            </div>

            <div class="data-management-icon-container">
                <button id="dataManagementToggle" title="데이터 관리" class="data-management-icon">
                    ⚙️
                </button>
                <div id="dataManagementDropdown" class="data-management-dropdown">
                    <h3 class="text-lg font-semibold text-emerald-700 mb-2 px-2">데이터 관리</h3>
                    <div class="mb-3 px-2">
                        <label for="csvUpload" class="block text-xs font-medium mb-1">CSV 파일 업로드:</label>
                        <input type="file" id="csvUpload" accept=".csv" class="block w-full text-xs text-slate-500 file:mr-2 file:py-1 file:px-2 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-sky-50 file:text-sky-700 hover:file:bg-sky-100"/>
                        <p id="uploadStatus" class="text-xs mt-1 text-slate-600"></p>
                    </div>
                    <button id="downloadCsvTemplate" class="data-management-button">CSV 양식 (BOM)</button>
                    <button id="downloadCurrentCsvState" class="data-management-button">현재 CSV (BOM)</button>
                    <button id="manageDongUnits" class="data-management-button">동별 세대수 관리</button>
                    <button id="manageCsvHeaders" class="data-management-button">CSV 항목 관리</button>
                    <button id="manageFilterConfigs" class="data-management-button">필터 항목 구성</button>
                    <button id="downloadHtml" class="data-management-button">HTML 다운로드</button>
                </div>
            </div>
        </div>
    </div>

    <div class="main-content-container container mx-auto max-w-full px-4 md:px-8">
        <section id="overview" class="mb-8 pt-4"> <h2 class="text-2xl font-bold text-slate-700 mb-4">종합 개요</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6 mb-6">
                <div class="stat-card">
                    <h3 id="statTotalProjectsTitle">작업 건수</h3>
                    <div id="statTotalProjects" class="stat-value-multiline">0건</div>
                </div>
                <div class="stat-card">
                    <h3 id="statTotalExpenditureTitle">집행 금액</h3>
                    <div id="statTotalExpenditure" class="stat-value-multiline">0원</div>
                </div>
                <div class="stat-card">
                    <h3 id="statAvgProjectCostTitle">평균 비용</h3>
                    <div id="statAvgProjectCost" class="stat-value-multiline">0원</div>
                </div>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6">
                <div class="chart-container h-72 md:h-80 max-h-[350px]">
                    <canvas id="overviewChartDongAnalysis"></canvas>
                </div>
                <div class="chart-container h-72 md:h-80 max-h-[350px]">
                    <canvas id="overviewChartWorkTypeDistribution"></canvas>
                </div>
                <div class="chart-container h-72 md:h-80 max-h-[350px]">
                    <canvas id="overviewChartAnnualTrend"></canvas>
                </div>
            </div>

            <div class="note-box">
                <p><strong>주의사항:</strong></p>
                <ul class="list-disc list-inside ml-4">
                    <li id="noteDong9">데이터를 기반으로 동별 세대수 초과 여부를 확인합니다.</li>
                    <li id="notePO">PO번호가 누락된 행은 분석에서 제외됩니다.</li>
                </ul>
            </div>
        </section>

        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
            <section id="buildingAnalysis" class="mb-8 p-4 bg-white rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-slate-700 mb-4">동별 분석</h2>
                <div class="mb-4 table-container">
                    <table id="tableBuildingSummary">
                        <thead><tr><th>동</th><th>전체 세대수</th><th>완료 세대수</th><th>진행률 (%)</th><th>총 PO금액 (원)</th><th>세대당 평균금액 (원)</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-1 gap-4"> <div class="chart-container h-80 md:h-96 max-h-[400px]"><canvas id="chartBuildingCompleted"></canvas></div>
                    <div class="chart-container h-80 md:h-96 max-h-[400px]"><canvas id="chartBuildingFinanceCombination"></canvas></div>
                </div>
            </section>

            <section id="workTypeAnalysis" class="mb-8 p-4 bg-white rounded-lg shadow-lg">
                <h2 class="text-xl font-semibold text-slate-700 mb-4">작업 유형별 분석</h2>
                 <div class="mb-4 table-container">
                    <table id="tableWorkTypeSummary">
                        <thead><tr><th>작업유형</th><th>총 작업 건수</th><th>총 PO금액 (원)</th></tr></thead>
                        <tbody></tbody>
                    </table>
                </div>
                <div class="chart-container h-80 md:h-96 max-h-[400px] mb-6">
                    <canvas id="chartWorkTypeCombination"></canvas>
                </div>
                <div id="dongWorkTypeProgressChartContainerWrapper" class="mt-6">
                    <h3 class="text-lg font-semibold text-slate-700 mb-2 text-center" id="dongWorkTypeProgressTitle">동 및 작업 유형별 진척률</h3>
                    <div id="dongWorkTypeProgressPlaceholder" class="text-center text-slate-500 py-10 bg-slate-100 rounded-md">
                        건물 동과 작업 유형을 선택하여 (다중 선택 가능) 연도별 종합 진척률을 확인하세요.
                    </div>
                    <div id="chartDongWorkTypeProgressContainer" class="chart-container h-80 md:h-96 max-h-[400px]" style="display: none;">
                         <canvas id="chartDongWorkTypeProgress"></canvas>
                    </div>
                </div>
                <div id="dongWorkTypeFinanceCountChartWrapper" class="mt-6">
                    <div id="dongWorkTypeFinanceCountPlaceholder" class="text-center text-slate-500 py-10 bg-slate-100 rounded-md" style="display: none;">
                        데이터가 없거나 필터를 조정하여 확인하세요.
                    </div>
                    <div id="chartDongWorkTypeFinanceCountContainer" class="chart-container h-80 md:h-96 max-h-[400px]">
                        <canvas id="chartDongWorkTypeFinanceCount"></canvas>
                    </div>
                </div>
            </section>
        </div>

        <section id="annualAnalysis" class="mb-8 p-4 bg-white rounded-lg shadow-lg">
            <h2 class="text-xl font-semibold text-slate-700 mb-4">연도별 추이 분석</h2>
            <div class="mb-4 table-container">
                <table id="tableAnnualSummary">
                    <thead><tr><th>회계연도</th><th>총 작업 건수</th><th>총 PO금액 (원)</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
            <div class="chart-container h-80 md:h-96 max-h-[400px]">
                <canvas id="chartAnnualCombination"></canvas>
            </div>
        </section>

        <section id="crossAnalysis" class="mb-8 p-4 bg-white rounded-lg shadow-lg">
            <h2 class="text-xl font-semibold text-slate-700 mb-4">상세 교차 분석</h2>
            <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                <div class="chart-container h-96 md:h-[450px] max-h-[500px]">
                    <canvas id="chartDongWorkTypeCount"></canvas>
                </div>
                <div class="chart-container h-96 md:h-[450px] max-h-[500px]">
                    <canvas id="chartDongWorkTypePO"></canvas>
                </div>
                <div class="chart-container h-96 md:h-[450px] max-h-[500px]">
                    <canvas id="chartYearDongCount"></canvas>
                </div>
                <div class="chart-container h-96 md:h-[450px] max-h-[500px]">
                    <canvas id="chartYearWorkTypeCount"></canvas>
                </div>
            </div>
        </section>

        <footer class="text-center mt-12 py-4 border-t border-slate-300">
            <p class="text-sm text-slate-500">전체 집행 현황 분석</p>
        </footer>
    </div>

    <div id="detailModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="detailModalTitle" class="modal-title">상세 데이터</h3>
                <button id="detailModalCloseButton" class="modal-close-button">&times;</button>
            </div>
            <div id="detailModalBody" class="table-container">
                <table id="detailModalTable">
                    <thead></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>

    <div id="dongUnitsModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">동별 전체 세대수 관리</h3>
                <button id="dongUnitsModalCloseButton" class="modal-close-button">&times;</button>
            </div>
            <div id="dongUnitsModalBody">
                <p class="text-sm text-slate-600 mb-4">각 동의 전체 세대수를 입력하거나 수정하세요. 변경사항은 "저장" 버튼을 눌러야 적용됩니다.</p>
                <div id="dongUnitsTableContainer" class="mb-4 max-h-60 overflow-y-auto table-container">
                    <table class="w-full">
                        <thead>
                            <tr>
                                <th class="w-2/5">동 이름</th>
                                <th class="w-2/5">전체 세대수</th>
                                <th class="w-1/5">삭제</th>
                            </tr>
                        </thead>
                        <tbody id="dongUnitsTableBody">
                            </tbody>
                    </table>
                </div>
                <div class="flex items-center space-x-2 mb-4">
                    <input type="text" id="newDongName" placeholder="새 동 이름 (예: 10동)" class="filter-select flex-grow">
                    <input type="text" id="newDongUnits" placeholder="세대수 (숫자, N/A, - 등)" class="filter-select w-32"> <button id="addDongUnitButton" class="action-button bg-green-500 hover:bg-green-600 text-white">추가</button>
                </div>
                <p id="dongUnitsError" class="text-red-500 text-sm mb-2"></p>
            </div>
            <div class="modal-footer text-right space-x-2 mt-6">
                <button id="saveDongUnitsButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow">저장</button>
                <button id="cancelDongUnitsButton" class="bg-slate-300 hover:bg-slate-400 text-slate-800 font-semibold py-2 px-4 rounded-lg shadow">취소</button>
            </div>
        </div>
    </div>
    
    <div id="chartPopupOverlay" class="chart-popup-overlay" style="display: none;">
        <div id="chartPopupContent" class="chart-popup-content">
            <div class="chart-popup-header">
                <span id="chartPopupTitle" class="chart-popup-title">차트</span>
                <button id="chartPopupCloseButton" class="chart-popup-close-button">&times;</button>
            </div>
            <div id="chartPopupBody" class="chart-popup-body">
                <canvas id="popupChartCanvas"></canvas>
            </div>
            <div class="chart-resize-handle resize-handle-se"></div>
            <div class="chart-resize-handle resize-handle-s"></div>
            <div class="chart-resize-handle resize-handle-e"></div>
        </div>
    </div>

    <div id="csvMappingModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">CSV 항목(컬럼) 관리</h3>
                <button id="csvMappingModalCloseButton" class="modal-close-button">&times;</button>
            </div>
            <div id="csvMappingModalBody">
                <p class="text-sm text-slate-600 mb-1">업로드할 CSV 파일의 항목(컬럼) 순서와 내용을 정의합니다.</p>
                <p class="text-xs text-amber-700 bg-amber-100 p-2 rounded-md mb-4">참고: 여기서 변경된 항목 구성은 다음 CSV 파일 업로드 시부터 적용됩니다. 현재 로드된 데이터에는 영향을 주지 않습니다.</p>
                <div class="mb-4 border border-slate-200 rounded-md p-3">
                    <h4 class="text-md font-semibold mb-2 text-slate-700">현재 정의된 항목 (드래그하여 순서 변경 가능)</h4>
                    <ul id="csvHeaderList" class="space-y-2">
                        </ul>
                </div>
                <div class="mb-4 p-3 border border-slate-200 rounded-md">
                    <h4 class="text-md font-semibold mb-2 text-slate-700">새 항목 추가</h4>
                    <div class="flex items-center space-x-2">
                        <input type="text" id="newCsvHeaderName" placeholder="새 항목 이름" class="csv-header-input flex-grow">
                         <select id="newCsvHeaderType" class="csv-header-select w-28">
                            <option value="text">텍스트</option>
                            <option value="number">숫자</option>
                            <option value="date">날짜</option>
                        </select>
                        <label class="flex items-center space-x-1">
                            <input type="checkbox" id="newCsvHeaderRequired" class="form-checkbox h-4 w-4 text-sky-600">
                            <span>필수</span>
                        </label>
                        <button id="addCsvHeaderButton" class="action-button bg-green-500 hover:bg-green-600 text-white">추가</button>
                    </div>
                </div>
                 <p id="csvMappingError" class="text-red-500 text-sm mb-2"></p>
            </div>
            <div class="modal-footer text-right space-x-2 mt-6">
                <button id="saveCsvHeadersButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow">저장</button>
                <button id="cancelCsvMappingButton" class="bg-slate-300 hover:bg-slate-400 text-slate-800 font-semibold py-2 px-4 rounded-lg shadow">취소</button>
            </div>
        </div>
    </div>

    <div id="filterConfigModal" class="modal-overlay">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">데이터 필터 항목 구성</h3>
                <button id="filterConfigModalCloseButton" class="modal-close-button">&times;</button>
            </div>
            <div id="filterConfigModalBody">
                <p class="text-sm text-slate-600 mb-4">대시보드에 표시할 필터 항목을 선택하고 순서를 정합니다.</p>
                <div class="two-panel-container">
                    <div class="panel">
                        <h4 class="text-md font-semibold mb-2 text-slate-700">사용 가능한 CSV 항목</h4>
                        <ul id="availableCsvColumnsList" class="space-y-1">
                            </ul>
                    </div>
                    <div class="panel">
                        <h4 class="text-md font-semibold mb-2 text-slate-700">현재 활성화된 필터 (드래그하여 순서 변경)</h4>
                        <ul id="activeFiltersList" class="space-y-1">
                            </ul>
                    </div>
                </div>
                <p id="filterConfigError" class="text-red-500 text-sm mt-2 mb-2"></p>
            </div>
            <div class="modal-footer text-right space-x-2 mt-6">
                <button id="saveFilterConfigsButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg shadow">저장</button>
                <button id="cancelFilterConfigsButton" class="bg-slate-300 hover:bg-slate-400 text-slate-800 font-semibold py-2 px-4 rounded-lg shadow">취소</button>
            </div>
        </div>
    </div>


<script id="dashboardSettingsInline"></script>
<script>
    // Ensure window.DASHBOARD_SAVED_SETTINGS is at least null if not injected by the placeholder.
    if (typeof window.DASHBOARD_SAVED_SETTINGS === 'undefined') {
        window.DASHBOARD_SAVED_SETTINGS = null;
    }

    // Global data variables
    let initialMasterRawEntries = [ 
        { "회계 연도": "17년", "매입 마감 (월)": "05월31일", "작업유형": "사택 씽크대 교체", "건물동": "8동", "계약명": "사택 8-101 씽크대", "PO금액": "872900", "PO번호": "PO-17-001", "PR번호": "PR-17-001", "전체 세대수": "44" },
        { "회계 연도": "18년", "매입 마감 (월)": "06월30일", "작업유형": "사택 씽크대 교체", "건물동": "8동", "계약명": "사택 8-202 씽크대", "PO금액": "1300000", "PO번호": "PO-18-001", "PR번호": "PR-18-001", "전체 세대수": "44" },
        { "회계 연도": "18년", "매입 마감 (월)": "07월31일", "작업유형": "사택 주방벽 타일교체", "건물동": "8동", "계약명": "사택 8-203 타일", "PO금액": "1301800", "PO번호": "PO-18-002", "PR번호": "PR-18-002", "전체 세대수": "44" },
        { "회계 연도": "18년", "매입 마감 (월)": "08월31일", "작업유형": "사택 씽크대 교체", "건물동": "9동", "계약명": "사택 9-101 씽크대", "PO금액": "1050000", "PO번호": "PO-18-003", "PR번호": "PR-18-003", "전체 세대수": "30" },
        { "회계 연도": "18년", "매입 마감 (월)": "09월30일", "작업유형": "사택 주방벽 타일교체", "건물동": "9동", "계약명": "사택 9-102 타일", "PO금액": "1057350", "PO번호": "PO-18-004", "PR번호": "PR-18-004", "전체 세대수": "30" },
        { "회계 연도": "19년", "매입 마감 (월)": "05월31일", "작업유형": "사택 씽크대 교체", "건물동": "5동", "계약명": "사택 5-305 씽크대", "PO금액": "3389475", "PO번호": "4508267979-10", "PR번호": "91476921-30", "전체 세대수": "30" },
        { "회계 연도": "19년", "매입 마감 (월)": "01월31일", "작업유형": "사택 씽크대 교체", "건물동": "8동", "계약명": "사택 8-xxx 씽크대", "PO금액": "1000000", "PO번호": "PO-19-001", "PR번호": "PR-19-001", "전체 세대수": "44" },
        { "회계 연도": "19년", "매입 마감 (월)": "02월28일", "작업유형": "사택 주방벽 타일교체", "건물동": "8동", "계약명": "사택 8-yyy 타일", "PO금액": "1000000", "PO번호": "PO-19-002", "PR번호": "PR-19-002", "전체 세대수": "44" },
        { "회계 연도": "19년", "매입 마감 (월)": "03월31일", "작업유형": "사택 주방벽 타일교체", "건물동": "8동", "계약명": "사택 8-zzz 타일", "PO금액": "1000000", "PO번호": "PO-19-003", "PR번호": "PR-19-003", "전체 세대수": "44" },
        { "회계 연도": "19년", "매입 마감 (월)": "04월30일", "작업유형": "사택 주방벽 타일교체", "건물동": "9동", "계약명": "사택 9-aaa 타일", "PO금액": "1000000", "PO번호": "PO-19-004", "PR번호": "PR-19-004", "전체 세대수": "30" },
        { "회계 연도": "19년", "매입 마감 (월)": "05월31일", "작업유형": "사택 주방벽 타일교체", "건물동": "9동", "계약명": "사택 9-bbb 타일", "PO금액": "1000000", "PO번호": "PO-19-005", "PR번호": "PR-19-005", "전체 세대수": "30" },
        { "회계 연도": "23년", "매입 마감 (월)": "01월31일", "작업유형": "사택 씽크대 교체", "건물동": "2동", "계약명": "사택 2-103 씽크대(저층)", "PO금액": "3990400", "PO번호": "4560169329-10", "PR번호": "92604127-30", "전체 세대수": "32" },
        { "회계 연도": "24년", "매입 마감 (월)": "01월15일", "작업유형": "사택 씽크대 교체", "건물동": "2동", "계약명": "사택 2-201 씽크대", "PO금액": "4100000", "PO번호": "PO-24-001", "PR번호": "PR-24-001", "전체 세대수": "32" },
        { "회계 연도": "24년", "매입 마감 (월)": "01월20일", "작업유형": "사택 주방벽 타일교체", "건물동": "2동", "계약명": "사택 2-202 타일", "PO금액": "1200000", "PO번호": "PO-24-002", "PR번호": "PR-24-002", "전체 세대수": "32" },
        { "회계 연도": "24년", "매입 마감 (월)": "02월10일", "작업유형": "사택 씽크대 교체", "건물동": "5동", "계약명": "사택 5-101 씽크대", "PO금액": "3800000", "PO번호": "PO-24-003", "PR번호": "PR-24-003", "전체 세대수": "30" }
    ];
    // Default CSV header configuration
    let initialMasterCsvHeaders = [
        { name: "회계 연도", originalName: "회계 연도", required: true, type: "text" },
        { name: "매입 마감 (월)", originalName: "매입 마감 (월)", required: true, type: "text" },
        { name: "작업유형", originalName: "작업유형", required: true, type: "text" },
        { name: "건물동", originalName: "건물동", required: true, type: "text" },
        { name: "계약명", originalName: "계약명", required: true, type: "text" },
        { name: "PO금액", originalName: "PO금액", required: true, type: "number" },
        { name: "PO번호", originalName: "PO번호", required: true, type: "text" },
        { name: "PR번호", originalName: "PR번호", required: false, type: "text" },
        { name: "전체 세대수", originalName: "전체 세대수", required: false, type: "number" }
    ];

    let initialTotalUnitsPerDongStatic = { 
        "2동": 32, "5동": 30, "7동": 40, "8동": 44, "9동": 30
    };
    // Default active filter configurations
    let initialActiveFilterConfigs = [
        { headerName: "건물동", sort: "asc" },
        { headerName: "회계 연도", sort: "desc" },
        { headerName: "작업유형", sort: "asc" }
    ];


    // Processed data storage (derived from masterRawEntries based on filters)
    let dataBuildingSummaryRaw = [];
    let dataWorkTypeSummaryRaw = [];
    let dataDongWorkTypeCountRaw = {};
    let dataDongWorkTypePORaw = {};
    let dataAnnualSummaryRaw = [];
    let dataYearDongCountRaw = {};
    let dataYearWorkTypeCountRaw = {};
    let dataDongFinanceAndCountRaw = []; // For the new chart

    // Global lists for filters (populated from masterRawEntries)
    let allDongsGlobal = [];
    let allYearsGlobal = [];
    let allWorkTypesGlobal = [];

    // Static data (can be overridden by CSV or modal, and reset by "업로드된 데이터로 초기 상태 설정")
    let totalUnitsPerDongStatic = {
        "2동": 32, "5동": 30, "7동": 40, "8동": 44, "9동": 30
    };

    // Chart instances
    let charts = {};
    let popupChartInstance = null; // For the chart in the popup

    // Master data (holds current working data, initially from initialMasterRawEntries or loaded settings/CSV)
    let masterRawEntries = [];
    let masterCsvHeaders = []; // Will be array of objects: {name, originalName, required, type}
    let activeFilterConfigs = []; // Array of objects: { headerName: "컬럼명", sort: "asc/desc" }


    // Fullscreen state
    // let currentFullscreenChartContainer = null; // Deprecated, using popup instead
    let currentPopupChartId = null;
    let currentPopupElement = null;
    let isResizingPopup = false;
    let popupInitialX, popupInitialY, popupInitialWidth, popupInitialHeight;
    let dragOffsetX, dragOffsetY, isDraggingPopupHeader = false;


    // Color palettes
    const specificDongColors = {
        "2동": "#672D93",
        "5동": "#BE5014",
        "8동": "#00B050",
        "9동": "#FF00FF"
    };

    const dynamicColorPalette = [
        'rgba(255, 99, 71, 0.7)', 'rgba(60, 179, 113, 0.7)', 'rgba(106, 90, 205, 0.7)',
        'rgba(218, 112, 214, 0.7)', 'rgba(0, 191, 255, 0.7)', 'rgba(173, 255, 47, 0.7)',
        'rgba(255, 105, 180, 0.7)', 'rgba(138, 43, 226, 0.7)', 'rgba(240, 230, 140, 0.7)',
        'rgba(0, 206, 209, 0.7)', 'rgba(123, 104, 238, 0.7)', 'rgba(255, 127, 80, 0.7)',
        'rgba(220, 20, 60, 0.7)', 'rgba(0, 255, 127, 0.7)', 'rgba(70, 130, 180, 0.7)',
        'rgba(255, 215, 0, 0.7)'
    ];

    // --- Color Helper Functions ---
    function getDongColor(dongName) {
        if (specificDongColors[dongName]) {
            const color = specificDongColors[dongName];
            if (color.startsWith('#') && color.length === 7) {
                const r = parseInt(color.slice(1, 3), 16);
                const g = parseInt(color.slice(3, 5), 16);
                const b = parseInt(color.slice(5, 7), 16);
                return `rgba(${r}, ${g}, ${b}, 0.7)`;
            }
            return color.includes('rgba') ? color : color.replace('rgb', 'rgba').replace(')', ', 0.7)');
        }
        const dongIndex = allDongsGlobal.length > 0 ? allDongsGlobal.indexOf(dongName) : Math.floor(Math.random() * dynamicColorPalette.length);
        return dynamicColorPalette[dongIndex % dynamicColorPalette.length];
    }

    function getDongBorderColor(dongName) {
        if (specificDongColors[dongName]) {
            const color = specificDongColors[dongName];
            if (color.includes('rgba')) return color.replace(/, ?\d?\.?\d+\)$/, ', 1)');
            if (color.startsWith('#')) return color;
            return color;
        }
        const dongIndex = allDongsGlobal.length > 0 ? allDongsGlobal.indexOf(dongName) : Math.floor(Math.random() * dynamicColorPalette.length);
        return dynamicColorPalette[dongIndex % dynamicColorPalette.length].replace('0.7', '1');
    }

    function getWorkTypeColor(workTypeName) {
        const workTypeIndex = allWorkTypesGlobal.length > 0 ? allWorkTypesGlobal.indexOf(workTypeName) : Math.floor(Math.random() * dynamicColorPalette.length);
        const offset = Object.keys(specificDongColors).length + (allDongsGlobal.length > 0 ? allDongsGlobal.length : 0) + 5;
        return dynamicColorPalette[(workTypeIndex + offset) % dynamicColorPalette.length];
    }

    function getWorkTypeBorderColor(workTypeName) {
        const workTypeIndex = allWorkTypesGlobal.length > 0 ? allWorkTypesGlobal.indexOf(workTypeName) : Math.floor(Math.random() * dynamicColorPalette.length);
        const offset = Object.keys(specificDongColors).length + (allDongsGlobal.length > 0 ? allDongsGlobal.length : 0) + 5;
        return dynamicColorPalette[(workTypeIndex + offset) % dynamicColorPalette.length].replace('0.7', '1');
    }

    // --- Formatting and Utility Functions ---
    function formatCurrency(amount, isCount = false) {
        if (amount === 0 && !isCount) { // Handle 0 value for currency
            return "-";
        }
        if (isCount) {
             if (amount === 0) return "-";
             if (isNaN(parseFloat(amount))) return '0건';
            return new Intl.NumberFormat('ko-KR').format(amount) + '건';
        }
        amount = parseFloat(String(amount).replace(/,/g, ''));
        if (isNaN(amount)) return '0원'; 
        if (amount === 0) return "-"; // Already handled above, but as a safeguard

        if (amount >= 100000000) {
            return (amount / 100000000).toFixed(2) + '억원';
        } else if (amount >= 1000000) {
            return (amount / 1000000).toFixed(2) + '백만원';
        } else if (amount >= 1000) {
            return (amount / 1000).toFixed(2) + '천원';
        }
        return new Intl.NumberFormat('ko-KR').format(amount) + '원';
    }

    function getSelectedOptions(selectElement) {
        if (!selectElement) return [];
        return Array.from(selectElement.selectedOptions).map(option => option.value);
    }

    function repopulateSelectWithOptions(selectElement, allPossibleOptions, relevantOptions, previouslySelectedValues) {
        if (!selectElement) return;
        const currentScrollTop = selectElement.scrollTop;
        selectElement.innerHTML = '';

        allPossibleOptions.forEach(optValue => {
            const option = document.createElement('option');
            option.value = optValue;
            option.textContent = optValue;

            if (relevantOptions.includes(optValue)) {
                option.classList.add('relevant-option');
                option.disabled = false;
                option.style.fontWeight = 'bold';
                option.style.backgroundColor = '#e0f2fe';
            } else {
                option.disabled = true;
                option.style.color = '#9ca3af';
                option.style.backgroundColor = '#f3f4f6';
            }

            if (previouslySelectedValues.includes(optValue) && relevantOptions.includes(optValue)) {
                option.selected = true;
            }
            selectElement.appendChild(option);
        });
        selectElement.scrollTop = currentScrollTop;
    }

    function formatTitleWithSuffix(fullTitle, isChartSubtitle = false) {
        if (!fullTitle) return '';
        const match = fullTitle.match(/^(.*?)(\s*\([^)]+\))$/);
        let mainClass = "title-main";
        let suffixClass = "title-suffix";

        if (isChartSubtitle) {
            mainClass = "chart-subtitle-main";
            suffixClass = "chart-subtitle-suffix";
        }

        if (match && match[2]) { // Suffix in parentheses found
            const mainPart = match[1].trim();
            const suffixPart = match[2].trim();
            return `<span class="${mainClass}">${mainPart}</span> <span class="${suffixClass}">${suffixPart}</span>`;
        } else { // No suffix found, style the whole title as main
            return `<span class="${mainClass}">${fullTitle.trim()}</span>`;
        }
    }

    // --- Filter and Data Processing Logic ---
    let filterSortOrders = { // This will be deprecated and managed by activeFilterConfigs
        // dong: 'asc',
        // year: 'desc',
        // worktype: 'asc'
    };

    // Helper function to get header name by its original name (useful after user reordering/renaming)
    function getHeaderName(originalConceptName) {
        const headerConfig = masterCsvHeaders.find(h => h.originalName === originalConceptName);
        return headerConfig ? headerConfig.name : originalConceptName; 
    }


    function populateDynamicFilters() {
        const filterContentEl = document.getElementById('filterContent');
        if (!filterContentEl) {
            console.error("Filter content element not found.");
            return;
        }
        filterContentEl.innerHTML = ''; // Clear existing dynamic filters

        activeFilterConfigs.forEach(filterConfig => {
            const columnName = filterConfig.headerName;
            const columnData = masterRawEntries.map(e => e[columnName] ? (columnName === getHeaderName("건물동") ? e[columnName].replace('사택 ','').trim() : e[columnName]) : '').filter(Boolean);
            const uniqueOptions = [...new Set(columnData)];
            
            // Sort options based on filterConfig.sort (which should be part of activeFilterConfigs)
            if (filterConfig.sort === 'asc') {
                uniqueOptions.sort((a, b) => String(a).localeCompare(String(b), 'ko-KR', { numeric: true }));
            } else if (filterConfig.sort === 'desc') {
                uniqueOptions.sort((a, b) => String(b).localeCompare(String(a), 'ko-KR', { numeric: true }));
            }


            const filterDiv = document.createElement('div');
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'flex justify-between items-center mb-1';

            const label = document.createElement('label');
            label.htmlFor = `filter-select-${columnName.replace(/\s+/g, '_')}`;
            label.className = 'block text-sm font-medium';
            label.textContent = `${columnName} 선택:`;
            headerDiv.appendChild(label);

            const controlsDiv = document.createElement('div');
            const selectAllBtn = document.createElement('button');
            selectAllBtn.id = `selectAll-${columnName.replace(/\s+/g, '_')}`;
            selectAllBtn.className = 'action-button selection-action-button';
            selectAllBtn.textContent = '전체';
            selectAllBtn.onclick = () => {
                const selectEl = document.getElementById(`filter-select-${columnName.replace(/\s+/g, '_')}`);
                if(selectEl) Array.from(selectEl.options).forEach(option => { if (!option.disabled) option.selected = true; });
                updateDashboard();
            };
            controlsDiv.appendChild(selectAllBtn);

            const deselectAllBtn = document.createElement('button');
            deselectAllBtn.id = `deselectAll-${columnName.replace(/\s+/g, '_')}`;
            deselectAllBtn.className = 'action-button selection-action-button';
            deselectAllBtn.textContent = '해제';
            deselectAllBtn.onclick = () => {
                const selectEl = document.getElementById(`filter-select-${columnName.replace(/\s+/g, '_')}`);
                if(selectEl) Array.from(selectEl.options).forEach(opt => opt.selected = false);
                updateDashboard();
            };
            controlsDiv.appendChild(deselectAllBtn);
            
            const sortAscBtn = document.createElement('button');
            sortAscBtn.id = `sort-${columnName.replace(/\s+/g, '_')}Asc`;
            sortAscBtn.className = 'action-button sort-order-button' + (filterConfig.sort === 'asc' ? ' active-sort' : '');
            sortAscBtn.innerHTML = '▲';
            sortAscBtn.onclick = () => { 
                filterConfig.sort = 'asc'; 
                populateDynamicFilters(); // Re-populate to reflect sort
                updateDashboard(); 
            };
            controlsDiv.appendChild(sortAscBtn);

            const sortDescBtn = document.createElement('button');
            sortDescBtn.id = `sort-${columnName.replace(/\s+/g, '_')}Desc`;
            sortDescBtn.className = 'action-button sort-order-button' + (filterConfig.sort === 'desc' ? ' active-sort' : '');
            sortDescBtn.innerHTML = '▼';
             sortDescBtn.onclick = () => { 
                filterConfig.sort = 'desc'; 
                populateDynamicFilters(); // Re-populate to reflect sort
                updateDashboard(); 
            };
            controlsDiv.appendChild(sortDescBtn);
            headerDiv.appendChild(controlsDiv);
            filterDiv.appendChild(headerDiv);

            const selectEl = document.createElement('select');
            selectEl.id = `filter-select-${columnName.replace(/\s+/g, '_')}`;
            selectEl.className = 'filter-select w-full';
            selectEl.multiple = true;
            selectEl.size = 3;
            selectEl.onchange = updateDashboard;
            
            // Populate select options
            // For dynamic filters, we need to determine relevant options based on *other* active filters
            // This is a simplified version for now, assuming independence for option population
            let relevantForThisFilter = uniqueOptions; // Simplified: assume all unique options are initially relevant
            // More complex: filter uniqueOptions based on selections in *other* active filters
            
            repopulateSelectWithOptions(selectEl, uniqueOptions, relevantForThisFilter, filterConfig.selectedValues || []);


            filterDiv.appendChild(selectEl);
            filterContentEl.appendChild(filterDiv);
        });
        updateButtonActiveStates(); // Update active states for newly created buttons
    }


    function updateOverviewCharts(filteredEntries, buildingSummary, workTypeSummary, annualSummary) {
        const filterYearEl = document.getElementById(`filter-select-${getHeaderName("회계 연도").replace(/\s+/g, '_')}`);
        const selectedYears = filterYearEl ? getSelectedOptions(filterYearEl) : [];

        let latestYearToDisplay;
        let titleSuffixDongWorkType;
        let titleSuffixAnnualTrend;
        let dataForDongAndWorkTypeCharts = filteredEntries;
        
        const yearHeaderName = getHeaderName("회계 연도");
        const dongHeaderName = getHeaderName("건물동");
        const workTypeHeaderName = getHeaderName("작업유형");
        const poAmountHeaderName = getHeaderName("PO금액");

        if (selectedYears.length > 0) {
            latestYearToDisplay = selectedYears.sort((a,b) => parseInt(String(b).replace('년','')) - parseInt(String(a).replace('년','')))[0];
            titleSuffixDongWorkType = ` (${selectedYears.join(', ')} 필터 적용)`;
            titleSuffixAnnualTrend = ` (${selectedYears.join(', ')} 필터 적용)`;
        } else if (allYearsGlobal.length > 0 && masterCsvHeaders.length > 0) {
            latestYearToDisplay = allYearsGlobal[allYearsGlobal.length - 1];
            titleSuffixDongWorkType = ` (${latestYearToDisplay} 기준)`;

            let annualTrendYearsData = dataAnnualSummaryRaw.slice(-3);
            if (annualTrendYearsData.length > 0) {
                const yearRange = annualTrendYearsData.map(y => y.year);
                titleSuffixAnnualTrend = ` (최근 ${annualTrendYearsData.length}개년: ${yearRange.join(', ')})`;
            } else {
                 titleSuffixAnnualTrend = ' (데이터 없음)';
            }
            dataForDongAndWorkTypeCharts = masterRawEntries.filter(e => e[yearHeaderName] === latestYearToDisplay);
        } else {
            titleSuffixDongWorkType = ' (데이터 없음)';
            titleSuffixAnnualTrend = ' (데이터 없음)';
        }

        let overviewDongSummary = [];
        if (masterCsvHeaders.length > 0) {
            overviewDongSummary = allDongsGlobal.map(dName => {
                const dongEntries = dataForDongAndWorkTypeCharts.filter(e => (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dName);
                const completedUnits = dongEntries.length;
                const totalPOAmount = dongEntries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0);
                return { dong: dName, completedUnits, avgAmountPerUnit: completedUnits > 0 ? Math.round(totalPOAmount / completedUnits) : 0 };
            }).filter(d => d.completedUnits > 0 || d.avgAmountPerUnit > 0);
        }

        let overviewWorkTypeSummary = [];
        if (masterCsvHeaders.length > 0) {
            overviewWorkTypeSummary = allWorkTypesGlobal.map(wtName => {
                 const workTypeEntries = dataForDongAndWorkTypeCharts.filter(e => e[workTypeHeaderName] === wtName);
                 return { workType: wtName, totalWorkCount: workTypeEntries.length, totalPOAmount: workTypeEntries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0) };
            }).filter(wt => wt.totalWorkCount > 0);
        }

        let overviewAnnualDataForTrend = annualSummary;
         if (selectedYears.length === 0) {
            overviewAnnualDataForTrend = dataAnnualSummaryRaw.slice(-3);
         }


        const dongAnalysisTitle = `동별 작업 건수 및 평균 집행 비용${titleSuffixDongWorkType}`;
        const dongAnalysisOpts = commonChartOptions(dongAnalysisTitle, 'overviewChartDongAnalysis'); // Pass chartId
        createOrUpdateChart('overviewChartDongAnalysis', 'bar', {
            labels: overviewDongSummary.map(d => d.dong),
            datasets: [
                {
                    label: '완료 작업 건수',
                    data: overviewDongSummary.map(d => d.completedUnits),
                    backgroundColor: 'rgba(54, 162, 235, 0.7)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    yAxisID: 'yBar',
                },
                {
                    label: '세대당 평균 집행 비용',
                    data: overviewDongSummary.map(d => d.avgAmountPerUnit),
                    type: 'line',
                    borderColor: 'rgba(255, 159, 64, 1)',
                    backgroundColor: 'rgba(255, 159, 64, 0.2)',
                    yAxisID: 'yLine',
                    tension: 0.1,
                    pointRadius: 6,
                    pointHoverRadius: 7.2,
                    pointBackgroundColor: 'rgba(255, 159, 64, 0.8)',
                    pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
                }
            ]
        }, {
            ...dongAnalysisOpts,
            scales: {
                yBar: { type: 'linear', display: true, position: 'left', title: { display: true, text: '작업 건수' }, ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value; }}},
                yLine: { type: 'linear', display: true, position: 'right', title: { display: true, text: '평균 비용 (원)'}, grid: { drawOnChartArea: false }, ticks: { callback: function(value) { if (value === 0) return "-"; return formatCurrency(value);}}}
            }
        });

        const workTypeDistTitle = `작업 유형별 분포${titleSuffixDongWorkType}`;
        const pieOpts = pieChartOptions(workTypeDistTitle, 'overviewChartWorkTypeDistribution'); // Pass chartId
        createOrUpdateChart('overviewChartWorkTypeDistribution', 'doughnut', {
            labels: overviewWorkTypeSummary.map(d => d.workType),
            datasets: [{
                label: '작업 건수',
                data: overviewWorkTypeSummary.map(d => d.totalWorkCount),
                backgroundColor: (typeof dynamicColorPalette !== 'undefined' && dynamicColorPalette.length > 0 && overviewWorkTypeSummary.length > 0)
                                 ? overviewWorkTypeSummary.map((wt, i) => getWorkTypeColor(wt.workType))
                                 : ['rgba(201, 203, 207, 0.7)'],
            }]
        }, {...pieOpts,
            plugins: {
                ...pieOpts.plugins,
                tooltip: {
                ...pieOpts.plugins.tooltip,
                callbacks: {
                    label: function(context) {
                        let label = context.label || '';
                        if (label) { label += ': '; }
                        const dataIndex = context.dataIndex;
                        const count = context.dataset.data[dataIndex];
                        const workTypeData = overviewWorkTypeSummary[dataIndex];
                        const amount = workTypeData ? workTypeData.totalPOAmount : 0;

                        label += `${count === 0 ? '-' : formatCurrency(count, true)}, ${amount === 0 ? '-' : formatCurrency(amount)}`;
                        return label;
                    }
                }
            }}
        });

        const annualTrendTitleText = `연도별 작업 건수 및 집행 금액 추이${titleSuffixAnnualTrend}`;
        const annualTrendChartOpts = {
            ...commonChartOptions(annualTrendTitleText, 'overviewChartAnnualTrend'), // Pass chartId
             plugins: {
                ...commonChartOptions(annualTrendTitleText, 'overviewChartAnnualTrend').plugins,
                tooltip: {
                    ...commonChartOptions(annualTrendTitleText, 'overviewChartAnnualTrend').plugins.tooltip,
                    bodyFontSize: 14 * 1.3,
                    titleFontSize: 16 * 1.3,
                    padding: 10 * 1.3
                }
             },
             scales: {
                yCount: { type: 'linear', display: true, position: 'left', title: {display: true, text: '총 작업 건수'}, ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value; }}},
                yAmount: { type: 'linear', display: true, position: 'right', title: {display: true, text: '총 집행 금액 (원)'}, grid: { drawOnChartArea: false }, ticks: { callback: function(value) {if (value === 0) return "-"; return formatCurrency(value);}}}
             }
        };

        const latestYearForHighlightInTrend = overviewAnnualDataForTrend.length > 0 ? overviewAnnualDataForTrend[overviewAnnualDataForTrend.length - 1].year : null;

        createOrUpdateChart('overviewChartAnnualTrend', 'line', {
            labels: overviewAnnualDataForTrend.map(d => d.year),
            datasets: [
                {
                    label: '총 작업 건수',
                    data: overviewAnnualDataForTrend.map(d => d.totalWorkCount),
                    borderColor: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 'rgba(30, 64, 175, 1)' : 'rgba(54, 162, 235, 1)';
                    },
                    backgroundColor: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 'rgba(30, 64, 175, 0.2)' : 'rgba(54, 162, 235, 0.2)';
                    },
                    borderWidth: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 3.5 : 2;
                    },
                    pointRadius: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 8 : 6;
                    },
                    pointHoverRadius: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 9.6 : 7.2;
                    },
                    pointBackgroundColor: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 'rgba(220, 20, 60, 1)' : 'rgba(54, 162, 235, 0.8)';
                    },
                    pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)',
                    yAxisID: 'yCount',
                    fill: false,
                    tension: 0.1,
                },
                {
                    label: '총 집행 금액',
                    data: overviewAnnualDataForTrend.map(d => d.totalPOAmount),
                     borderColor: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 'rgba(200, 80, 0, 1)' : 'rgba(255, 159, 64, 1)';
                    },
                    backgroundColor: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 'rgba(200, 80, 0, 0.2)' : 'rgba(255, 159, 64, 0.2)';
                    },
                    borderWidth: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 3.5 : 2;
                    },
                    pointRadius: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 8 : 6;
                    },
                    pointHoverRadius: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 9.6 : 7.2;
                    },
                    pointBackgroundColor: (ctx) => {
                        const currentYear = overviewAnnualDataForTrend[ctx.dataIndex]?.year;
                        return (selectedYears.length === 0 && currentYear === latestYearForHighlightInTrend) ? 'rgba(220, 20, 60, 1)' : 'rgba(255, 159, 64, 0.8)';
                    },
                    pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)',
                    yAxisID: 'yAmount',
                    fill: false,
                    tension: 0.1,
                }
            ]
        }, annualTrendChartOpts);
    }

    function updateDashboard() {
        const yearHeaderName = getHeaderName("회계 연도");
        const workTypeHeaderName = getHeaderName("작업유형");
        const dongHeaderName = getHeaderName("건물동");
        const poAmountHeaderName = getHeaderName("PO금액");

        let selectedDongs = [];
        let selectedYears = [];
        let selectedWorkTypes = [];

        activeFilterConfigs.forEach(config => {
            const selectEl = document.getElementById(`filter-select-${config.headerName.replace(/\s+/g, '_')}`);
            if (selectEl) {
                const selectedOptions = getSelectedOptions(selectEl);
                if (config.headerName === dongHeaderName) selectedDongs = selectedOptions;
                else if (config.headerName === yearHeaderName) selectedYears = selectedOptions;
                else if (config.headerName === workTypeHeaderName) selectedWorkTypes = selectedOptions;
                // Store selected values back into config for persistence if needed (e.g. for HTML download)
                config.selectedValues = selectedOptions; 
            }
        });


        let currentFilteredEntries = [...masterRawEntries];
        if (selectedDongs.length > 0) {
            currentFilteredEntries = currentFilteredEntries.filter(e => selectedDongs.includes(e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : ''));
        }
        if (selectedYears.length > 0) {
            currentFilteredEntries = currentFilteredEntries.filter(e => selectedYears.includes(e[yearHeaderName]));
        }
        if (selectedWorkTypes.length > 0) {
            currentFilteredEntries = currentFilteredEntries.filter(e => selectedWorkTypes.includes(e[workTypeHeaderName]));
        }
        
        let entriesForBuildingSummary = [...masterRawEntries];
        if (selectedYears.length > 0) {
            entriesForBuildingSummary = entriesForBuildingSummary.filter(e => selectedYears.includes(e[yearHeaderName]));
        }
        if (selectedWorkTypes.length > 0) {
            entriesForBuildingSummary = entriesForBuildingSummary.filter(e => selectedWorkTypes.includes(e[workTypeHeaderName]));
        }
        dataBuildingSummaryRaw = allDongsGlobal.map(dName => {
            const dongEntries = entriesForBuildingSummary.filter(e => (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dName);
            const completedUnits = dongEntries.length;
            const totalPOAmount = dongEntries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0);
            const totalU = totalUnitsPerDongStatic[dName]; 
            return {
                dong: dName, 
                totalUnits: totalU === null ? "N/A" : totalU, 
                completedUnits: completedUnits,
                progressRate: (totalU !== null && totalU > 0) ? parseFloat(((completedUnits / totalU) * 100).toFixed(2)) : "N/A",
                totalPOAmount: totalPOAmount, 
                avgAmountPerUnit: completedUnits > 0 ? Math.round(totalPOAmount / completedUnits) : 0
            };
        });


        let entriesForWorkTypeSummary = [...masterRawEntries];
        if (selectedYears.length > 0) {
            entriesForWorkTypeSummary = entriesForWorkTypeSummary.filter(e => selectedYears.includes(e[yearHeaderName]));
        }
        if (selectedDongs.length > 0) {
            entriesForWorkTypeSummary = entriesForWorkTypeSummary.filter(e => selectedDongs.includes(e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : ''));
        }
        dataWorkTypeSummaryRaw = allWorkTypesGlobal.map(wtName => {
            const workTypeEntries = entriesForWorkTypeSummary.filter(e => e[workTypeHeaderName] === wtName);
            return {
                workType: wtName, totalWorkCount: workTypeEntries.length,
                totalPOAmount: workTypeEntries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0)
            };
        });

        let entriesForAnnualSummary = [...masterRawEntries];
        if (selectedDongs.length > 0) {
            entriesForAnnualSummary = entriesForAnnualSummary.filter(e => selectedDongs.includes(e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : ''));
        }
        if (selectedWorkTypes.length > 0) {
            entriesForAnnualSummary = entriesForAnnualSummary.filter(e => selectedWorkTypes.includes(e[workTypeHeaderName]));
        }
        dataAnnualSummaryRaw = allYearsGlobal.map(yName => {
            const yearEntries = entriesForAnnualSummary.filter(e => e[yearHeaderName] === yName);
            return {
                year: yName, totalWorkCount: yearEntries.length,
                totalPOAmount: yearEntries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0)
            };
        });


        updateThreeYearStatCards(currentFilteredEntries, dataBuildingSummaryRaw, dataWorkTypeSummaryRaw, dataAnnualSummaryRaw, selectedYears);
        updateOverviewCharts(currentFilteredEntries, dataBuildingSummaryRaw, dataWorkTypeSummaryRaw, dataAnnualSummaryRaw);

        let generalTitleSuffix;
        if (selectedYears.length > 0 && selectedDongs.length > 0 && selectedWorkTypes.length > 0) {
            generalTitleSuffix = ` (${selectedYears.join(',')}, ${selectedDongs.join(',')}, ${selectedWorkTypes.join(',')} 필터 적용)`;
        } else if (selectedYears.length > 0 && selectedDongs.length > 0) {
            generalTitleSuffix = ` (${selectedYears.join(',')}, ${selectedDongs.join(',')} 필터 적용)`;
        } else if (selectedYears.length > 0 && selectedWorkTypes.length > 0) {
            generalTitleSuffix = ` (${selectedYears.join(',')}, ${selectedWorkTypes.join(',')} 필터 적용)`;
        } else if (selectedDongs.length > 0 && selectedWorkTypes.length > 0) {
            generalTitleSuffix = ` (${selectedDongs.join(',')}, ${selectedWorkTypes.join(',')} 필터 적용)`;
        } else if (selectedYears.length > 0) {
            generalTitleSuffix = ` (${selectedYears.join(', ')} 필터 적용)`;
        } else if (selectedDongs.length > 0) {
            generalTitleSuffix = ` (${selectedDongs.join(', ')} 필터 적용)`;
        } else if (selectedWorkTypes.length > 0) {
            generalTitleSuffix = ` (${selectedWorkTypes.join(', ')} 필터 적용)`;
        }
         else if (allYearsGlobal.length > 0) { 
            const latestThreeYears = allYearsGlobal.slice(-3);
            if (latestThreeYears.length > 0) {
                generalTitleSuffix = ` (최근 ${latestThreeYears.length}개년: ${latestThreeYears.join(', ')} 기준)`;
            } else {
                generalTitleSuffix = ' (데이터 없음)';
            }
        } else {
            generalTitleSuffix = ' (데이터 없음)';
        }


        populateTable('tableBuildingSummary', dataBuildingSummaryRaw.filter(d => selectedDongs.length === 0 || selectedDongs.includes(d.dong)), ['dong', 'totalUnits', 'completedUnits', 'progressRate', 'totalPOAmount', 'avgAmountPerUnit']);
        
        const sortedWorkTypeData = [...dataWorkTypeSummaryRaw.filter(wt => selectedWorkTypes.length === 0 || selectedWorkTypes.includes(wt.workType))]
                                    .sort((a, b) => b.totalPOAmount - a.totalPOAmount);
        populateTable('tableWorkTypeSummary', sortedWorkTypeData, ['workType', 'totalWorkCount', 'totalPOAmount']);
        
        populateTable('tableAnnualSummary', dataAnnualSummaryRaw.filter(y => selectedYears.length === 0 || selectedYears.includes(y.year)), ['year', 'totalWorkCount', 'totalPOAmount']);

        updateBuildingCharts(dataBuildingSummaryRaw.filter(d => selectedDongs.length === 0 || selectedDongs.includes(d.dong)), generalTitleSuffix);
        updateWorkTypeCharts(dataWorkTypeSummaryRaw.filter(wt => selectedWorkTypes.length === 0 || selectedWorkTypes.includes(wt.workType)), selectedDongs, selectedWorkTypes, generalTitleSuffix); 
        updateAnnualCharts(dataAnnualSummaryRaw.filter(y => selectedYears.length === 0 || selectedYears.includes(y.year)));
        updateCrossAnalysisCharts(selectedDongs, selectedYears, selectedWorkTypes);

        let dataForDongFinanceCountChart;
        const dongsToDisplayInNewChart = selectedDongs.length > 0 ? selectedDongs : allDongsGlobal;

        let baseEntriesForNewChart = [...masterRawEntries];
        if (selectedYears.length > 0) {
            baseEntriesForNewChart = baseEntriesForNewChart.filter(e => selectedYears.includes(e[yearHeaderName]));
        }
        if (selectedWorkTypes.length > 0) {
            baseEntriesForNewChart = baseEntriesForNewChart.filter(e => selectedWorkTypes.includes(e[workTypeHeaderName]));
        }

        dataForDongFinanceCountChart = dongsToDisplayInNewChart.map(dName => {
            const dongEntriesInCurrentFilter = baseEntriesForNewChart.filter(
                e => (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dName
            );
            const totalPOAmount = dongEntriesInCurrentFilter.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0);
            const totalWorkCount = dongEntriesInCurrentFilter.length;
            return {
                dong: dName,
                totalPOAmount: totalPOAmount,
                totalWorkCount: totalWorkCount
            };
        });
        updateDongWorkTypeFinanceAndCountChart(dataForDongFinanceCountChart, generalTitleSuffix);


        // populateDynamicFilters(); // This should be called by initializeDynamicFiltersUI or when filter configs change
        updateButtonActiveStates();
    }

    function updateThreeYearStatCards(entriesToAnalyze, buildingSummary, workTypeSummary, annualSummary, selectedYears) {
        const statTotalProjectsEl = document.getElementById('statTotalProjects');
        const statTotalExpenditureEl = document.getElementById('statTotalExpenditure');
        const statAvgProjectCostEl = document.getElementById('statAvgProjectCost');

        if (!statTotalProjectsEl || !statTotalExpenditureEl || !statAvgProjectCostEl || masterCsvHeaders.length === 0) {
            console.warn("Stat card elements or master CSV headers not found, skipping update.");
            return;
        }
        const yearHeaderName = getHeaderName("회계 연도");
        const poAmountHeaderName = getHeaderName("PO금액");


        statTotalProjectsEl.innerHTML = '';
        statTotalExpenditureEl.innerHTML = '';
        statAvgProjectCostEl.innerHTML = '';

        let titleSuffixForStatCards;
        if (selectedYears.length > 0) {
            titleSuffixForStatCards = ` (${selectedYears.join(', ')} 필터 적용)`;
        } else if (allYearsGlobal.length > 0) {
            const latestThreeYearsData = allYearsGlobal.slice(-3);
             if (latestThreeYearsData.length > 0) {
                titleSuffixForStatCards = ` (최근 ${latestThreeYearsData.length}개년: ${latestThreeYearsData.join(', ')} 기준)`;
            } else {
                titleSuffixForStatCards = ' (데이터 없음)';
            }
        } else {
            titleSuffixForStatCards = ' (데이터 없음)';
        }

        document.getElementById('statTotalProjectsTitle').innerHTML = formatTitleWithSuffix("작업 건수" + titleSuffixForStatCards);
        document.getElementById('statTotalExpenditureTitle').innerHTML = formatTitleWithSuffix("집행 금액" + titleSuffixForStatCards);
        document.getElementById('statAvgProjectCostTitle').innerHTML = formatTitleWithSuffix("평균 비용" + titleSuffixForStatCards);


        const uniqueYearsInFilteredData = [...new Set(entriesToAnalyze.map(e => e[yearHeaderName]))].sort((a,b) => parseInt(String(b).replace('년','')) - parseInt(String(a).replace('년','')));
        const lastThreeYears = uniqueYearsInFilteredData.slice(0, 3);

        let projectsContent = '';
        let expenditureContent = '';
        let avgCostContent = '';

        if (lastThreeYears.length === 0 && entriesToAnalyze.length > 0) {
             const totalProjects = entriesToAnalyze.length;
             const totalExpenditure = entriesToAnalyze.reduce((sum, item) => sum + (parseFloat(String(item[poAmountHeaderName]).replace(/,/g, '')) || 0), 0);
             const avgCost = totalProjects > 0 ? Math.round(totalExpenditure / totalProjects) : 0;
             projectsContent = `<span class="stat-value">${formatCurrency(totalProjects, true)}</span>`;
             expenditureContent = `<span class="stat-value">${formatCurrency(totalExpenditure)}</span>`;
             avgCostContent = `<span class="stat-value">${formatCurrency(avgCost)}</span>`;
        } else if (lastThreeYears.length === 0 && entriesToAnalyze.length === 0){
             projectsContent = `<span class="stat-value">0건</span>`;
             expenditureContent = `<span class="stat-value">0원</span>`;
             avgCostContent = `<span class="stat-value">0원</span>`;
        } else {
            lastThreeYears.forEach((year, index) => {
                const yearEntries = entriesToAnalyze.filter(e => e[yearHeaderName] === year);
                const totalProjectsYear = yearEntries.length;
                const totalExpenditureYear = yearEntries.reduce((sum, item) => sum + (parseFloat(String(item[poAmountHeaderName]).replace(/,/g, '')) || 0), 0);
                const avgCostYear = totalProjectsYear > 0 ? Math.round(totalExpenditureYear / totalProjectsYear) : 0;

                const yearLabelClass = index === 0 ? 'current-year' : 'previous-year';
                const valueClass = index === 0 ? 'current-year-value' : 'previous-year-value';

                projectsContent += `<div><span class="year-label ${yearLabelClass}">${year}:</span> <span class="stat-value ${valueClass}">${formatCurrency(totalProjectsYear, true)}</span></div>`;
                expenditureContent += `<div><span class="year-label ${yearLabelClass}">${year}:</span> <span class="stat-value ${valueClass}">${formatCurrency(totalExpenditureYear)}</span></div>`;
                avgCostContent += `<div><span class="year-label ${yearLabelClass}">${year}:</span> <span class="stat-value ${valueClass}">${formatCurrency(avgCostYear)}</span></div>`;
            });
        }

        if (buildingSummary.length > 0) {
            const activeBuildingSummary = buildingSummary.filter(d => d.completedUnits > 0);
            if (activeBuildingSummary.length > 0) {
                const sortedByCompleted = [...activeBuildingSummary].sort((a, b) => b.completedUnits - a.completedUnits);
                projectsContent += `<div class="additional-insight"><p><strong>최다 작업 동:</strong> ${sortedByCompleted[0].dong} (${formatCurrency(sortedByCompleted[0].completedUnits, true)})</p></div>`;

                const sortedByAvgCost = [...activeBuildingSummary].sort((a, b) => b.avgAmountPerUnit - a.avgAmountPerUnit);
                 avgCostContent += `<div class="additional-insight"><p><strong>평균 비용 최고 동:</strong> ${sortedByAvgCost[0].dong} (${formatCurrency(sortedByAvgCost[0].avgAmountPerUnit)})</p>`;
                if (sortedByAvgCost.length > 1) {
                    avgCostContent += `<p><strong>평균 비용 최저 동:</strong> ${sortedByAvgCost[sortedByAvgCost.length - 1].dong} (${formatCurrency(sortedByAvgCost[sortedByAvgCost.length - 1].avgAmountPerUnit)})</p></div>`;
                } else {
                    avgCostContent += `</div>`;
                }
            }
        }

        if (workTypeSummary.length > 0) {
            const activeWorkTypeSummary = workTypeSummary.filter(wt => wt.totalWorkCount > 0);
            if (activeWorkTypeSummary.length > 0) {
                const sortedByCount = [...activeWorkTypeSummary].sort((a, b) => b.totalWorkCount - a.totalWorkCount);
                const totalOverallWorkCount = activeWorkTypeSummary.reduce((sum, wt) => sum + wt.totalWorkCount, 0);

                projectsContent += `<div class="additional-insight"><p><strong>주요 작업 유형 (건수):</strong></p>`;
                sortedByCount.slice(0,3).forEach(wt => {
                    const percentage = totalOverallWorkCount > 0 ? ((wt.totalWorkCount / totalOverallWorkCount) * 100).toFixed(1) : 0;
                    projectsContent += `<p>- ${wt.workType}: ${formatCurrency(wt.totalWorkCount, true)} (${percentage}%)</p>`;
                });
                projectsContent += `</div>`;

                const sortedByTotalPO = [...activeWorkTypeSummary].sort((a, b) => b.totalPOAmount - a.totalPOAmount);
                expenditureContent += `<div class="additional-insight"><p><strong>주요 작업 유형 (집행 금액):</strong></p>`;
                sortedByTotalPO.slice(0,3).forEach(wt => {
                     expenditureContent += `<p>- ${wt.workType}: ${formatCurrency(wt.totalPOAmount)}</p>`;
                });
                expenditureContent += `</div>`;


                const workTypeAvgCosts = activeWorkTypeSummary.map(wt => ({
                    workType: wt.workType,
                    avgCost: wt.totalWorkCount > 0 ? Math.round(wt.totalPOAmount / wt.totalWorkCount) : 0
                })).filter(wt => wt.avgCost > 0).sort((a,b) => b.avgCost - a.avgCost);

                if (workTypeAvgCosts.length > 0) {
                    avgCostContent += `<div class="additional-insight"><p><strong>작업 유형별 평균 비용:</strong></p>`;
                    avgCostContent += `<p>- 최고: ${workTypeAvgCosts[0].workType} (${formatCurrency(workTypeAvgCosts[0].avgCost)})</p>`;
                    if (workTypeAvgCosts.length > 1) {
                         avgCostContent += `<p>- 최저: ${workTypeAvgCosts[workTypeAvgCosts.length - 1].workType} (${formatCurrency(workTypeAvgCosts[workTypeAvgCosts.length - 1].avgCost)})</p></div>`;
                    } else {
                        avgCostContent += `</div>`;
                    }
                }

            }
        }

        if (annualSummary.length > 0) {
            const activeAnnualSummary = annualSummary.filter(y => y.totalWorkCount > 0);
            if (activeAnnualSummary.length > 0) {
                const highestWorkCountYear = [...activeAnnualSummary].sort((a, b) => b.totalWorkCount - a.totalWorkCount)[0];
                projectsContent += `<div class="additional-insight"><p><strong>최다 작업 연도:</strong> ${highestWorkCountYear.year} (${formatCurrency(highestWorkCountYear.totalWorkCount, true)})</p></div>`;
            }
        }

        statTotalProjectsEl.innerHTML = projectsContent || '0건';
        statTotalExpenditureEl.innerHTML = expenditureContent || '0원';
        statAvgProjectCostEl.innerHTML = avgCostContent || '0원';

        const noteDong9El = document.getElementById('noteDong9');
        if (noteDong9El) {
            const dong9Data = dataBuildingSummaryRaw.find(d => d.dong === "9동");
            if (dong9Data && dong9Data.totalUnits !== "N/A" && dong9Data.completedUnits > dong9Data.totalUnits) {
                noteDong9El.textContent = `9동의 경우 완료 세대수(${dong9Data.completedUnits})가 전체 세대수(${dong9Data.totalUnits})를 초과합니다. 데이터 확인이 필요할 수 있습니다.`;
                noteDong9El.style.display = 'list-item';
            } else {
                 noteDong9El.textContent = `데이터를 기반으로 동별 세대수 초과 여부를 확인합니다.`;
            }
        }
    }

    function populateTable(tableId, data, columns, isModal = false) {
        const table = document.getElementById(tableId);
        if (!table) {
            console.error(`Table with ID '${tableId}' not found.`);
            return;
        }
        let tableBody = table.getElementsByTagName('tbody')[0];
        if (!tableBody) {
            tableBody = document.createElement('tbody');
            table.appendChild(tableBody);
        }
        tableBody.innerHTML = '';

        if (isModal && data.length > 0) {
            let tableHead = table.getElementsByTagName('thead')[0];
            if (!tableHead) {
                tableHead = document.createElement('thead');
                table.insertBefore(tableHead, tableBody);
            }
            tableHead.innerHTML = '';
            const headerRow = tableHead.insertRow();
            // For modal, use the currently defined masterCsvHeaders' names
            const modalHeaders = masterCsvHeaders.map(h => h.name);
            modalHeaders.forEach(key => {
                const th = document.createElement('th');
                th.textContent = key;
                headerRow.appendChild(th);
            });
             columns = modalHeaders; // Use these headers for data access
        }

        data.forEach(item => {
            const row = tableBody.insertRow();
            columns.forEach(colNameOrObj => { // col can be string (from main table) or object (from modal)
                const cell = row.insertCell();
                const colKey = typeof colNameOrObj === 'string' ? colNameOrObj : colNameOrObj; // Get the actual key name
                let value = item[colKey];


                if (value === 0 && (colKey.toLowerCase().includes('amount') || colKey.toLowerCase().includes('금액') || colKey === 'completedUnits' || colKey === 'totalWorkCount' || colKey === 'avgAmountPerUnit')) {
                    cell.textContent = "-";
                    cell.classList.add('text-zero-as-dash');
                } else if (isModal && colKey === getHeaderName("PO금액")) {
                     value = formatCurrency(parseFloat(String(value).replace(/,/g, '')) || 0);
                     cell.classList.add('number-cell');
                     cell.textContent = value;
                } else if (!isModal && (colKey.toLowerCase().includes('amount') || colKey.toLowerCase().includes('금액'))) {
                    value = formatCurrency(value);
                    cell.classList.add('number-cell');
                    cell.textContent = value;
                } else if (!isModal && colKey.toLowerCase().includes('rate')) {
                    if (value === "N/A") {
                        cell.textContent = "N/A";
                        cell.classList.add('text-na'); 
                    } else if (value === 0 || value === "0%" || parseFloat(value) === 0) {
                        cell.textContent = "-";
                        cell.classList.add('text-zero-as-dash');
                    }
                    else {
                        value = `${parseFloat(value).toFixed(2)}%`; // Ensure consistent formatting for percentages
                        cell.textContent = value;
                    }
                    cell.classList.add('number-cell');
                    if (cell.textContent === "N/A" || cell.textContent === "-") {
                        cell.classList.add('text-center'); 
                        cell.classList.remove('number-cell'); 
                    }
                } else if (!isModal && colKey === 'totalUnits') { 
                     cell.style.textAlign = 'center';
                     if (value === "N/A") {
                        cell.textContent = "N/A";
                        cell.classList.add('text-na'); 
                     } else if (value === 0) {
                        cell.textContent = "-";
                        cell.classList.add('text-zero-as-dash');
                     }
                     else {
                        cell.textContent = String(value);
                     }
                } else if (!isModal && (colKey === '완료 세대수' || colKey === '총 작업 건수' || colKey === 'completedUnits' || colKey === 'totalWorkCount')) {
                     if (value === 0) {
                        cell.textContent = "-";
                        cell.classList.add('text-zero-as-dash');
                     } else {
                        cell.textContent = String(value); 
                     }
                     cell.style.textAlign = 'center';
                } else {
                    cell.style.textAlign = 'center';
                    const headerForAlignment = masterCsvHeaders.find(h => h.name === colKey);
                    if (isModal && (headerForAlignment?.name === getHeaderName('계약명') || headerForAlignment?.name === getHeaderName('PO번호') || headerForAlignment?.name === getHeaderName('PR번호') || headerForAlignment?.name === getHeaderName('매입 마감 (월)'))) {
                        cell.style.textAlign = 'left';
                    } else if (!isModal && (colKey === '동' || colKey === '작업유형' || colKey === '회계연도' || colKey === 'dong' || colKey === 'workType' || colKey === 'year')) {
                        cell.style.textAlign = 'left';
                    }
                    cell.textContent = value;
                }
                 if (isModal) { 
                    cell.style.whiteSpace = 'nowrap';
                }
            });
        });
    }

    // --- Chart Creation and Update Functions ---
    function createOrUpdateChart(chartId, chartType, data, chartOptions) {
        const canvasEl = document.getElementById(chartId);
        if (!canvasEl) {
            console.error(`Canvas element with ID '${chartId}' not found.`);
            const errorPlaceholder = document.createElement('p');
            errorPlaceholder.className = 'text-red-500 text-center p-4';
            errorPlaceholder.textContent = `차트 영역 ('${chartId}')을 찾을 수 없습니다.`;
            const container = document.querySelector('.chart-container canvas#' + chartId)?.parentElement || document.getElementById(chartId)?.parentElement || document.body;
            if (document.getElementById(chartId) && document.getElementById(chartId).parentElement) {
                 document.getElementById(chartId).parentElement.innerHTML = '';
                 document.getElementById(chartId).parentElement.appendChild(errorPlaceholder);
            } else if(container) {
                container.innerHTML = '';
                container.appendChild(errorPlaceholder);
            }
            return;
        }

        if (typeof Chart === 'undefined') {
            console.error("Chart.js is not loaded. Cannot create chart:", chartId);
            canvasEl.parentElement.innerHTML = `<p class="text-red-500 text-center p-4">Chart.js 라이브러리를 로드하지 못했습니다. 차트를 표시할 수 없습니다.</p>`;
            return;
        }

        const ctx = canvasEl.getContext('2d');
        if (charts[chartId]) {
            charts[chartId].destroy();
        }
        try {
            const finalOptions = {
                ...chartOptions,
                onClick: (event, elements) => {
                    const chartInstance = Chart.getChart(ctx); 
                    if (elements.length > 0) { 
                        if (currentPopupChartId) return; 
                        const elementIndex = elements[0].index;
                        const datasetIndex = elements[0].datasetIndex;
                        handleChartClick(chartInstance, datasetIndex, elementIndex, chartId);
                    } else { 
                        openChartInPopup(chartId, canvasEl);
                    }
                }
            };

            charts[chartId] = new Chart(ctx, {
                type: chartType,
                data: data,
                options: finalOptions
            });
        } catch (error) {
            console.error(`Error creating chart '${chartId}':`, error);
            canvasEl.parentElement.innerHTML = `<p class="text-red-500 text-center p-4">차트 ('${chartId}') 생성 중 오류 발생: ${error.message}</p>`;
        }
    }
    
    function openChartInPopup(originalChartId, originalCanvas) {
        if (currentPopupChartId) { 
            closeChartPopup();
        }

        currentPopupChartId = originalChartId;
        currentPopupElement = document.getElementById('chartPopupOverlay');
        const popupContent = document.getElementById('chartPopupContent');
        const popupTitleEl = document.getElementById('chartPopupTitle');
        const popupCanvas = document.getElementById('popupChartCanvas');
        const popupCloseButton = document.getElementById('chartPopupCloseButton');

        if (!currentPopupElement || !popupContent || !popupTitleEl || !popupCanvas || !popupCloseButton) {
            console.error("Popup elements not found.");
            return;
        }

        const originalChartInstance = charts[originalChartId];
        let titleForPopup = originalChartId; 
        if (originalChartInstance && originalChartInstance.options && originalChartInstance.options.plugins && originalChartInstance.options.plugins.title && originalChartInstance.options.plugins.title.text) {
            titleForPopup = originalChartInstance.options.plugins.title.text;
        } else {
            const htmlTitleElement = document.getElementById(originalChartId.replace('chart', '') + 'Title'); 
            if (htmlTitleElement) {
                 titleForPopup = htmlTitleElement.textContent || htmlTitleElement.innerText; 
            }
        }
        popupTitleEl.textContent = titleForPopup; 
        
        currentPopupElement.style.display = 'flex';

        if (originalChartInstance) {
            if (popupChartInstance) {
                popupChartInstance.destroy();
            }
            const popupCtx = popupCanvas.getContext('2d');
            const configToClone = originalChartInstance.config;
            
            let clonedData = {};
            try {
                clonedData = JSON.parse(JSON.stringify(configToClone.data || {labels:[], datasets:[]}));
            } catch (e) {
                console.error("Error cloning chart data, using empty.", e);
                 clonedData = { labels: [], datasets: [] }; 
            }

            let clonedOptions = { responsive: true, maintainAspectRatio: false, plugins: { title: {} } }; 
            if (configToClone.options && typeof configToClone.options === 'object') {
                try {
                    clonedOptions = typeof structuredClone === 'function' 
                                    ? structuredClone(configToClone.options) 
                                    : JSON.parse(JSON.stringify(configToClone.options));
                    if (typeof clonedOptions !== 'object' || clonedOptions === null) { 
                        clonedOptions = { responsive: true, maintainAspectRatio: false, plugins: { title: {} } };
                    }
                } catch (e) {
                    console.error("Error during JSON cloning of chart options, using fresh default:", e);
                     clonedOptions = { responsive: true, maintainAspectRatio: false, plugins: { title: {} } }; 
                }
            }
            
            if (!clonedOptions.plugins) {
                clonedOptions.plugins = {};
            }
            if (!clonedOptions.plugins.title) {
                clonedOptions.plugins.title = {}; 
            }
            
            clonedOptions.plugins.title.display = true; 
            clonedOptions.plugins.title.text = titleForPopup;
            
            popupChartInstance = new Chart(popupCtx, {
                type: configToClone.type,
                data: clonedData, 
                options: { 
                    ...clonedOptions, 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    onClick: (event, elements) => { 
                        if (elements.length > 0) {
                            const elementIndex = elements[0].index;
                            const datasetIndex = elements[0].datasetIndex;
                            handleChartClick(popupChartInstance, datasetIndex, elementIndex, originalChartId); 
                            // Do NOT close popup automatically here, user closes manually
                        }
                    }
                } 
            });
            setTimeout(() => { 
                if(popupChartInstance) {
                    try {
                        popupChartInstance.resize();
                    } catch(e) {
                        console.error("Error resizing popup chart:", e);
                    }
                }
            }, 250); 
        }

        popupCloseButton.onclick = closeChartPopup;
        currentPopupElement.onclick = (event) => { 
            if (event.target === currentPopupElement) {
                closeChartPopup();
            }
        };

        const popupHeader = popupContent.querySelector('.chart-popup-header');
        const resizeHandles = {
            se: popupContent.querySelector('.resize-handle-se'),
            s: popupContent.querySelector('.resize-handle-s'),
            e: popupContent.querySelector('.resize-handle-e')
        };
        
        let startX, startY, startWidth, startHeight, dragStartX, dragOffsetY;

        if (popupHeader) {
            popupHeader.onmousedown = function(e) {
                if (e.target.classList.contains('chart-popup-close-button')) return; 
                isDraggingPopupHeader = true;
                dragOffsetX = e.clientX - popupContent.offsetLeft;
                dragOffsetY = e.clientY - popupContent.offsetTop;
                document.documentElement.addEventListener('mousemove', dragPopup, false);
                document.documentElement.addEventListener('mouseup', stopDragPopupHeader, false);
            };
        }

        function dragPopup(e) {
            if (!isDraggingPopupHeader) return;
            popupContent.style.left = (e.clientX - dragOffsetX) + 'px';
            popupContent.style.top = (e.clientY - dragOffsetY) + 'px';
        }
        function stopDragPopupHeader() {
            isDraggingPopupHeader = false;
            document.documentElement.removeEventListener('mousemove', dragPopup, false);
            document.documentElement.removeEventListener('mouseup', stopDragPopupHeader, false);
        }


        Object.values(resizeHandles).forEach(handle => {
            if (!handle) return;
            handle.onmousedown = function(e) {
                e.preventDefault();
                e.stopPropagation(); 
                isResizingPopup = true;
                startX = e.clientX;
                startY = e.clientY;
                startWidth = parseInt(document.defaultView.getComputedStyle(popupContent).width, 10);
                startHeight = parseInt(document.defaultView.getComputedStyle(popupContent).height, 10);
                document.documentElement.addEventListener('mousemove', doResizePopup, false);
                document.documentElement.addEventListener('mouseup', stopResizePopup, false);
            };
        });

        function doResizePopup(e) {
            if (!isResizingPopup) return;
            let newWidth = startWidth;
            let newHeight = startHeight;

            if (e.target.classList.contains('resize-handle-e') || e.target.classList.contains('resize-handle-se')) {
                newWidth = startWidth + (e.clientX - startX);
            }
            if (e.target.classList.contains('resize-handle-s') || e.target.classList.contains('resize-handle-se')) {
                newHeight = startHeight + (e.clientY - startY);
            }
            
            popupContent.style.width = Math.max(300, newWidth) + 'px'; 
            popupContent.style.height = Math.max(200, newHeight) + 'px'; 
            if (popupChartInstance) {
                popupChartInstance.resize();
            }
        }

        function stopResizePopup() {
            isResizingPopup = false;
            document.documentElement.removeEventListener('mousemove', doResizePopup, false);
            document.documentElement.removeEventListener('mouseup', stopResizePopup, false);
        }
    }

    function closeChartPopup() {
        if (currentPopupElement) {
            currentPopupElement.style.display = 'none';
        }
        if (popupChartInstance) {
            popupChartInstance.destroy();
            popupChartInstance = null;
        }
        currentPopupChartId = null;
        currentPopupElement = null;
    }


    const commonChartOptions = (titleText, chartIdForTooltipContext) => ({ 
        responsive: true,
        maintainAspectRatio: false, 
        plugins: {
            title: { display: !!titleText, text: String(titleText || ''), font: { size: 16 } }, 
            legend: { position: 'top' },
            tooltip: {
                bodyFont: { size: 14 * 1.3 },
                titleFont: { size: 16 * 1.3 },
                padding: 10 * 1.3,
                callbacks: {
                    label: function(context) {
                        let label = context.dataset.label || '';
                        if (label) { label += ': '; }
                        if (context.parsed.y !== null) {
                            const datasetLabel = context.dataset.label.toLowerCase();
                            const yAxisID = context.dataset.yAxisID;
                             const isCountChart = chartIdForTooltipContext === 'chartYearDongCount' ||
                                                 chartIdForTooltipContext === 'chartYearWorkTypeCount' ||
                                                 (chartIdForTooltipContext === 'chartDongWorkTypeFinanceCount' && datasetLabel.includes('건수'));

                            if (context.parsed.y === 0 && yAxisID !== 'yPercentage') { 
                                label += "-";
                            } else if (yAxisID === 'yPercentage') {
                                 label += context.parsed.y === 0 ? "-" : context.parsed.y.toFixed(2) + '%';
                            } else if (
                                datasetLabel.includes('건수') ||
                                datasetLabel.includes('세대수') ||
                                yAxisID === 'yCount' || yAxisID === 'yBar' || 
                                isCountChart
                            ) {
                                label += formatCurrency(context.parsed.y, true);
                            } else {
                                label += formatCurrency(context.parsed.y);
                            }
                        } else if (context.parsed !== null && (context.chart.config.type === 'pie' || context.chart.config.type === 'doughnut')) {
                           if (context.parsed === 0) {
                               label += "-";
                           } else {
                               label += formatCurrency(context.parsed, true);
                           }
                        }
                        return label;
                    }
                }
            },
            datalabels: {
                display: false,
            }
        },
        scales: {
            y: {
                beginAtZero: true,
                ticks: { 
                    callback: function(value) { 
                        if (value === 0) return "-";
                        return formatCurrency(value); 
                    } 
                }
            },
            x: { ticks: { autoSkip: false, maxRotation: 45, minRotation: 0, callback: function(value, index, ticks) {
                        const label = this.getLabelForValue(value);
                        if (typeof label === 'string' && label.length > 10) {
                            return label.substring(0, 10) + '...';
                        }
                        return label;
                    }
                }
            }
        },
        elements: {
            line: {
                tension: 0.1,
                pointRadius: 6,
                pointHoverRadius: 7.2,
                pointBackgroundColor: 'rgba(255, 99, 132, 0.8)',
                pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
            },
            bar: {}
        }
    });

    const pieChartOptions = (titleText, chartIdForTooltipContext) => ({ 
        responsive: true,
        maintainAspectRatio: false,
        plugins: {
            title: { display: true, text: String(titleText || ''), font: {size: 16} },
            legend: {position: 'top'},
            tooltip: {
                bodyFont: { size: 14 * 1.3 },
                titleFont: { size: 16 * 1.3 },
                padding: 10 * 1.3,
                callbacks: {
                    label: function(context) {
                        let label = context.label || '';
                        const dataIndex = context.dataIndex;
                        const dataset = context.chart.config.data.datasets[0];
                        const count = dataset.data[dataIndex];

                        const workTypeData = dataWorkTypeSummaryRaw.find(item => item.workType === context.label);
                        const amount = workTypeData ? workTypeData.totalPOAmount : 0;

                        if (label) { label += ': '; }
                        label += `${count === 0 ? '-' : formatCurrency(count, true)}, ${amount === 0 ? '-' : formatCurrency(amount)}`;
                        return label;
                    }
                }
            },
            datalabels: {
                 formatter: (value, ctx) => {
                    if (value === 0) return ''; // Don't display label for 0
                    let sum = 0;
                    let dataArr = ctx.chart.data.datasets[0].data;
                    dataArr.map(data => { sum += data; });
                    let percentage = (value*100 / sum).toFixed(1)+"%";
                    return percentage;
                },
                color: '#fff',
                font: { weight: 'bold', size: 10 }
            }
        },
        elements: {
            arc: {
                hoverOffset: 8,
                hoverBorderColor: 'rgba(220, 20, 60, 1)',
                hoverBorderWidth: 2
            }
        }
    });

    function updateBuildingCharts(data, titleSuffix) {
        createOrUpdateChart('chartBuildingCompleted', 'bar', {
            labels: data.map(d => d.dong),
            datasets: [
                { label: '완료 세대수', data: data.map(d => d.completedUnits), backgroundColor: 'rgba(54, 162, 235, 0.7)', borderColor: 'rgba(54, 162, 235, 1)', borderWidth: 1, yAxisID: 'y'},
                {
                    label: '진행률 (%)',
                    data: data.map(d => d.progressRate === "N/A" ? null : d.progressRate), // Handle "N/A" for chart data
                    type: 'line',
                    borderColor: 'rgba(75, 192, 192, 1)',
                    backgroundColor: 'rgba(75, 192, 192, 0.2)',
                    yAxisID: 'yPercentage',
                    tension: 0.1,
                    pointRadius: 6, pointHoverRadius: 7.2,
                    pointBackgroundColor: 'rgba(75, 192, 192, 0.8)', pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
                }
            ]
        }, { ...commonChartOptions(`동별 완료 세대수 및 진행률${titleSuffix}`, 'chartBuildingCompleted'), scales: {
                y: { type: 'linear', display: true, position: 'left', title: {display: true, text: '세대수'}, ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value; } } },
                yPercentage: { type: 'linear', display: true, position: 'right', title: {display: true, text: '진행률 (%)'}, grid: { drawOnChartArea: false }, ticks: {callback: function(value) { if (value === 0) return "-"; return value + "%";}}}
            }
        });

        createOrUpdateChart('chartBuildingFinanceCombination', 'bar', {
            labels: data.map(d => d.dong),
            datasets: [
                {
                    label: '총 PO금액',
                    data: data.map(d => d.totalPOAmount),
                    backgroundColor: 'rgba(255, 159, 64, 0.7)',
                    borderColor: 'rgba(255, 159, 64, 1)',
                    borderWidth: 1,
                    yAxisID: 'yAmount',
                    order: 2
                },
                {
                    label: '세대당 평균금액',
                    data: data.map(d => d.avgAmountPerUnit),
                    type: 'line',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    backgroundColor: 'rgba(255, 99, 132, 0.2)',
                    yAxisID: 'yAvgAmount',
                    tension: 0.1,
                    order: 1,
                    pointRadius: 6, pointHoverRadius: 7.2,
                    pointBackgroundColor: 'rgba(255, 99, 132, 0.8)', pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
                }
            ]
        }, {
            ...commonChartOptions(`동별 총 PO금액 및 세대당 평균금액${titleSuffix}`, 'chartBuildingFinanceCombination'),
            scales: {
                yAmount: { type: 'linear', display: true, position: 'left', title: {display: true, text: '총 PO금액 (원)'}, ticks: {callback: function(value) { if (value === 0) return "-"; return formatCurrency(value);}}},
                yAvgAmount: { type: 'linear', display: true, position: 'right', title: {display: true, text: '세대당 평균금액 (원)'}, grid: { drawOnChartArea: false }, ticks: {callback: function(value) {if (value === 0) return "-"; return formatCurrency(value);}}}
            }
        });
    }

    function updateWorkTypeCharts(data, selectedDongs, selectedWorkTypes, titleSuffix) {
        createOrUpdateChart('chartWorkTypeCombination', 'bar', {
            labels: data.map(d => d.workType),
            datasets: [
                {
                    label: '총 작업 건수',
                    data: data.map(d => d.totalWorkCount),
                    backgroundColor: 'rgba(54, 162, 235, 0.7)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1,
                    yAxisID: 'yCount',
                    order: 2
                },
                {
                    label: '총 PO금액 (원)',
                    data: data.map(d => d.totalPOAmount),
                    type: 'line',
                    borderColor: 'rgba(255, 159, 64, 1)',
                    backgroundColor: 'rgba(255, 159, 64, 0.2)',
                    yAxisID: 'yAmount',
                    tension: 0.1,
                    order: 1,
                    pointRadius: 6, pointHoverRadius: 7.2,
                    pointBackgroundColor: 'rgba(255, 159, 64, 0.8)', pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
                }
            ]
        }, {
            ...commonChartOptions(`작업 유형별 건수 및 총 PO 금액${titleSuffix}`, 'chartWorkTypeCombination'),
            scales: {
                yCount: { type: 'linear', display: true, position: 'left', title: { display: true, text: '총 작업 건수' }, ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value; }}},
                yAmount: { type: 'linear', display: true, position: 'right', title: { display: true, text: '총 PO금액 (원)'}, grid: { drawOnChartArea: false }, ticks: { callback: function(value) {if (value === 0) return "-"; return formatCurrency(value);}}}
            }
        });

        const progressChartContainer = document.getElementById('chartDongWorkTypeProgressContainer');
        const progressPlaceholder = document.getElementById('dongWorkTypeProgressPlaceholder');
        const progressTitleEl = document.getElementById('dongWorkTypeProgressTitle'); 
        
        const dongsForProgress = selectedDongs.length > 0 ? selectedDongs : allDongsGlobal;
        const workTypesForProgress = selectedWorkTypes.length > 0 ? selectedWorkTypes : allWorkTypesGlobal;


        if (dongsForProgress.length > 0 && workTypesForProgress.length > 0 && masterCsvHeaders.length > 0) {
            let totalUnitsForSelectedDongs = 0;
            let validDongsForProgressCount = 0;
            dongsForProgress.forEach(dongName => {
                const units = totalUnitsPerDongStatic[dongName];
                if (units !== null && units > 0) { 
                    totalUnitsForSelectedDongs += units;
                    validDongsForProgressCount++;
                }
            });

            if (validDongsForProgressCount === 0) { 
                if (progressChartContainer) progressChartContainer.style.display = 'none';
                if (progressPlaceholder) {
                    progressPlaceholder.style.display = 'block';
                    progressPlaceholder.textContent = '선택된 동의 전체 세대수 정보가 없어 진척률을 계산할 수 없습니다.';
                }
                if (progressTitleEl) progressTitleEl.innerHTML = formatTitleWithSuffix('동 및 작업 유형별 진척률', true);
                if (charts['chartDongWorkTypeProgress']) {
                    charts['chartDongWorkTypeProgress'].destroy();
                    delete charts['chartDongWorkTypeProgress'];
                }
                return; 
            }
            
            progressChartContainer.style.display = 'block';
            if(progressPlaceholder) progressPlaceholder.style.display = 'none';

            let chartTitleText = "";
             if (dongsForProgress.length === 1 && workTypesForProgress.length === 1) {
                const dongName = dongsForProgress[0];
                const workTypeName = workTypesForProgress[0];
                const singleDongUnits = totalUnitsPerDongStatic[dongName];
                chartTitleText = `${dongName} (${singleDongUnits === null || singleDongUnits <= 0 ? "세대수 미정의" : singleDongUnits + "세대"}) - ${workTypeName}: 연도별 진척 현황`;
            } else {
                let dongText = dongsForProgress.length > 1 ? `${dongsForProgress.length}개 동` : (dongsForProgress.length === 1 ? dongsForProgress[0] : "선택된 동");
                if (dongsForProgress.length === allDongsGlobal.length && allDongsGlobal.length > 1) dongText = "전체 동";

                let workTypeText = workTypesForProgress.length > 1 ? `${workTypesForProgress.length}개 유형` : (workTypesForProgress.length === 1 ? workTypesForProgress[0] : "선택된 유형");
                if (workTypesForProgress.length === allWorkTypesGlobal.length && allWorkTypesGlobal.length > 1) workTypeText = "전체 유형";
                
                chartTitleText = `${dongText} & ${workTypeText} 종합: 연도별 진척 현황 (총 ${totalUnitsForSelectedDongs}세대 기준)`;
            }
            if(progressTitleEl) progressTitleEl.innerHTML = formatTitleWithSuffix(chartTitleText, true); // Apply subtitle style

            let cumulativeCount = 0;
            const workTypeProgressData = allYearsGlobal.map(year => {
                const countForYear = masterRawEntries.filter(e =>
                    dongsForProgress.includes(e[getHeaderName("건물동")] ? e[getHeaderName("건물동")].replace('사택 ','').trim() : '') &&
                    workTypesForProgress.includes(e[getHeaderName("작업유형")]) &&
                    e[getHeaderName("회계 연도")] === year
                ).length;
                cumulativeCount += countForYear;
                const progress = totalUnitsForSelectedDongs > 0 ? (cumulativeCount / totalUnitsForSelectedDongs) * 100 : 0;
                return { year, count: countForYear, progress: parseFloat(progress.toFixed(2)), cumulativeCount };
            });

            createOrUpdateChart('chartDongWorkTypeProgress', 'bar', {
                labels: workTypeProgressData.map(d => d.year),
                datasets: [
                    {
                        label: '연도별 작업 건수',
                        data: workTypeProgressData.map(d => d.count),
                        backgroundColor: 'rgba(54, 162, 235, 0.7)',
                        yAxisID: 'yCount',
                    },
                     {
                        label: '누적 작업 건수',
                        data: workTypeProgressData.map(d => d.cumulativeCount),
                        type: 'line',
                        borderColor: 'rgba(153, 102, 255, 1)',
                        backgroundColor: 'rgba(153, 102, 255, 0.2)',
                        yAxisID: 'yCount',
                        tension: 0.1,
                        order: 1,
                        pointRadius: 6, pointHoverRadius: 7.2,
                        pointBackgroundColor: 'rgba(153, 102, 255, 0.8)', pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
                    },
                    {
                        label: '누적 진척률 (%)',
                        data: workTypeProgressData.map(d => d.progress),
                        type: 'line',
                        borderColor: 'rgba(75, 192, 192, 1)',
                        backgroundColor: 'rgba(75, 192, 192, 0.2)',
                        yAxisID: 'yPercentage',
                        tension: 0.1,
                        order: 0,
                        pointRadius: 6, pointHoverRadius: 7.2,
                        pointBackgroundColor: 'rgba(75, 192, 192, 0.8)', pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
                    }
                ]
            }, {
                ...commonChartOptions(chartTitleText, 'chartDongWorkTypeProgress'), 
                plugins: { 
                    ...commonChartOptions(chartTitleText, 'chartDongWorkTypeProgress').plugins,
                    title: { display: false } 
                },
                scales: {
                    yCount: { type: 'linear', display: true, position: 'left', title: {display: true, text: '작업 건수'}, ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value; } } },
                    yPercentage: { type: 'linear', display: true, position: 'right', title: {display: true, text: '누적 진척률 (%)'}, grid: { drawOnChartArea: false }, ticks: {callback: function(value) { if (value === 0) return "-"; return value.toFixed(2) + "%"; }}}
                }
            });

        } else {
            if (progressChartContainer) progressChartContainer.style.display = 'none';
            if (progressPlaceholder) {
                progressPlaceholder.style.display = 'block';
                progressPlaceholder.textContent = '건물 동과 작업 유형을 선택하여 (다중 선택 가능) 연도별 종합 진척률을 확인하세요.';
            }
            if (progressTitleEl) progressTitleEl.innerHTML = formatTitleWithSuffix('동 및 작업 유형별 진척률', true);
             if (charts['chartDongWorkTypeProgress']) {
                charts['chartDongWorkTypeProgress'].destroy();
                delete charts['chartDongWorkTypeProgress'];
            }
        }
    }

    // New chart update function
    function updateDongWorkTypeFinanceAndCountChart(data, titleSuffix) {
        const chartWrapper = document.getElementById('dongWorkTypeFinanceCountChartWrapper');
        const chartContainer = document.getElementById('chartDongWorkTypeFinanceCountContainer');
        const placeholder = document.getElementById('dongWorkTypeFinanceCountPlaceholder');
        // const chartTitleEl = document.getElementById('dongWorkTypeFinanceCountTitle'); // This HTML h3 was removed.

        if (!chartContainer || !placeholder || !chartWrapper) { 
            console.error("DongWorkTypeFinanceCount chart elements (container or placeholder) not found.");
            return;
        }

        const filteredData = data.filter(d => d.totalPOAmount > 0 || d.totalWorkCount > 0);
        const chartFullTitle = `동별 집행비 및 작업 건수${titleSuffix}`; 

        if (filteredData.length === 0) {
            chartContainer.style.display = 'none';
            placeholder.style.display = 'block';
            if (charts['chartDongWorkTypeFinanceCount']) {
                charts['chartDongWorkTypeFinanceCount'].destroy();
                delete charts['chartDongWorkTypeFinanceCount'];
            }
            createOrUpdateChart('chartDongWorkTypeFinanceCount', 'bar', { labels: [], datasets: [] }, 
                commonChartOptions(chartFullTitle + ' (데이터 없음)', 'chartDongWorkTypeFinanceCount')
            );
            return;
        }

        chartContainer.style.display = 'block';
        placeholder.style.display = 'none';

        createOrUpdateChart('chartDongWorkTypeFinanceCount', 'bar', {
            labels: filteredData.map(d => d.dong),
            datasets: [
                {
                    label: '총 PO금액 (원)',
                    data: filteredData.map(d => d.totalPOAmount),
                    backgroundColor: 'rgba(255, 159, 64, 0.7)', // Orange
                    borderColor: 'rgba(255, 159, 64, 1)',
                    yAxisID: 'yAmount',
                    order: 2 
                },
                {
                    label: '총 작업 건수',
                    data: filteredData.map(d => d.totalWorkCount),
                    type: 'line',
                    borderColor: 'rgba(54, 162, 235, 1)', // Blue
                    backgroundColor: 'rgba(54, 162, 235, 0.2)',
                    yAxisID: 'yCount',
                    tension: 0.1,
                    order: 1, 
                    pointRadius: 6,
                    pointHoverRadius: 7.2,
                    pointBackgroundColor: 'rgba(54, 162, 235, 0.8)',
                    pointHoverBackgroundColor: 'rgba(30, 144, 255, 1)' 
                }
            ]
        }, {
            ...commonChartOptions(chartFullTitle, 'chartDongWorkTypeFinanceCount'), 
            scales: {
                yAmount: { 
                    type: 'linear',
                    display: true,
                    position: 'left',
                    title: { display: true, text: '총 PO금액 (원)' },
                    ticks: { callback: function(value) { if (value === 0) return "-"; return formatCurrency(value); } }
                },
                yCount: { 
                    type: 'linear',
                    display: true,
                    position: 'right',
                    title: { display: true, text: '총 작업 건수' },
                    grid: { drawOnChartArea: false }, 
                    ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value + '건'; return value; } }
                },
                x: { ...commonChartOptions(null, 'chartDongWorkTypeFinanceCount').scales.x } 
            }
        });
    }


    function updateAnnualCharts(data) {
        const filterYearEl = document.getElementById(`filter-select-${getHeaderName("회계 연도").replace(/\s+/g, '_')}`);
        const selectedYears = filterYearEl ? getSelectedOptions(filterYearEl) : [];
        
        let titleSuffix;
        let dataToPlot = data;

         if (selectedYears.length > 0) {
            titleSuffix = ` (${selectedYears.join(', ')} 필터 적용)`;
        } else if (allYearsGlobal.length > 0) {
            const latestThreeYears = allYearsGlobal.slice(-3);
            dataToPlot = dataAnnualSummaryRaw.filter(d => latestThreeYears.includes(d.year));
            if (dataToPlot.length > 0) {
                 titleSuffix = ` (최근 ${dataToPlot.length}개년: ${dataToPlot.map(d=>d.year).join(', ')} 기준)`;
            } else {
                 titleSuffix = ' (최근 3개년 데이터 없음)';
            }
        } else {
            titleSuffix = ' (데이터 없음)';
        }


        createOrUpdateChart('chartAnnualCombination', 'bar', {
            labels: dataToPlot.map(d => d.year),
            datasets: [
                {
                    label: '총 작업 건수',
                    data: dataToPlot.map(d => d.totalWorkCount),
                    backgroundColor: 'rgba(54, 162, 235, 0.7)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1,
                    yAxisID: 'yCount',
                    order: 2
                },
                {
                    label: '총 PO금액 (원)',
                    data: dataToPlot.map(d => d.totalPOAmount),
                    type: 'line',
                    borderColor: 'rgba(255, 159, 64, 1)',
                    backgroundColor: 'rgba(255, 159, 64, 0.2)',
                    yAxisID: 'yAmount',
                    tension: 0.1,
                    order: 1,
                    pointRadius: 6, pointHoverRadius: 7.2,
                    pointBackgroundColor: 'rgba(255, 159, 64, 0.8)', pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
                }
            ]
        }, {
            ...commonChartOptions(`연도별 작업 건수 및 총 PO 금액${titleSuffix}`, 'chartAnnualCombination'),
            scales: {
                yCount: { type: 'linear', display: true, position: 'left', title: { display: true, text: '총 작업 건수' }, ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value; }}},
                yAmount: { type: 'linear', display: true, position: 'right', title: { display: true, text: '총 PO금액 (원)'}, grid: { drawOnChartArea: false }, ticks: { callback: function(value) {if (value === 0) return "-"; return formatCurrency(value);}}}
            }
        });
    }

    function updateCrossAnalysisCharts(selectedDongs, selectedYears, selectedWorkTypes) {
        if (masterCsvHeaders.length === 0) {
            console.warn("Master CSV headers not available, skipping cross-analysis charts.");
            ['chartDongWorkTypeCount', 'chartDongWorkTypePO', 'chartYearDongCount', 'chartYearWorkTypeCount'].forEach(chartId => {
                if (charts[chartId]) {
                    charts[chartId].destroy();
                    delete charts[chartId];
                    const canvasEl = document.getElementById(chartId);
                    if (canvasEl && canvasEl.parentElement) {
                        canvasEl.parentElement.innerHTML = `<p class="text-slate-500 text-center p-4">데이터를 불러오거나 필터를 조정해주세요.</p>`;
                    }
                }
            });
            return;
        }
        
        const yearHeaderName = getHeaderName("회계 연도");
        const dongHeaderName = getHeaderName("건물동");
        const workTypeHeaderName = getHeaderName("작업유형");
        const poAmountHeaderName = getHeaderName("PO금액");


        let currentDongsForChart = selectedDongs.length > 0 ? selectedDongs : allDongsGlobal;
        let currentYearsForChart = selectedYears.length > 0 ? selectedYears : allYearsGlobal.slice(-3);
        if (selectedYears.length === 0 && allYearsGlobal.length < 3 && allYearsGlobal.length > 0) {
            currentYearsForChart = allYearsGlobal;
        }
         if (selectedYears.length === 0 && allYearsGlobal.length === 0) {
            currentYearsForChart = [];
        }
        let currentWorkTypesForChart = selectedWorkTypes.length > 0 ? selectedWorkTypes : allWorkTypesGlobal;

        let titleSuffix = '';
        let titleParts = [];

        if (selectedYears.length > 0) {
            titleParts.push(`${selectedYears.join(', ')}년`);
        } else if (currentYearsForChart.length > 0) {
             const yearLabels = currentYearsForChart.length === allYearsGlobal.length && allYearsGlobal.length > 3 ? '전체 기간' : `최근 ${currentYearsForChart.length}개년`;
            titleParts.push(yearLabels);
        }


        if (selectedDongs.length > 0) {
            titleParts.push(`${selectedDongs.join(', ')}동`);
        }
         if (selectedWorkTypes.length > 0) {
            titleParts.push(`${selectedWorkTypes.join(', ')} 유형`);
        }

        if (titleParts.length > 0) {
            titleSuffix = ` (${titleParts.join(' & ')} 기준)`;
        } else if (masterRawEntries.length > 0){
             if (currentYearsForChart.length > 0 && currentYearsForChart.length <=3 && currentYearsForChart.length < allYearsGlobal.length) {
                 titleSuffix = ` (최근 ${currentYearsForChart.length}개년: ${currentYearsForChart.join(', ')} 기준)`;
            } else if (currentYearsForChart.length === allYearsGlobal.length && allYearsGlobal.length > 0) {
                titleSuffix = ' (전체 기간 기준)';
            } else {
                 titleSuffix = ' (전체 데이터 기준)';
            }
        } else {
            titleSuffix = ' (데이터 없음)';
        }


        const dongWorkTypeCountDatasets = currentWorkTypesForChart
            .map((workType, index) => ({
                label: workType,
                data: currentDongsForChart.map(dong => {
                    return masterRawEntries.filter(e =>
                        (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dong &&
                        e[workTypeHeaderName] === workType &&
                        (currentYearsForChart.length === 0 || currentYearsForChart.includes(e[yearHeaderName]))
                    ).length;
                }),
                backgroundColor: getWorkTypeColor(workType)
            }));
        createOrUpdateChart('chartDongWorkTypeCount', 'bar', { labels: currentDongsForChart, datasets: dongWorkTypeCountDatasets },
            {
                ...commonChartOptions(`동별 & 작업유형별 작업 건수${titleSuffix}`, 'chartDongWorkTypeCount'),
                plugins: {
                    ...commonChartOptions(`동별 & 작업유형별 작업 건수${titleSuffix}`, 'chartDongWorkTypeCount').plugins,
                    tooltip: {
                        ...commonChartOptions(`동별 & 작업유형별 작업 건수${titleSuffix}`, 'chartDongWorkTypeCount').plugins.tooltip,
                        callbacks: {
                            label: function(context) {
                                let label = context.dataset.label || '';
                                if (label) { label += ': '; }
                                if (context.parsed.y !== null) {
                                     if (context.parsed.y === 0) label += "-"; else label += formatCurrency(context.parsed.y, true);
                                }
                                return label;
                            }
                        }
                    }
                },
                scales: {
                    x: { ...commonChartOptions(null, 'chartDongWorkTypeCount').scales.x, stacked: true },
                    y: { stacked: true, beginAtZero: true, title: { display: true, text: '작업 건수' }, ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value; } } }
                }
            }
        );

        const dongWorkTypePODatasets = currentWorkTypesForChart
            .map((workType, index) => ({
                label: workType,
                data: currentDongsForChart.map(dong => {
                    return masterRawEntries.filter(e =>
                        (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dong &&
                        e[workTypeHeaderName] === workType &&
                        (currentYearsForChart.length === 0 || currentYearsForChart.includes(e[yearHeaderName]))
                    ).reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0);
                }),
                backgroundColor: getWorkTypeColor(workType)
            }));
        createOrUpdateChart('chartDongWorkTypePO', 'bar', { labels: currentDongsForChart, datasets: dongWorkTypePODatasets },
            {...commonChartOptions(`동별 & 작업유형별 총 PO 금액${titleSuffix}`, 'chartDongWorkTypePO'), scales: {...commonChartOptions(null, 'chartDongWorkTypePO').scales, x: {...commonChartOptions().scales.x, stacked: true}, y: {...commonChartOptions().scales.y, stacked: true, title: {display: true, text: '총 PO 금액 (원)'}, ticks: {callback: function(value){ if(value === 0) return "-"; return formatCurrency(value);}}} }});

        const yearDongCountDatasets = currentDongsForChart
            .map((dong, index) => ({
                label: dong,
                data: currentYearsForChart.map(year => {
                    return masterRawEntries.filter(e =>
                        e[yearHeaderName] === year &&
                        (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dong &&
                        (selectedWorkTypes.length === 0 || selectedWorkTypes.includes(e[workTypeHeaderName]))
                    ).length;
                }),
                borderColor: getDongBorderColor(dong),
                backgroundColor: 'transparent', fill: false, tension: 0.1,
                pointRadius: 6, pointHoverRadius: 7.2,
                pointBackgroundColor: getDongColor(dong),
                pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
            }));
        createOrUpdateChart('chartYearDongCount', 'line', { labels: currentYearsForChart, datasets: yearDongCountDatasets },
            {...commonChartOptions(`연도별 & 동별 작업 건수${titleSuffix}`, 'chartYearDongCount'), scales: {...commonChartOptions(null, 'chartYearDongCount').scales, y: { ...commonChartOptions().scales.y, yAxisID: 'yCount', title: {display: true, text: '작업 건수'}, ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value; } } }}});


        const yearWorkTypeCountDatasets = currentWorkTypesForChart
            .map((workType, index) => ({
                label: workType,
                data: currentYearsForChart.map(year => {
                     return masterRawEntries.filter(e =>
                        e[yearHeaderName] === year &&
                        e[workTypeHeaderName] === workType &&
                        (selectedDongs.length === 0 || selectedDongs.includes(e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : ''))
                    ).length;
                }),
                borderColor: getWorkTypeBorderColor(workType),
                backgroundColor: 'transparent', fill: false, tension: 0.1,
                pointRadius: 6, pointHoverRadius: 7.2,
                pointBackgroundColor: getWorkTypeColor(workType),
                pointHoverBackgroundColor: 'rgba(220, 20, 60, 1)'
            }));
        createOrUpdateChart('chartYearWorkTypeCount', 'line', { labels: currentYearsForChart, datasets: yearWorkTypeCountDatasets },
            {...commonChartOptions(`연도별 & 작업유형별 작업 건수${titleSuffix}`, 'chartYearWorkTypeCount'), scales: {...commonChartOptions(null, 'chartYearWorkTypeCount').scales, y: { ...commonChartOptions().scales.y, yAxisID: 'yCount', title: {display: true, text: '작업 건수'}, ticks: { callback: function(value) { if (value === 0) return "-"; if (Number.isInteger(value)) return value; } } }}});
    }

    // --- CSV and HTML Download/Upload Functions ---
    function generateCsvTemplate() {
        return masterCsvHeaders.map(h => h.name).join(',') + '\n' + 
               masterCsvHeaders.map(h => {
                    switch(h.originalName || h.name) { // Use originalName for matching if available
                        case "회계 연도": return "24년";
                        case "매입 마감 (월)": return "01월31일";
                        case "작업유형": return "샘플 작업 유형";
                        case "건물동": return "1동";
                        case "계약명": return "샘플 계약명";
                        case "PO금액": return "1000000";
                        case "PO번호": return "PO-24-999";
                        case "PR번호": return "PR-24-999";
                        case "전체 세대수": return "50";
                        default: return "";
                    }
               }).join(',') + '\n';
    }

    function downloadFile(content, fileName, contentType) {
        const a = document.createElement("a");
        const file = new Blob(["\uFEFF" + content], { type: contentType }); // Add BOM for Excel
        a.href = URL.createObjectURL(file);
        a.download = fileName;
        a.click();
        URL.revokeObjectURL(a.href);
    }

    function initializeDataFromSource(sourceRawEntries, sourceCsvHeadersConfig, sourceTotalUnits, sourceActiveFilterConfigs) {
        masterRawEntries = JSON.parse(JSON.stringify(sourceRawEntries));
        masterCsvHeaders = JSON.parse(JSON.stringify(sourceCsvHeadersConfig)); 
        totalUnitsPerDongStatic = JSON.parse(JSON.stringify(sourceTotalUnits));
        activeFilterConfigs = JSON.parse(JSON.stringify(sourceActiveFilterConfigs));

        processRawEntries(masterRawEntries, masterCsvHeaders);
    }


    function parseCsvLine(line) {
        const values = [];
        let currentVal = '';
        let inQuotes = false;
        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            if (char === '"') {
                if (inQuotes && i + 1 < line.length && line[i+1] === '"') {
                    currentVal += '"';
                    i++;
                } else {
                    inQuotes = !inQuotes;
                }
            } else if (char === ',' && !inQuotes) {
                values.push(currentVal.trim());
                currentVal = '';
            } else {
                currentVal += char;
            }
        }
        values.push(currentVal.trim());
        return values;
    }

    function escapeCsvField(field) {
        if (field === null || field === undefined) {
            return '';
        }
        let stringField = String(field);
        if (stringField.includes(',') || stringField.includes('"') || stringField.includes('\n') || stringField.includes('\r')) {
            stringField = stringField.replace(/"/g, '""');
            return `"${stringField}"`;
        }
        return stringField;
    }


    function processRawEntries(rawEntries, csvHeaderConfig) { // csvHeaderConfig is now array of objects
        if (!csvHeaderConfig || csvHeaderConfig.length === 0) {
            console.warn("processRawEntries: CSV header configuration is missing.");
            return false;
        }
        
        const requiredHeaders = csvHeaderConfig.filter(h => h.required).map(h => h.name);
        const poNumeroHeader = getHeaderName("PO번호"); 

        if (rawEntries.length === 0) { 
            allYearsGlobal = [];
            allDongsGlobal = [...new Set(Object.keys(totalUnitsPerDongStatic))].sort((a,b) => a.localeCompare(b, 'ko-KR'));
            allWorkTypesGlobal = [];
            
            const dongHeaderName = getHeaderName("건물동");
            const poAmountHeaderName = getHeaderName("PO금액");

            dataBuildingSummaryRaw = allDongsGlobal.map(dName => ({
                dong: dName, 
                totalUnits: totalUnitsPerDongStatic[dName] === null ? "N/A" : totalUnitsPerDongStatic[dName] || 0, 
                completedUnits: 0,
                progressRate: (totalUnitsPerDongStatic[dName] !== null && totalUnitsPerDongStatic[dName] > 0) ? 0 : "N/A", 
                totalPOAmount: 0, 
                avgAmountPerUnit: 0
            }));
            dataWorkTypeSummaryRaw = []; 
            dataAnnualSummaryRaw = [];
            dataDongWorkTypeCountRaw = {}; 
            dataDongWorkTypePORaw = {};
            dataYearDongCountRaw = {}; 
            dataYearWorkTypeCountRaw = {};
            dataDongFinanceAndCountRaw = [];
            return false;
        }


        const yearHeaderName = getHeaderName("회계 연도");
        const dongHeaderName = getHeaderName("건물동");
        const workTypeHeaderName = getHeaderName("작업유형");
        const poAmountHeaderName = getHeaderName("PO금액");
        const totalUnitsHeaderName = getHeaderName("전체 세대수");

        if (csvHeaderConfig.find(h => h.name === totalUnitsHeaderName) && csvHeaderConfig.find(h => h.name === dongHeaderName)) {
            const newUnitsFromCsv = {};
            rawEntries.forEach(entry => {
                const dongName = entry[dongHeaderName] ? entry[dongHeaderName].replace('사택 ','').trim() : null;
                const unitsValue = entry[totalUnitsHeaderName] ? String(entry[totalUnitsHeaderName]).trim() : null;
                
                if (dongName) {
                    if (unitsValue === null || unitsValue.toLowerCase() === "n/a" || unitsValue === "-" || unitsValue.toLowerCase() === "해당없음" || unitsValue === "0") {
                        newUnitsFromCsv[dongName] = null;
                    } else {
                        const totalUnitsVal = parseInt(unitsValue.replace(/,/g, ''), 10);
                        if (!isNaN(totalUnitsVal) && totalUnitsVal > 0) {
                             newUnitsFromCsv[dongName] = totalUnitsVal;
                        } else if (!newUnitsFromCsv.hasOwnProperty(dongName)) { 
                            newUnitsFromCsv[dongName] = null;
                        }
                    }
                }
            });
            for (const dong in newUnitsFromCsv) {
                if (newUnitsFromCsv[dong] !== null || !totalUnitsPerDongStatic.hasOwnProperty(dong) || totalUnitsPerDongStatic[dong] === null) {
                    totalUnitsPerDongStatic[dong] = newUnitsFromCsv[dong];
                }
            }
        }
        rawEntries.forEach(entry => {
             const dongName = entry[dongHeaderName] ? entry[dongHeaderName].replace('사택 ','').trim() : null;
             if(dongName && !totalUnitsPerDongStatic.hasOwnProperty(dongName)) {
                 totalUnitsPerDongStatic[dongName] = null; 
             }
        });

        allYearsGlobal = [...new Set(rawEntries.map(e => e[yearHeaderName]).filter(Boolean))].sort((a,b) => parseInt(String(a).replace('년','')) - parseInt(String(b).replace('년','')));
        allDongsGlobal = [...new Set(Object.keys(totalUnitsPerDongStatic))].sort((a,b) => a.localeCompare(b, 'ko-KR'));
        allWorkTypesGlobal = [...new Set(rawEntries.map(e => e[workTypeHeaderName]).filter(Boolean))].sort();

        dataBuildingSummaryRaw = allDongsGlobal.map(dName => {
            const dongEntries = rawEntries.filter(e => (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dName);
            const completedUnits = dongEntries.length;
            const totalPOAmount = dongEntries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0);
            const totalU = totalUnitsPerDongStatic[dName];
            return {
                dong: dName, 
                totalUnits: totalU === null ? "N/A" : totalU, 
                completedUnits: completedUnits,
                progressRate: (totalU !== null && totalU > 0) ? parseFloat(((completedUnits / totalU) * 100).toFixed(2)) : "N/A",
                totalPOAmount: totalPOAmount, 
                avgAmountPerUnit: completedUnits > 0 ? Math.round(totalPOAmount / completedUnits) : 0
            };
        });

        dataWorkTypeSummaryRaw = allWorkTypesGlobal.map(wtName => {
            const workTypeEntries = rawEntries.filter(e => e[workTypeHeaderName] === wtName);
            return {
                workType: wtName, totalWorkCount: workTypeEntries.length,
                totalPOAmount: workTypeEntries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0)
            };
        });

        dataDongWorkTypeCountRaw = {};
        dataDongWorkTypePORaw = {};
        allDongsGlobal.forEach(dName => {
            dataDongWorkTypeCountRaw[dName] = {};
            dataDongWorkTypePORaw[dName] = {};
            allWorkTypesGlobal.forEach(wtName => {
                const entries = rawEntries.filter(e => (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dName && e[workTypeHeaderName] === wtName);
                dataDongWorkTypeCountRaw[dName][wtName] = entries.length;
                dataDongWorkTypePORaw[dName][wtName] = entries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0);
            });
        });

        dataAnnualSummaryRaw = allYearsGlobal.map(yName => {
            const yearEntries = rawEntries.filter(e => e[yearHeaderName] === yName);
            return {
                year: yName, totalWorkCount: yearEntries.length,
                totalPOAmount: yearEntries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0)
            };
        });

        dataYearDongCountRaw = {};
        allYearsGlobal.forEach(yName => {
            dataYearDongCountRaw[yName] = {};
            allDongsGlobal.forEach(dName => {
                dataYearDongCountRaw[yName][dName] = rawEntries.filter(e => e[yearHeaderName] === yName && (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dName).length;
            });
        });

        dataYearWorkTypeCountRaw = {};
        allYearsGlobal.forEach(yName => {
            dataYearWorkTypeCountRaw[yName] = {};
            allWorkTypesGlobal.forEach(wtName => {
                dataYearWorkTypeCountRaw[yName][wtName] = rawEntries.filter(e => e[yearHeaderName] === yName && e[workTypeHeaderName] === wtName).length;
            });
        });
        dataDongFinanceAndCountRaw = allDongsGlobal.map(dName => {
            const dongEntries = rawEntries.filter(e => (e[dongHeaderName] ? e[dongHeaderName].replace('사택 ','').trim() : '') === dName);
            const totalPOAmount = dongEntries.reduce((sum, e) => sum + (parseFloat(String(e[poAmountHeaderName]).replace(/,/g, '')) || 0), 0);
            const totalWorkCount = dongEntries.length;
            return {
                dong: dName,
                totalPOAmount: totalPOAmount,
                totalWorkCount: totalWorkCount
            };
        });
        return true;
    }


    function processUploadedData(csvData) {
        const uploadStatusEl = document.getElementById('uploadStatus');
        if (csvData.startsWith("\uFEFF")) {
            csvData = csvData.substring(1);
        }

        const lines = csvData.split(/\r\n|\n/).filter(line => line.trim() !== '');
        if (lines.length < 1) { // Only header is not enough
            if(uploadStatusEl) uploadStatusEl.textContent = "오류: CSV 파일에 헤더와 하나 이상의 데이터 행이 필요합니다.";
            return;
        }

        const fileHeaders = parseCsvLine(lines[0]).map(h => h.trim().replace(/\s+/g, ' '));
        const localRawEntries = [];
        const poNumeroHeaderName = getHeaderName("PO번호");

        // Check for required headers in the file
        for (const definedHeader of masterCsvHeaders) {
            if (definedHeader.required && !fileHeaders.includes(definedHeader.name)) {
                if(uploadStatusEl) {
                    uploadStatusEl.textContent = `오류: CSV 파일에 필수 항목 "${definedHeader.name}"이(가) 없습니다.`;
                    uploadStatusEl.style.color = 'red';
                }
                return;
            }
        }


        for (let i = 1; i < lines.length; i++) {
            const values = parseCsvLine(lines[i]);
            if (values.length !== fileHeaders.length) { // Check against file's header length
                console.warn(`행 ${i+1}의 값 개수(${values.length})가 파일 헤더 개수(${fileHeaders.length})와 다릅니다. 건너뜁니다.`);
                continue;
            }
            const entry = {};
            let poNumberPresent = false;
            masterCsvHeaders.forEach(definedHeader => {
                const fileHeaderIndex = fileHeaders.indexOf(definedHeader.name);
                if (fileHeaderIndex !== -1) {
                    let value = values[fileHeaderIndex] ? values[fileHeaderIndex].trim() : '';
                    if (definedHeader.type === 'number') {
                        value = parseFloat(value.replace(/,/g, '')) || 0;
                    }
                    entry[definedHeader.name] = value;
                    if (definedHeader.name === poNumeroHeaderName && value) {
                        poNumberPresent = true;
                    }
                } else if (definedHeader.required) {
                    // This case should have been caught above, but as a safeguard:
                    console.warn(`필수 항목 "${definedHeader.name}"이(가) CSV 데이터 행 ${i+1}에 없습니다. (파일 헤더에는 있었으나, 데이터가 누락된 경우)`);
                    // Decide how to handle this - skip row, or use default? For now, skip.
                    return; // Skips this entry
                } else {
                    entry[definedHeader.name] = ''; // Non-required and not in file, set to empty or null
                }
            });

            if (!poNumberPresent) { // Check based on the current name of PO번호
                console.warn(`"${poNumeroHeaderName}" 누락으로 행 제외:`, entry);
                continue;
            }
            localRawEntries.push(entry);
        }

        if (localRawEntries.length === 0) {
            if(uploadStatusEl) uploadStatusEl.textContent = "오류: 유효한 데이터가 CSV 파일에 없습니다 (필수 항목 및 PO번호 확인).";
            masterRawEntries = [];
            // masterCsvHeaders should retain user's definition
            processRawEntries([], masterCsvHeaders); // Process with empty data but current headers
            initializeDynamicFiltersUI(); // Re-initialize filter UI based on (potentially empty) data
            updateDashboard();
            return;
        }

        masterRawEntries = [...localRawEntries];
        // masterCsvHeaders is already set by user or defaults, no need to change it here from file.

        if (processRawEntries(masterRawEntries, masterCsvHeaders)) { // Re-process with new data and existing header config
            if(uploadStatusEl) uploadStatusEl.textContent = "CSV 파일이 성공적으로 업로드 및 처리되었습니다.";
        } else {
            if(uploadStatusEl) uploadStatusEl.textContent = "오류: 업로드된 CSV에서 데이터를 처리할 수 없습니다. 필수 헤더를 확인하세요.";
        }

        initializeDynamicFiltersUI(); // Re-initialize filter UI based on new data
        updateDashboard();
    }

    // --- Event Handlers (Chart Clicks, Modals) ---
    function handleChartClick(chartInstance, datasetIndex, elementIndex, chartId) {
        if (!chartInstance || !chartInstance.config || !chartInstance.config.data || !chartInstance.config.data.labels || !chartInstance.config.data.datasets) {
            console.error("Chart data is not available for click handling in handleChartClick.", chartInstance);
            return;
        }
        
        const yearHeaderName = getHeaderName("회계 연도");
        const dongHeaderName = getHeaderName("건물동");
        const workTypeHeaderName = getHeaderName("작업유형");

        const clickedLabel = chartInstance.config.data.labels[elementIndex];
        const clickedDatasetLabel = chartInstance.config.data.datasets[datasetIndex].label;

        let detailData = [];
        let modalTitle = `상세 데이터: ${clickedLabel}`;

        if (masterRawEntries.length === 0 || masterCsvHeaders.length === 0) {
            console.warn("Master data not available for modal display.");
            return;
        }

        if (chartId === 'chartBuildingCompleted' || chartId === 'chartBuildingFinanceCombination' || chartId === 'overviewChartDongAnalysis' || chartId === 'chartDongWorkTypeFinanceCount') {
            modalTitle = `동별 상세: ${clickedLabel}`;
            detailData = masterRawEntries.filter(entry => (entry[dongHeaderName] ? entry[dongHeaderName].replace('사택 ','').trim() : '') === clickedLabel);
        } else if (chartId === 'chartWorkTypeCombination' || chartId === 'overviewChartWorkTypeDistribution') {
             modalTitle = `작업 유형별 상세: ${clickedLabel}`;
             detailData = masterRawEntries.filter(entry => entry[workTypeHeaderName] === clickedLabel);
        } else if (chartId === 'chartDongWorkTypeProgress') {
            const currentSelectedDongs = getSelectedOptions(document.getElementById(`filter-select-${dongHeaderName.replace(/\s+/g, '_')}`));
            const currentSelectedWorkTypes = getSelectedOptions(document.getElementById(`filter-select-${workTypeHeaderName.replace(/\s+/g, '_')}`));
            const yearClicked = clickedLabel; // clickedLabel is the year from this chart's x-axis

            if (currentSelectedDongs.length > 0 && currentSelectedWorkTypes.length > 0) {
                let dongText = currentSelectedDongs.length > 1 ? `${currentSelectedDongs.length}개 동` : currentSelectedDongs[0];
                if (currentSelectedDongs.length === allDongsGlobal.length && allDongsGlobal.length > 1) dongText = "전체 동";
                
                let workTypeText = currentSelectedWorkTypes.length > 1 ? `${currentSelectedWorkTypes.length}개 유형` : currentSelectedWorkTypes[0];
                if (currentSelectedWorkTypes.length === allWorkTypesGlobal.length && allWorkTypesGlobal.length > 1) workTypeText = "전체 유형";

                modalTitle = `상세: ${dongText} & ${workTypeText} - ${yearClicked}년 작업 내역`;
                detailData = masterRawEntries.filter(entry =>
                    currentSelectedDongs.includes(entry[dongHeaderName] ? entry[dongHeaderName].replace('사택 ','').trim() : '') &&
                    currentSelectedWorkTypes.includes(entry[workTypeHeaderName]) &&
                    entry[yearHeaderName] === yearClicked
                );
            }
        } else if (chartId === 'chartAnnualCombination' || chartId === 'overviewChartAnnualTrend') {
            modalTitle = `연도별 상세: ${clickedLabel}`;
            detailData = masterRawEntries.filter(entry => entry[yearHeaderName] === clickedLabel);
        } else if (chartId === 'chartDongWorkTypeCount' || chartId === 'chartDongWorkTypePO') {
            const dong = chartInstance.config.data.labels[elementIndex];
            const workType = chartInstance.config.data.datasets[datasetIndex].label;
            modalTitle = `상세: ${dong} - ${workType}`;
            detailData = masterRawEntries.filter(entry =>
                (entry[dongHeaderName] ? entry[dongHeaderName].replace('사택 ','').trim() : '') === dong &&
                entry[workTypeHeaderName] === workType
            );
        } else if (chartId === 'chartYearDongCount') {
            const year = chartInstance.config.data.labels[elementIndex];
            const dong = chartInstance.config.data.datasets[datasetIndex].label;
            modalTitle = `상세: ${year} - ${dong}`;
            detailData = masterRawEntries.filter(entry =>
                entry[yearHeaderName] === year &&
                (entry[dongHeaderName] ? entry[dongHeaderName].replace('사택 ','').trim() : '') === dong
            );
        } else if (chartId === 'chartYearWorkTypeCount') {
            const year = chartInstance.config.data.labels[elementIndex];
            const workType = chartInstance.config.data.datasets[datasetIndex].label;
            modalTitle = `상세: ${year} - ${workType}`;
            detailData = masterRawEntries.filter(entry =>
                entry[yearHeaderName] === year &&
                entry[workTypeHeaderName] === workType
            );
        }


        if (detailData.length > 0) {
            document.getElementById('detailModalTitle').textContent = modalTitle;
            populateTable('detailModalTable', detailData, masterCsvHeaders.map(h => h.name), true);
            document.getElementById('detailModal').classList.add('active');
        } else {
            console.log("No detail data found for:", modalTitle);
        }
    }

    function updateButtonActiveStates() {
        activeFilterConfigs.forEach(config => {
            const columnName = config.headerName;
            const sanitizedColumnName = columnName.replace(/\s+/g, '_');
            
            const ascButton = document.getElementById(`sort-${sanitizedColumnName}Asc`);
            const descButton = document.getElementById(`sort-${sanitizedColumnName}Desc`);
            if (ascButton && descButton) {
                ascButton.classList.remove('active-sort');
                descButton.classList.remove('active-sort');
                if (config.sort === 'asc') {
                    ascButton.classList.add('active-sort');
                } else if (config.sort === 'desc') {
                    descButton.classList.add('active-sort');
                }
            }

            const selectAllButton = document.getElementById(`selectAll-${sanitizedColumnName}`);
            const deselectAllButton = document.getElementById(`deselectAll-${sanitizedColumnName}`);
            const selectElement = document.getElementById(`filter-select-${sanitizedColumnName}`);

            if (selectAllButton && deselectAllButton && selectElement) {
                selectAllButton.classList.remove('active-selection');
                deselectAllButton.classList.remove('active-selection');

                let allSelected = true;
                let noneSelected = true;
                let hasEnabledOptions = false;

                for (const option of selectElement.options) {
                    if (!option.disabled) {
                        hasEnabledOptions = true;
                        if (!option.selected) allSelected = false;
                        if (option.selected) noneSelected = false;
                    }
                }

                if (hasEnabledOptions) {
                    if (allSelected) {
                        selectAllButton.classList.add('active-selection');
                    }
                    if (noneSelected) {
                        deselectAllButton.classList.add('active-selection');
                    }
                }
            }
        });
    }

    // --- Dong Units Management Modal Logic ---
    const dongUnitsModal = document.getElementById('dongUnitsModal');
    const dongUnitsModalCloseButton = document.getElementById('dongUnitsModalCloseButton');
    const manageDongUnitsButton = document.getElementById('manageDongUnits');
    const dongUnitsTableBody = document.getElementById('dongUnitsTableBody');
    const addDongUnitButton = document.getElementById('addDongUnitButton');
    const newDongNameInput = document.getElementById('newDongName');
    const newDongUnitsInput = document.getElementById('newDongUnits');
    const saveDongUnitsButton = document.getElementById('saveDongUnitsButton');
    const cancelDongUnitsButton = document.getElementById('cancelDongUnitsButton');
    const dongUnitsError = document.getElementById('dongUnitsError');

    let tempDongUnits = {}; // Stores { dongName: number | null }

    function renderDongUnitTable() {
        if (!dongUnitsTableBody) return;
        dongUnitsTableBody.innerHTML = '';
        const sortedDongs = Object.keys(tempDongUnits).sort((a, b) => a.localeCompare(b, 'ko-KR'));

        sortedDongs.forEach(dong => {
            const row = dongUnitsTableBody.insertRow();
            row.insertCell().textContent = dong;

            const unitsCell = row.insertCell();
            const unitsInput = document.createElement('input');
            unitsInput.type = "text"; // Allow "N/A", "-", etc.
            unitsInput.value = tempDongUnits[dong] === null ? '' : String(tempDongUnits[dong]); // Display empty for null
            unitsInput.placeholder = "세대수 또는 N/A";
            unitsInput.classList.add('filter-select', 'w-full', 'text-center');
            unitsInput.addEventListener('change', (e) => {
                const rawValue = e.target.value.trim();
                if (rawValue === "0" || rawValue.toLowerCase() === "n/a" || rawValue === "-" || rawValue.toLowerCase() === "해당없음") {
                    tempDongUnits[dong] = null;
                    e.target.value = ''; // Clear input for visual consistency if preferred for null
                } else {
                    const parsedValue = parseInt(rawValue, 10);
                    if (!isNaN(parsedValue) && parsedValue > 0) {
                        tempDongUnits[dong] = parsedValue;
                        e.target.value = parsedValue; // Ensure it's the number
                    } else if (rawValue === '') { // User cleared the input
                         tempDongUnits[dong] = null;
                    }
                    else { // Invalid number or other text not explicitly handled as N/A
                        tempDongUnits[dong] = null; // Treat as N/A
                        e.target.value = ''; // Clear invalid input
                        if(dongUnitsError) dongUnitsError.textContent = `"${dong}"동: 유효한 숫자 또는 'N/A' 계열 값을 입력하세요.`;
                        setTimeout(() => { if(dongUnitsError) dongUnitsError.textContent = ''; }, 3000);
                    }
                }
            });
            unitsCell.appendChild(unitsInput);

            const deleteCell = row.insertCell();
            const deleteButton = document.createElement('button');
            deleteButton.textContent = '삭제';
            deleteButton.classList.add('action-button', 'bg-red-500', 'hover:bg-red-600', 'text-white');
            deleteButton.onclick = () => {
                delete tempDongUnits[dong];
                renderDongUnitTable();
            };
            deleteCell.appendChild(deleteButton);
        });
    }

    if (manageDongUnitsButton) {
        manageDongUnitsButton.addEventListener('click', () => {
            tempDongUnits = JSON.parse(JSON.stringify(totalUnitsPerDongStatic));
            renderDongUnitTable();
            if (dongUnitsError) dongUnitsError.textContent = '';
            if (dongUnitsModal) dongUnitsModal.classList.add('active');
        });
    }

    if (dongUnitsModalCloseButton && dongUnitsModal) {
        dongUnitsModalCloseButton.onclick = () => dongUnitsModal.classList.remove('active');
    }
    if (cancelDongUnitsButton && dongUnitsModal) {
        cancelDongUnitsButton.onclick = () => dongUnitsModal.classList.remove('active');
    }

    if (addDongUnitButton) {
        addDongUnitButton.addEventListener('click', () => {
            const newName = newDongNameInput.value.trim();
            const rawUnitsValue = newDongUnitsInput.value.trim();
            if (dongUnitsError) dongUnitsError.textContent = '';

            if (!newName) {
                if (dongUnitsError) dongUnitsError.textContent = '새 동 이름을 입력해주세요.';
                return;
            }
            if (tempDongUnits.hasOwnProperty(newName)) {
                if (dongUnitsError) dongUnitsError.textContent = `"${newName}" 동은 이미 존재합니다.`;
                return;
            }

            if (rawUnitsValue === "0" || rawUnitsValue.toLowerCase() === "n/a" || rawUnitsValue === "-" || rawUnitsValue.toLowerCase() === "해당없음") {
                tempDongUnits[newName] = null;
            } else {
                const newUnits = parseInt(rawUnitsValue, 10);
                if (isNaN(newUnits) || newUnits < 0) { // Allow 0 to be stored as null, but negative is invalid
                     if (dongUnitsError) dongUnitsError.textContent = '세대수는 0 이상의 숫자 또는 "N/A" 계열 값으로 입력해주세요.';
                    return;
                }
                tempDongUnits[newName] = (newUnits === 0) ? null : newUnits;
            }
            
            renderDongUnitTable();
            if(newDongNameInput) newDongNameInput.value = '';
            if(newDongUnitsInput) newDongUnitsInput.value = '';
        });
    }

    if (saveDongUnitsButton && dongUnitsModal) {
        saveDongUnitsButton.addEventListener('click', () => {
            totalUnitsPerDongStatic = JSON.parse(JSON.stringify(tempDongUnits));
            allDongsGlobal = [...new Set(Object.keys(totalUnitsPerDongStatic))].sort((a,b) => a.localeCompare(b, 'ko-KR'));

            dongUnitsModal.classList.remove('active');
            processRawEntries(masterRawEntries, masterCsvHeaders); // Re-process with new static units
            updateDashboard(); // Update all charts and tables
        });
    }

    // --- CSV 항목 관리 모달 ---
    const csvMappingModal = document.getElementById('csvMappingModal');
    const csvMappingModalCloseButton = document.getElementById('csvMappingModalCloseButton');
    const manageCsvHeadersButton = document.getElementById('manageCsvHeaders');
    const csvHeaderListEl = document.getElementById('csvHeaderList');
    const newCsvHeaderNameInput = document.getElementById('newCsvHeaderName');
    const newCsvHeaderTypeSelect = document.getElementById('newCsvHeaderType');
    const newCsvHeaderRequiredCheckbox = document.getElementById('newCsvHeaderRequired');
    const addCsvHeaderButton = document.getElementById('addCsvHeaderButton');
    const saveCsvHeadersButton = document.getElementById('saveCsvHeadersButton');
    const cancelCsvMappingButton = document.getElementById('cancelCsvMappingButton');
    const csvMappingErrorEl = document.getElementById('csvMappingError');
    let tempCsvHeaders = [];
    let draggedCsvHeaderItem = null;

    function renderCsvHeaderList() {
        if (!csvHeaderListEl) return;
        csvHeaderListEl.innerHTML = '';
        tempCsvHeaders.forEach((header, index) => {
            const listItem = document.createElement('li');
            listItem.className = 'flex items-center space-x-2 p-2 bg-slate-50 rounded';
            listItem.draggable = true;
            listItem.dataset.index = index; // Current index in tempCsvHeaders

            const dragHandle = document.createElement('span');
            dragHandle.className = 'drag-handle cursor-move text-slate-400 hover:text-slate-600';
            dragHandle.innerHTML = '&#x2630;'; 
            listItem.appendChild(dragHandle);

            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = header.name;
            nameInput.className = 'csv-header-input flex-grow p-1 border rounded';
            nameInput.onchange = (e) => { 
                const newName = e.target.value.trim();
                // Check for duplicate names before updating
                if (tempCsvHeaders.some((h, i) => i !== index && h.name === newName)) {
                    if(csvMappingErrorEl) csvMappingErrorEl.textContent = `항목 이름 "${newName}"이(가) 이미 존재합니다.`;
                    e.target.value = tempCsvHeaders[index].name; // Revert to old name
                } else {
                    tempCsvHeaders[index].name = newName; 
                    if(csvMappingErrorEl) csvMappingErrorEl.textContent = '';
                }
            };
            listItem.appendChild(nameInput);

            const typeSelect = document.createElement('select');
            typeSelect.className = 'csv-header-select p-1 border rounded w-24';
            ['text', 'number', 'date'].forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type.charAt(0).toUpperCase() + type.slice(1);
                if (header.type === type) option.selected = true;
                typeSelect.appendChild(option);
            });
            typeSelect.onchange = (e) => { tempCsvHeaders[index].type = e.target.value; };
            listItem.appendChild(typeSelect);
            
            const requiredLabel = document.createElement('label');
            requiredLabel.className = 'flex items-center space-x-1 text-sm';
            const requiredCheckbox = document.createElement('input');
            requiredCheckbox.type = 'checkbox';
            requiredCheckbox.checked = header.required;
            requiredCheckbox.className = 'form-checkbox h-4 w-4 text-sky-600';
            requiredCheckbox.onchange = (e) => { tempCsvHeaders[index].required = e.target.checked; };
            requiredLabel.appendChild(requiredCheckbox);
            requiredLabel.appendChild(document.createTextNode('필수'));
            listItem.appendChild(requiredLabel);

            const deleteButton = document.createElement('button');
            deleteButton.textContent = '삭제';
            deleteButton.className = 'header-action-button bg-red-500 hover:bg-red-600 text-white rounded px-2 py-1 text-xs';
            deleteButton.onclick = () => {
                tempCsvHeaders.splice(index, 1);
                renderCsvHeaderList(); // Re-render to update indices
            };
            listItem.appendChild(deleteButton);

            listItem.addEventListener('dragstart', (e) => {
                draggedCsvHeaderItem = listItem;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', index); // Store index of dragged item
                setTimeout(() => listItem.classList.add('dragging'), 0);
            });
            listItem.addEventListener('dragend', () => {
                listItem.classList.remove('dragging');
                draggedCsvHeaderItem = null;
                updateTempCsvHeadersOrderFromDOM(); // Update array order after drag
            });
             listItem.addEventListener('dragover', (e) => {
                e.preventDefault(); // Necessary to allow drop
                e.dataTransfer.dropEffect = 'move';
            });
            listItem.addEventListener('drop', (e) => {
                e.preventDefault();
                if (draggedCsvHeaderItem && draggedCsvHeaderItem !== listItem) {
                    const fromIndex = parseInt(draggedCsvHeaderItem.dataset.index);
                    const toIndex = parseInt(listItem.dataset.index);
                    
                    const itemToMove = tempCsvHeaders.splice(fromIndex, 1)[0];
                    tempCsvHeaders.splice(toIndex, 0, itemToMove);
                    renderCsvHeaderList(); // Re-render the list to reflect new order
                }
            });
            csvHeaderListEl.appendChild(listItem);
        });
    }
    
    function updateTempCsvHeadersOrderFromDOM() {
        const newOrderedHeaders = [];
        const listItems = csvHeaderListEl.querySelectorAll('li');
        listItems.forEach(li => {
            const nameInput = li.querySelector('.csv-header-input');
            const typeSelect = li.querySelector('.csv-header-select');
            const requiredCheckbox = li.querySelector('.form-checkbox');
            const originalHeader = tempCsvHeaders.find(h => h.name === nameInput.value); // Find by potentially old name if not updated yet
                                                                                        // This is tricky if names are changed during drag.
                                                                                        // A more robust way is to use a unique ID per header object.
                                                                                        // For now, we assume names are unique enough or we re-fetch from an originalIndex.
            const originalIndex = parseInt(li.dataset.index); // This index might be stale if items were deleted.
                                                              // It's better to find the object in tempCsvHeaders by a unique property.
                                                              // Let's assume the input field value reflects the current state.
            const currentName = nameInput.value.trim();
            const headerObj = tempCsvHeaders.find(h => h.name === currentName) || // Try to find by current name
                              tempCsvHeaders[originalIndex]; // Fallback to original index if name changed
            
            if(headerObj){
                 headerObj.name = currentName;
                 headerObj.type = typeSelect.value;
                 headerObj.required = requiredCheckbox.checked;
                 newOrderedHeaders.push(headerObj);
            }
        });
        // This reordering based on DOM can be complex if items are deleted during drag.
        // A simpler approach for reordering on dragend:
        const domOrderIndices = Array.from(listItems).map(li => parseInt(li.dataset.index));
        const reorderedTemp = domOrderIndices.map(idx => tempCsvHeaders[idx]);
        // However, if items were deleted, indices are no longer valid.
        // The current drag/drop on list items reorders `tempCsvHeaders` directly.
        // So, `updateTempCsvHeadersOrderFromDOM` might not be needed if drag/drop modifies the array.
        // Let's simplify: the drag/drop in `renderCsvHeaderList` should directly manipulate `tempCsvHeaders` order.
    }


    if (manageCsvHeadersButton) {
        manageCsvHeadersButton.addEventListener('click', () => {
            tempCsvHeaders = JSON.parse(JSON.stringify(masterCsvHeaders)); // Deep copy
            renderCsvHeaderList();
            if (csvMappingErrorEl) csvMappingErrorEl.textContent = '';
            if (csvMappingModal) csvMappingModal.classList.add('active');
        });
    }

    if (csvMappingModalCloseButton && csvMappingModal) {
        csvMappingModalCloseButton.onclick = () => csvMappingModal.classList.remove('active');
    }
    if (cancelCsvMappingButton && csvMappingModal) {
        cancelCsvMappingButton.onclick = () => csvMappingModal.classList.remove('active');
    }

    if (addCsvHeaderButton) {
        addCsvHeaderButton.addEventListener('click', () => {
            const newName = newCsvHeaderNameInput.value.trim();
            const newType = newCsvHeaderTypeSelect.value;
            const newRequired = newCsvHeaderRequiredCheckbox.checked;
            if (csvMappingErrorEl) csvMappingErrorEl.textContent = '';

            if (!newName) {
                if (csvMappingErrorEl) csvMappingErrorEl.textContent = '새 항목 이름을 입력해주세요.';
                return;
            }
            if (tempCsvHeaders.some(h => h.name === newName)) {
                if (csvMappingErrorEl) csvMappingErrorEl.textContent = `항목 "${newName}"이(가) 이미 존재합니다.`;
                return;
            }
            tempCsvHeaders.push({ name: newName, originalName: newName, required: newRequired, type: newType }); 
            renderCsvHeaderList();
            newCsvHeaderNameInput.value = '';
            newCsvHeaderTypeSelect.value = 'text';
            newCsvHeaderRequiredCheckbox.checked = false;
        });
    }

    if (saveCsvHeadersButton && csvMappingModal) {
        saveCsvHeadersButton.addEventListener('click', () => {
            // Update names from input fields one last time before saving
            const listItems = csvHeaderListEl.querySelectorAll('li');
            const updatedHeadersFromModal = [];
            let hasError = false;
            const namesEncountered = new Set();

            listItems.forEach((li, newIndex) => {
                const originalHeaderIndex = parseInt(li.dataset.index); // This is the index in the *current* tempCsvHeaders array before reordering
                const nameInput = li.querySelector('.csv-header-input');
                const typeSelect = li.querySelector('.csv-header-select');
                const requiredCheckbox = li.querySelector('.form-checkbox');

                const name = nameInput.value.trim();
                const type = typeSelect.value;
                const required = requiredCheckbox.checked;
                
                if (!name) {
                    if(csvMappingErrorEl) csvMappingErrorEl.textContent = `항목 이름은 비워둘 수 없습니다 (항목 ${newIndex + 1}).`;
                    hasError = true;
                    return; // from forEach callback
                }
                if (namesEncountered.has(name)) {
                    if(csvMappingErrorEl) csvMappingErrorEl.textContent = `항목 이름 "${name}"이(가) 중복됩니다.`;
                    hasError = true;
                    return; // from forEach callback
                }
                namesEncountered.add(name);
                
                // Find the corresponding object in tempCsvHeaders to preserve originalName
                // This assumes that the order in tempCsvHeaders might have changed due to drag/drop
                // and we need to find the item by its *current* name before potential edit or its original index
                let originalNameValue = tempCsvHeaders[originalHeaderIndex]?.originalName || name; // Fallback if originalName was not set

                updatedHeadersFromModal.push({ 
                    name: name, 
                    originalName: originalNameValue, 
                    required: required, 
                    type: type
                });
            });

            if (hasError) return;

            masterCsvHeaders = updatedHeadersFromModal; // This now reflects the order and content from the modal
            csvMappingModal.classList.remove('active');
            
            // Update activeFilterConfigs if any headerName changed
            activeFilterConfigs.forEach(fc => {
                const foundHeader = masterCsvHeaders.find(h => h.originalName === fc.headerName || h.name === fc.headerName);
                if (foundHeader) {
                    fc.headerName = foundHeader.name; // Update to current name
                } else {
                    // Header used in filter was deleted or renamed to something not findable by originalName
                    // Mark for removal or notify user - for now, we'll filter it out later
                }
            });
            activeFilterConfigs = activeFilterConfigs.filter(fc => masterCsvHeaders.some(h => h.name === fc.headerName));


            initializeDynamicFiltersUI(); 
            updateDashboard(); 
            if(document.getElementById('uploadStatus')) document.getElementById('uploadStatus').textContent = 'CSV 항목 구성이 저장되었습니다. 다음 CSV 업로드 시 적용됩니다.';

        });
    }

    // --- 필터 항목 구성 모달 ---
    const filterConfigModal = document.getElementById('filterConfigModal');
    const filterConfigModalCloseButton = document.getElementById('filterConfigModalCloseButton');
    const manageFilterConfigsButton = document.getElementById('manageFilterConfigs');
    const availableCsvColumnsListEl = document.getElementById('availableCsvColumnsList');
    const activeFiltersListEl = document.getElementById('activeFiltersList');
    const saveFilterConfigsButton = document.getElementById('saveFilterConfigsButton');
    const cancelFilterConfigsButton = document.getElementById('cancelFilterConfigsButton');
    const filterConfigErrorEl = document.getElementById('filterConfigError');
    let tempActiveFilterConfigs = []; // Array of { headerName: "...", sort: "asc" }
    let draggedFilterItem = null;

    function renderFilterConfigModal() {
        if (!availableCsvColumnsListEl || !activeFiltersListEl) return;
        availableCsvColumnsListEl.innerHTML = '';
        activeFiltersListEl.innerHTML = '';
        if(filterConfigErrorEl) filterConfigErrorEl.textContent = '';

        const activeFilterNames = new Set(tempActiveFilterConfigs.map(fc => fc.headerName));

        masterCsvHeaders.forEach(header => {
            if (!activeFilterNames.has(header.name)) {
                const listItem = document.createElement('li');
                listItem.className = 'flex justify-between items-center p-1';
                const nameSpan = document.createElement('span');
                nameSpan.textContent = header.name;
                nameSpan.className = 'filter-name-span';
                listItem.appendChild(nameSpan);

                const addButton = document.createElement('button');
                addButton.textContent = '필터 추가 +';
                addButton.className = 'filter-action-button bg-green-500 hover:bg-green-600 text-white rounded px-2 py-1 text-xs';
                addButton.onclick = () => {
                    tempActiveFilterConfigs.push({ headerName: header.name, sort: 'asc' }); // Default sort
                    renderFilterConfigModal();
                };
                listItem.appendChild(addButton);
                availableCsvColumnsListEl.appendChild(listItem);
            }
        });

        tempActiveFilterConfigs.forEach((filterConfig, index) => {
            const listItem = document.createElement('li');
            listItem.className = 'flex justify-between items-center p-1 bg-slate-100 rounded';
            listItem.draggable = true;
            listItem.dataset.index = index;

            const dragHandle = document.createElement('span');
            dragHandle.className = 'drag-handle cursor-move text-slate-400 hover:text-slate-600 mr-2';
            dragHandle.innerHTML = '&#x2630;';
            listItem.appendChild(dragHandle);
            
            const nameSpan = document.createElement('span');
            nameSpan.textContent = filterConfig.headerName;
            nameSpan.className = 'filter-name-span flex-grow';
            listItem.appendChild(nameSpan);

            const removeButton = document.createElement('button');
            removeButton.textContent = '- 제거';
            removeButton.className = 'filter-action-button bg-red-500 hover:bg-red-600 text-white rounded px-2 py-1 text-xs';
            removeButton.onclick = () => {
                tempActiveFilterConfigs.splice(index, 1);
                renderFilterConfigModal();
            };
            listItem.appendChild(removeButton);

            listItem.addEventListener('dragstart', (e) => {
                draggedFilterItem = listItem;
                e.dataTransfer.effectAllowed = 'move';
                e.dataTransfer.setData('text/plain', index.toString());
                setTimeout(() => listItem.classList.add('dragging'), 0);
            });
            listItem.addEventListener('dragend', () => {
                listItem.classList.remove('dragging');
                draggedFilterItem = null;
                // Update actual tempActiveFilterConfigs order based on new DOM order
                const newOrder = [];
                activeFiltersListEl.querySelectorAll('li').forEach(li => {
                    const oldIndex = parseInt(li.dataset.index); // This might be tricky if items were added/removed
                                                                // A more robust way is to find based on headerName
                    const headerNameToFind = li.querySelector('.filter-name-span').textContent;
                    const foundConfig = tempActiveFilterConfigs.find(fc => fc.headerName === headerNameToFind);
                    if(foundConfig) newOrder.push(foundConfig);
                });
                tempActiveFilterConfigs = newOrder;
                renderFilterConfigModal(); // Re-render to fix indices
            });
            listItem.addEventListener('dragover', (e) => {
                e.preventDefault();
                const draggingOverItem = e.target.closest('li');
                if (draggingOverItem && draggedFilterItem !== draggingOverItem) {
                    const rect = draggingOverItem.getBoundingClientRect();
                    const nextIsSibling = (e.clientY - rect.top - rect.height / 2) > 0;
                    if (nextIsSibling) {
                        activeFiltersListEl.insertBefore(draggedFilterItem, draggingOverItem.nextSibling);
                    } else {
                        activeFiltersListEl.insertBefore(draggedFilterItem, draggingOverItem);
                    }
                }
            });

            activeFiltersListEl.appendChild(listItem);
        });
    }
    
    if(manageFilterConfigsButton) {
        manageFilterConfigsButton.addEventListener('click', () => {
            tempActiveFilterConfigs = JSON.parse(JSON.stringify(activeFilterConfigs));
            renderFilterConfigModal();
            if(filterConfigModal) filterConfigModal.classList.add('active');
        });
    }
    if(filterConfigModalCloseButton && filterConfigModal) {
        filterConfigModalCloseButton.onclick = () => filterConfigModal.classList.remove('active');
    }
    if(cancelFilterConfigsButton && filterConfigModal) {
        cancelFilterConfigsButton.onclick = () => filterConfigModal.classList.remove('active');
    }
    if(saveFilterConfigsButton && filterConfigModal) {
        saveFilterConfigsButton.addEventListener('click', () => {
            activeFilterConfigs = JSON.parse(JSON.stringify(tempActiveFilterConfigs));
            filterConfigModal.classList.remove('active');
            initializeDynamicFiltersUI();
            updateDashboard();
            if(document.getElementById('uploadStatus')) document.getElementById('uploadStatus').textContent = '필터 구성이 저장되었습니다.';
        });
    }


    // --- Initialization Logic ---
    function whenChartJsReady(callback) {
        console.log("whenChartJsReady: Chart.js 및 ChartDataLabels 로드 상태 확인 중...");
        if (typeof Chart !== 'undefined' && typeof Chart.version !== 'undefined') {
            console.log("whenChartJsReady: Chart.js 라이브러리 준비 완료. 버전:", Chart.version);
            if (typeof ChartDataLabels !== 'undefined') {
                console.log("whenChartJsReady: ChartDataLabels 플러그인 스크립트 로드됨.");
                try {
                    if (!Chart.registry.plugins.get('datalabels')) {
                        Chart.register(ChartDataLabels);
                        console.log("whenChartJsReady: ChartDataLabels 플러그인 등록 성공.");
                    } else {
                        console.log("whenChartJsReady: ChartDataLabels 플러그인이 이미 등록되어 있음.");
                    }
                } catch (e) {
                    console.warn("whenChartJsReady: ChartDataLabels 등록 중 오류 (이미 등록되었거나 호환되지 않을 수 있음):", e.message);
                }
            } else {
                console.warn("whenChartJsReady: ChartDataLabels 플러그인 스크립트 감지 안됨. 데이터 레이블이 작동하지 않을 수 있습니다.");
            }

            console.log("whenChartJsReady: Chart.js 준비 완료. DOM도 준비되었을 것으로 예상 (window.onload 통해). 콜백 실행 (지연).");
            setTimeout(callback, 0);

        } else {
            console.log("whenChartJsReady: Chart.js 준비 안됨, 100ms 후 재시도...");
            setTimeout(() => whenChartJsReady(callback), 100);
        }
    }
    
    function initializeDynamicFiltersUI() {
        const filterContentEl = document.getElementById('filterContent');
        if (!filterContentEl) {
            console.error("Filter content element for dynamic UI not found.");
            return;
        }
        filterContentEl.innerHTML = ''; // Clear previous dynamic filters

        activeFilterConfigs.forEach(config => {
            const columnName = config.headerName;
            const sanitizedColumnName = columnName.replace(/\s+/g, '_'); // For valid ID
            
            // Check if this column still exists in masterCsvHeaders
            if (!masterCsvHeaders.some(h => h.name === columnName)) {
                console.warn(`Filter configuration for "${columnName}" skipped as it's no longer in masterCsvHeaders.`);
                return; // Skip creating this filter if its column doesn't exist
            }

            const filterDiv = document.createElement('div');
            
            const headerDiv = document.createElement('div');
            headerDiv.className = 'flex justify-between items-center mb-1';

            const label = document.createElement('label');
            label.htmlFor = `filter-select-${sanitizedColumnName}`;
            label.className = 'block text-sm font-medium';
            label.textContent = `${columnName} 선택:`;
            headerDiv.appendChild(label);

            const controlsDiv = document.createElement('div');
            const selectAllBtn = document.createElement('button');
            selectAllBtn.id = `selectAll-${sanitizedColumnName}`;
            selectAllBtn.className = 'action-button selection-action-button';
            selectAllBtn.textContent = '전체';
            selectAllBtn.onclick = () => {
                const selectEl = document.getElementById(`filter-select-${sanitizedColumnName}`);
                if(selectEl) Array.from(selectEl.options).forEach(option => { if (!option.disabled) option.selected = true; });
                updateDashboard();
            };
            controlsDiv.appendChild(selectAllBtn);

            const deselectAllBtn = document.createElement('button');
            deselectAllBtn.id = `deselectAll-${sanitizedColumnName}`;
            deselectAllBtn.className = 'action-button selection-action-button';
            deselectAllBtn.textContent = '해제';
            deselectAllBtn.onclick = () => {
                const selectEl = document.getElementById(`filter-select-${sanitizedColumnName}`);
                if(selectEl) Array.from(selectEl.options).forEach(opt => opt.selected = false);
                updateDashboard();
            };
            controlsDiv.appendChild(deselectAllBtn);
            
            const sortAscBtn = document.createElement('button');
            sortAscBtn.id = `sort-${sanitizedColumnName}Asc`;
            sortAscBtn.className = 'action-button sort-order-button' + (config.sort === 'asc' ? ' active-sort' : '');
            sortAscBtn.innerHTML = '▲';
            sortAscBtn.onclick = () => { 
                config.sort = 'asc'; 
                populateDynamicFilterOptions(); // Re-populate ALL to reflect sort
                updateDashboard(); 
            };
            controlsDiv.appendChild(sortAscBtn);

            const sortDescBtn = document.createElement('button');
            sortDescBtn.id = `sort-${sanitizedColumnName}Desc`;
            sortDescBtn.className = 'action-button sort-order-button' + (config.sort === 'desc' ? ' active-sort' : '');
            sortDescBtn.innerHTML = '▼';
             sortDescBtn.onclick = () => { 
                config.sort = 'desc'; 
                populateDynamicFilterOptions(); // Re-populate ALL to reflect sort
                updateDashboard(); 
            };
            controlsDiv.appendChild(sortDescBtn);
            headerDiv.appendChild(controlsDiv);
            filterDiv.appendChild(headerDiv);

            const selectEl = document.createElement('select');
            selectEl.id = `filter-select-${sanitizedColumnName}`;
            selectEl.className = 'filter-select w-full';
            selectEl.multiple = true;
            selectEl.size = 3;
            selectEl.onchange = updateDashboard;
            
            filterDiv.appendChild(selectEl);
            filterContentEl.appendChild(filterDiv);
        });
        populateDynamicFilterOptions(); // Populate options for all newly created filters
        updateButtonActiveStates();
    }

    function populateDynamicFilterOptions() {
        const yearHeaderName = getHeaderName("회계 연도");
        const workTypeHeaderName = getHeaderName("작업유형");
        const dongHeaderName = getHeaderName("건물동");

        activeFilterConfigs.forEach(config => {
            const currentColumnName = config.headerName;
            const selectEl = document.getElementById(`filter-select-${currentColumnName.replace(/\s+/g, '_')}`);
            if (!selectEl) return;

            const previouslySelectedValues = config.selectedValues || [];

            // Determine relevant options for *this* filter based on selections in *other* filters
            let entriesForThisFilterOptions = [...masterRawEntries];
            activeFilterConfigs.forEach(otherConfig => {
                if (otherConfig.headerName !== currentColumnName) {
                    const otherSelectEl = document.getElementById(`filter-select-${otherConfig.headerName.replace(/\s+/g, '_')}`);
                    if (otherSelectEl) {
                        const selectedInOtherFilter = getSelectedOptions(otherSelectEl);
                        if (selectedInOtherFilter.length > 0) {
                            entriesForThisFilterOptions = entriesForThisFilterOptions.filter(e => 
                                selectedInOtherFilter.includes(e[otherConfig.headerName] ? (otherConfig.headerName === dongHeaderName ? e[otherConfig.headerName].replace('사택 ','').trim() : e[otherConfig.headerName]) : '')
                            );
                        }
                    }
                }
            });
            
            let availableOptionsForThisFilter = [...new Set(entriesForThisFilterOptions.map(e => e[currentColumnName] ? (currentColumnName === dongHeaderName ? e[currentColumnName].replace('사택 ','').trim() : e[currentColumnName]) : '').filter(Boolean))];
            let allPossibleOptionsForThisFilter = [...new Set(masterRawEntries.map(e => e[currentColumnName] ? (currentColumnName === dongHeaderName ? e[currentColumnName].replace('사택 ','').trim() : e[currentColumnName]) : '').filter(Boolean))];


            if (config.sort === 'asc') {
                allPossibleOptionsForThisFilter.sort((a, b) => String(a).localeCompare(String(b), 'ko-KR', { numeric: true }));
                availableOptionsForThisFilter.sort((a, b) => String(a).localeCompare(String(b), 'ko-KR', { numeric: true }));
            } else if (config.sort === 'desc') {
                allPossibleOptionsForThisFilter.sort((a, b) => String(b).localeCompare(String(a), 'ko-KR', { numeric: true }));
                availableOptionsForThisFilter.sort((a, b) => String(b).localeCompare(String(a), 'ko-KR', { numeric: true }));
            }
            
            repopulateSelectWithOptions(selectEl, allPossibleOptionsForThisFilter, availableOptionsForThisFilter, previouslySelectedValues);
        });
    }


    function initializeDashboardApp() {
        try {
            console.log("함수 호출: initializeDashboardApp() 시작됨.");

            // 단계 1: 설정 로드 또는 초기 기본값 사용
            try {
                console.log("initializeDashboardApp: 단계 1 - 설정 및 초기 데이터 로딩 - 시작");
                console.log("initializeDashboardApp: 초기 window.DASHBOARD_SAVED_SETTINGS:", JSON.parse(JSON.stringify(window.DASHBOARD_SAVED_SETTINGS || null)));

                if (window.DASHBOARD_SAVED_SETTINGS) {
                    initialMasterRawEntries = (window.DASHBOARD_SAVED_SETTINGS.masterRawEntries && window.DASHBOARD_SAVED_SETTINGS.masterRawEntries.length > 0) ? JSON.parse(JSON.stringify(window.DASHBOARD_SAVED_SETTINGS.masterRawEntries)) : JSON.parse(JSON.stringify(initialMasterRawEntries));
                    initialMasterCsvHeaders = (window.DASHBOARD_SAVED_SETTINGS.masterCsvHeaders && window.DASHBOARD_SAVED_SETTINGS.masterCsvHeaders.length > 0) 
                        ? JSON.parse(JSON.stringify(window.DASHBOARD_SAVED_SETTINGS.masterCsvHeaders)) 
                        : JSON.parse(JSON.stringify(initialMasterCsvHeaders)); 
                    
                    initialTotalUnitsPerDongStatic = window.DASHBOARD_SAVED_SETTINGS.totalUnitsPerDongStatic ? JSON.parse(JSON.stringify(window.DASHBOARD_SAVED_SETTINGS.totalUnitsPerDongStatic)) : JSON.parse(JSON.stringify(initialTotalUnitsPerDongStatic));
                    initialActiveFilterConfigs = (window.DASHBOARD_SAVED_SETTINGS.activeFilterConfigs && window.DASHBOARD_SAVED_SETTINGS.activeFilterConfigs.length > 0)
                        ? JSON.parse(JSON.stringify(window.DASHBOARD_SAVED_SETTINGS.activeFilterConfigs))
                        : JSON.parse(JSON.stringify(initialActiveFilterConfigs));


                    masterRawEntries = JSON.parse(JSON.stringify(initialMasterRawEntries));
                    masterCsvHeaders = JSON.parse(JSON.stringify(initialMasterCsvHeaders));
                    totalUnitsPerDongStatic = JSON.parse(JSON.stringify(initialTotalUnitsPerDongStatic));
                    activeFilterConfigs = JSON.parse(JSON.stringify(initialActiveFilterConfigs));


                    filterSortOrders = window.DASHBOARD_SAVED_SETTINGS.filterSortOrders || { dong: 'asc', year: 'desc', worktype: 'asc' }; // Kept for backward compatibility if needed, but should be derived from activeFilterConfigs
                    console.log("initializeDashboardApp: window.DASHBOARD_SAVED_SETTINGS의 설정이 새로운 초기 상태로 적용됨.");
                } else {
                    console.log("initializeDashboardApp: window.DASHBOARD_SAVED_SETTINGS에서 설정을 찾을 수 없음, 기본 초기 데이터 사용.");
                    masterRawEntries = JSON.parse(JSON.stringify(initialMasterRawEntries));
                    masterCsvHeaders = JSON.parse(JSON.stringify(initialMasterCsvHeaders)); 
                    totalUnitsPerDongStatic = JSON.parse(JSON.stringify(initialTotalUnitsPerDongStatic));
                    activeFilterConfigs = JSON.parse(JSON.stringify(initialActiveFilterConfigs));
                }
                console.log("initializeDashboardApp: 단계 1 - 설정 및 초기 데이터 로딩 - 종료.");
            } catch (e) {
                console.error("initializeDashboardApp: 설정/초기 데이터 로딩 중 오류 (단계 1):", e);
                 masterRawEntries = JSON.parse(JSON.stringify(initialMasterRawEntries));
                 masterCsvHeaders = JSON.parse(JSON.stringify(initialMasterCsvHeaders));
                 totalUnitsPerDongStatic = JSON.parse(JSON.stringify(initialTotalUnitsPerDongStatic));
                 activeFilterConfigs = JSON.parse(JSON.stringify(initialActiveFilterConfigs));
            }

            // 단계 2: 데이터 처리 및 필터 UI 초기화
            try {
                console.log("initializeDashboardApp: 단계 2 - 데이터 처리 및 필터 UI 초기화 - 시작");
                processRawEntries(masterRawEntries, masterCsvHeaders);
                console.log("initializeDashboardApp: 데이터 처리됨. 전역 변수 채워짐:", {allDongsGlobal, allYearsGlobal, allWorkTypesGlobal});
                initializeDynamicFiltersUI(); // Initialize dynamic filter UI
                console.log("initializeDashboardApp: 동적 필터 UI 초기화됨.");
                console.log("initializeDashboardApp: 단계 2 - 데이터 처리 및 필터 UI 초기화 - 종료");
            } catch (e) {
                console.error("initializeDashboardApp: 데이터 처리 또는 필터 UI 초기화 중 오류 (단계 2):", e);
            }

            // 단계 3: 로드된 필터 선택 사항 적용 (존재하는 경우)
            if (window.DASHBOARD_SAVED_SETTINGS && window.DASHBOARD_SAVED_SETTINGS.activeFilterConfigs) {
                try {
                    console.log("initializeDashboardApp: 단계 3 - 로드된 필터 선택 사항 적용 - 시작.");
                    activeFilterConfigs.forEach(config => {
                        const selectEl = document.getElementById(`filter-select-${config.headerName.replace(/\s+/g, '_')}`);
                        if (selectEl && config.selectedValues) {
                            Array.from(selectEl.options).forEach(opt => {
                                if (config.selectedValues.includes(opt.value) && !opt.disabled) opt.selected = true;
                            });
                        }
                    });
                    console.log("initializeDashboardApp: 로드된 필터 선택 사항 적용됨.");
                    console.log("initializeDashboardApp: 단계 3 - 로드된 필터 선택 사항 적용 - 종료");
                } catch (e) {
                    console.error("initializeDashboardApp: 로드된 필터 선택 사항 적용 중 오류 (단계 3):", e);
                }
            } else {
                 console.log("initializeDashboardApp: 단계 3 - window.DASHBOARD_SAVED_SETTINGS.activeFilterConfigs가 없어 로드된 필터 선택 사항 적용 건너뜀.");
            }

            // 단계 4: 초기 대시보드 업데이트 (차트, 테이블)
            try {
                console.log("initializeDashboardApp: 단계 4 - 초기 대시보드 업데이트 - 시작");
                updateDashboard();
                console.log("initializeDashboardApp: 초기 updateDashboard 완료.");
                console.log("initializeDashboardApp: 단계 4 - 초기 대시보드 업데이트 - 종료");
            } catch (e) {
                console.error("initializeDashboardApp: 초기 updateDashboard() 중 오류 (단계 4):", e);
                const uploadStatusEl = document.getElementById('uploadStatus');
                if (uploadStatusEl) {
                    uploadStatusEl.textContent = "대시보드 업데이트 중 오류 발생: " + e.message;
                    uploadStatusEl.style.color = 'red';
                }
            }
            // 단계 5: 버튼 활성 상태 업데이트 (정렬, 전체 선택/해제)
            try {
                console.log("initializeDashboardApp: 단계 5 - 버튼 상태 업데이트 - 시작");
                updateButtonActiveStates();
                console.log("initializeDashboardApp: 버튼 활성 상태 업데이트됨.");
                console.log("initializeDashboardApp: 단계 5 - 버튼 상태 업데이트 - 종료");
            } catch (e) {
                 console.error("initializeDashboardApp: 버튼 활성 상태 업데이트 중 오류 (단계 5):", e);
            }


            // 단계 6: 모든 이벤트 리스너 연결
            try {
                console.log("initializeDashboardApp: 단계 6 - 이벤트 리스너 연결 - 시작");
                const attachListener = (id, event, handler) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener(event, handler);
                    } else {
                        console.error(`ID '${id}'를 가진 요소를 찾을 수 없어 이벤트 리스너를 연결할 수 없습니다. ${event}에 대한 핸들러가 연결되지 않았습니다.`);
                    }
                };

                // Reset filters button
                attachListener('resetFilters', 'click', () => {
                    initializeDataFromSource(initialMasterRawEntries, initialMasterCsvHeaders, initialTotalUnitsPerDongStatic, initialActiveFilterConfigs);
                    initializeDynamicFiltersUI(); // Re-create filters based on initial config
                    updateDashboard();
                    const uploadStatusEl = document.getElementById('uploadStatus');
                    if(uploadStatusEl) uploadStatusEl.textContent = '필터 및 데이터가 초기 상태로 복원되었습니다.';
                });

                attachListener('setInitialStateToCurrent', 'click', () => {
                    initialMasterRawEntries = JSON.parse(JSON.stringify(masterRawEntries));
                    initialMasterCsvHeaders = JSON.parse(JSON.stringify(masterCsvHeaders)); 
                    initialTotalUnitsPerDongStatic = JSON.parse(JSON.stringify(totalUnitsPerDongStatic));
                    initialActiveFilterConfigs = JSON.parse(JSON.stringify(activeFilterConfigs));
                    
                    // Clear selections in UI before re-initializing
                    activeFilterConfigs.forEach(config => {
                        const selectEl = document.getElementById(`filter-select-${config.headerName.replace(/\s+/g, '_')}`);
                        if (selectEl) {
                            Array.from(selectEl.options).forEach(opt => opt.selected = false);
                        }
                        config.selectedValues = []; // Clear stored selections
                    });

                    initializeDynamicFiltersUI();
                    updateDashboard();
                    const uploadStatusEl = document.getElementById('uploadStatus');
                    if(uploadStatusEl) uploadStatusEl.textContent = '현재 데이터 상태가 새로운 초기 상태로 설정되었습니다.';
                });


                attachListener('downloadCsvTemplate', 'click', () => {
                    const csvContent = generateCsvTemplate();
                    downloadFile(csvContent, '유지보수_데이터_양식.csv', 'text/csv;charset=utf-8;');
                });

                attachListener('downloadCurrentCsvState', 'click', () => {
                    const uploadStatusEl = document.getElementById('uploadStatus');
                    if (masterRawEntries.length > 0 && masterCsvHeaders.length > 0) {
                        let csvContent = masterCsvHeaders.map(h => h.name).join(',') + '\n'; 
                        const currentDongHeaderName = getHeaderName("건물동");
                        const currentTotalUnitsHeaderName = getHeaderName("전체 세대수");

                        const entriesWithTotalUnits = masterRawEntries.map(entry => {
                            const dongName = entry[currentDongHeaderName] ? entry[currentDongHeaderName].replace('사택 ','').trim() : '';
                            const newEntry = {...entry}; 
                            newEntry[currentTotalUnitsHeaderName] = totalUnitsPerDongStatic[dongName] === null ? "N/A" : totalUnitsPerDongStatic[dongName];
                            return newEntry;
                        });

                        entriesWithTotalUnits.forEach(entry => {
                            const rowValues = masterCsvHeaders.map(headerConfig => escapeCsvField(entry[headerConfig.name]));
                            csvContent += rowValues.join(',') + '\n';
                        });
                        downloadFile(csvContent, '현재_데이터_상태.csv', 'text/csv;charset=utf-8;');
                        if(uploadStatusEl) uploadStatusEl.textContent = '';
                    } else {
                        if(uploadStatusEl) {
                             uploadStatusEl.textContent = "현재 데이터가 없습니다. CSV 양식을 다운로드하여 데이터를 준비하거나, 파일을 업로드해주세요.";
                             uploadStatusEl.style.color = 'orange';
                        } else {
                            console.warn("현재 데이터가 없습니다. (uploadStatus 요소 없음)");
                        }
                    }
                });

                attachListener('downloadHtml', 'click', () => {
                    try {
                        console.log("downloadHtml: 클릭됨. 설정을 포함한 HTML 다운로드 준비 중.");
                        const settingsToSave = {
                            masterRawEntries: initialMasterRawEntries,
                            masterCsvHeaders: initialMasterCsvHeaders, 
                            filterSortOrders: filterSortOrders, // This might become redundant if fully managed by activeFilterConfigs
                            totalUnitsPerDongStatic: initialTotalUnitsPerDongStatic,
                            activeFilterConfigs: initialActiveFilterConfigs, // Save the initial/default filter config
                            // Save current selections for each active filter
                            currentFilterSelections: activeFilterConfigs.map(fc => ({
                                headerName: fc.headerName,
                                selectedValues: getSelectedOptions(document.getElementById(`filter-select-${fc.headerName.replace(/\s+/g, '_')}`))
                            }))
                        };

                        let settingsJsonString = JSON.stringify(settingsToSave);
                        settingsJsonString = settingsJsonString.replace(/<\/script/gi, '<\\/script');

                        const settingsScriptContentToInject = `window.DASHBOARD_SAVED_SETTINGS = ${settingsJsonString};`;

                        let currentHtml = document.documentElement.outerHTML;
                        const scriptTagRegex = /<script id="dashboardSettingsInline">.*?<\/script>/s;
                        if (currentHtml.match(scriptTagRegex)) {
                            currentHtml = currentHtml.replace(scriptTagRegex, `<script id="dashboardSettingsInline">${settingsScriptContentToInject}<\/script>`);
                             console.log("downloadHtml: 기존 dashboardSettingsInline 스크립트 내용 교체됨.");
                        } else {
                            currentHtml = currentHtml.replace(/\/\/ PLACEHOLDER_FOR_SAVED_SETTINGS/g, `<script id="dashboardSettingsInline">${settingsScriptContentToInject}<\/script>`);
                            console.log("downloadHtml: PLACEHOLDER_FOR_SAVED_SETTINGS가 새 스크립트 태그로 교체됨 (대체 경로).");
                        }


                        downloadFile(currentHtml, '전체_집행_현황_분석.html', 'text/html;charset=utf-8;');
                        console.log("downloadHtml: 파일 다운로드 시작됨.");
                    } catch (e) {
                        console.error("downloadHtml 오류:", e);
                        const uploadStatusEl = document.getElementById('uploadStatus');
                        if (uploadStatusEl) {
                            uploadStatusEl.textContent = "HTML 다운로드 중 오류 발생: " + e.message;
                            uploadStatusEl.style.color = 'red';
                        }
                    }
                });

                attachListener('csvUpload', 'change', (event) => {
                    const file = event.target.files[0];
                    const uploadStatusEl = document.getElementById('uploadStatus');
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            try {
                                processUploadedData(e.target.result);
                            } catch (error) {
                                console.error("CSV 처리 중 오류 발생:", error);
                                if(uploadStatusEl) {
                                     uploadStatusEl.textContent = "오류: CSV 파일 처리 중 문제가 발생했습니다. 콘솔을 확인하세요.";
                                     uploadStatusEl.style.color = 'red';
                                }
                            }
                        };
                        reader.onerror = () => {
                            if(uploadStatusEl) {
                                uploadStatusEl.textContent = "오류: 파일을 읽는 중 오류가 발생했습니다.";
                                uploadStatusEl.style.color = 'red';
                            }
                        };
                        reader.readAsText(file, 'UTF-8');
                    }
                });

                const detailModalEl = document.getElementById('detailModal');
                const detailModalCloseBtn = document.getElementById('detailModalCloseButton');
                if(detailModalCloseBtn && detailModalEl) {
                    detailModalCloseBtn.onclick = () => detailModalEl.classList.remove('active');
                    detailModalEl.onclick = (event) => {
                        if (event.target === detailModalEl) detailModalEl.classList.remove('active');
                    }
                }

                const dataMgmtToggle = document.getElementById('dataManagementToggle');
                const dataMgmtDropdown = document.getElementById('dataManagementDropdown');
                if(dataMgmtToggle && dataMgmtDropdown) {
                    dataMgmtToggle.addEventListener('click', (event) => {
                        event.stopPropagation();
                        dataMgmtDropdown.classList.toggle('active');
                    });
                }
                document.addEventListener('click', (event) => {
                    if (dataMgmtToggle && !dataMgmtToggle.contains(event.target) && dataMgmtDropdown && !dataMgmtDropdown.contains(event.target)) {
                        if(dataMgmtDropdown) dataMgmtDropdown.classList.remove('active');
                    }
                });

                const filterHeaderEl = document.getElementById('filterHeader');
                const filterContentEl = document.getElementById('filterContent');
                const fixedHeaderContainerEl = document.getElementById('fixedHeaderContainer');
                const mainContentContainerEl = document.querySelector('.main-content-container');
                const filterResizeHandle = document.getElementById('filterResizeHandle');
                let isResizingFilter = false;
                let initialFilterHeight = 0;
                let initialFilterMouseY = 0;
                const overviewSectionTitle = document.querySelector('#overview h2');


                if(filterHeaderEl && filterContentEl && fixedHeaderContainerEl && mainContentContainerEl && filterResizeHandle && overviewSectionTitle) {
                    filterHeaderEl.addEventListener('click', (event) => {
                        if (event.target.closest('.filter-controls')) return;

                        filterContentEl.classList.toggle('active');
                        const title = filterHeaderEl.querySelector('h2');
                        if (title) {
                            title.textContent = filterContentEl.classList.contains('active') ? "데이터 필터 (클릭하여 접기)" : "데이터 필터 (클릭하여 펼치기/접기)";
                        }
                        if (filterContentEl.classList.contains('active')) {
                            filterContentEl.style.maxHeight = '250px'; // Default open height
                            filterResizeHandle.style.display = 'block';
                        } else {
                            filterContentEl.style.maxHeight = '0px';
                            filterResizeHandle.style.display = 'none';
                        }
                        setTimeout(() => {
                             if (fixedHeaderContainerEl && mainContentContainerEl) {
                                mainContentContainerEl.style.paddingTop = fixedHeaderContainerEl.offsetHeight + 'px';
                             }
                        }, 50); 
                    });
                    
                    filterResizeHandle.addEventListener('mousedown', (e) => {
                        isResizingFilter = true;
                        initialFilterHeight = filterContentEl.offsetHeight;
                        initialFilterMouseY = e.clientY;
                        document.body.style.userSelect = 'none'; 
                        filterContentEl.style.transition = 'none'; 
                    });

                    document.addEventListener('mousemove', (e) => {
                        if (!isResizingFilter) return;
                        const dy = e.clientY - initialFilterMouseY;
                        let newHeight = initialFilterHeight + dy;
                        
                        const filterHeaderRect = filterHeaderEl.getBoundingClientRect();
                        const firstFilterRow = filterContentEl.querySelector('div > div'); 
                        let minHeight = filterHeaderRect.height + 20; 
                        if(firstFilterRow) { 
                            minHeight = filterHeaderEl.offsetHeight + firstFilterRow.offsetHeight + (filterContentEl.querySelectorAll('div > div').length > 1 ? 20 : 0) + 40 ; 
                        }
                        
                        const contentScrollHeight = filterContentEl.scrollHeight + 20; 
                        let maxHeight = contentScrollHeight; // Max height is the full scrollable content


                        newHeight = Math.max(minHeight, Math.min(newHeight, maxHeight));
                        filterContentEl.style.maxHeight = newHeight + 'px';
                         if (fixedHeaderContainerEl && mainContentContainerEl) {
                            mainContentContainerEl.style.paddingTop = fixedHeaderContainerEl.offsetHeight + 'px';
                         }
                    });

                    document.addEventListener('mouseup', () => {
                        if (isResizingFilter) {
                            isResizingFilter = false;
                            document.body.style.userSelect = '';
                        }
                    });


                    window.addEventListener('resize', () => {
                         if (fixedHeaderContainerEl && mainContentContainerEl) {
                            mainContentContainerEl.style.paddingTop = fixedHeaderContainerEl.offsetHeight + 'px';
                         }
                    });

                    if (fixedHeaderContainerEl && mainContentContainerEl) {
                        mainContentContainerEl.style.paddingTop = fixedHeaderContainerEl.offsetHeight + 'px';
                    }
                }

                // Event listeners for CSV Mapping Modal and Filter Config Modal will be attached when they are opened.
                console.log("initializeDashboardApp: 모든 이벤트 리스너 연결됨 또는 오류 로깅됨.");
                console.log("initializeDashboardApp: 단계 6 - 이벤트 리스너 연결 - 종료");
            } catch (e) {
                console.error("initializeDashboardApp: 이벤트 리스너 연결 중 오류 (단계 6):", e);
            }

            console.log("initializeDashboardApp: try 블록의 끝에 성공적으로 도달함.");
        } catch (initError) {
            console.error("치명적 오류: 대시보드 초기화 실패. Raw initError object:", initError);
            console.error("initError 타입:", typeof initError);
            if (initError && typeof initError === 'object') {
                console.error("initError 속성:", Object.keys(initError).join(', '));
                for (const key in initError) {
                    if (Object.hasOwnProperty.call(initError, key)) {
                        try {
                           console.error(`initError.${key}:`, initError[key]);
                        } catch (propError) {
                           console.error(`initError.${key}: (속성 접근 오류: ${propError.message})`);
                        }
                    }
                }
            }

            let errorMessage = "알 수 없는 오류";
            if (initError && initError.message) {
                errorMessage = initError.message;
                console.error("initError.message의 오류 메시지:", initError.message);
                if (initError.stack) {
                    console.error("오류 스택:", initError.stack);
                }
            } else if (typeof initError === 'string') {
                errorMessage = initError;
                console.error("오류 (문자열):", initError);
            } else if (initError && typeof initError === 'object') {
                try {
                    errorMessage = JSON.stringify(initError);
                    console.error("오류 객체 (JSON.stringify):", errorMessage);
                } catch (e) {
                    errorMessage = String(initError);
                    console.error("오류 객체 (String()):", errorMessage);
                }
            } else {
                 errorMessage = String(initError);
                 console.error("오류 (String으로 변환됨):", errorMessage);
            }

            const body = document.querySelector('body');
            if (body) {
                const errorDivId = 'dashboard-fatal-error-message';
                let errorDiv = document.getElementById(errorDivId);
                if (!errorDiv) {
                    errorDiv = document.createElement('div');
                    errorDiv.id = errorDivId;
                    errorDiv.className = "text-red-500 text-center p-8 text-xl";
                    if (body.firstChild) {
                        body.insertBefore(errorDiv, body.firstChild);
                    } else {
                        body.appendChild(errorDiv);
                    }
                }
                errorDiv.textContent = `오류가 발생하여 대시보드를 로드할 수 없습니다. 콘솔을 확인해주세요. 오류: ${errorMessage}`;
            }
        }
    }

    // --- Main Entry Point ---
    window.onload = () => {
        console.log("이벤트: window.onload 발생. Chart.js 준비 상태 확인 시작...");
        whenChartJsReady(initializeDashboardApp);
    };
</script>
</body>
</html>