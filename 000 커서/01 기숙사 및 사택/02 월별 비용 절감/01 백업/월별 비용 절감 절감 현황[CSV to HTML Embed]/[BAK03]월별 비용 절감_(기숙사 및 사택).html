<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>25년 상반기 유형별 절감 대시보드 (1월~5월)</title>
  <script src="https://d3js.org/d3.v6.min.js"></script>
  <style>
    body { 
      font-family: 'Noto Sans KR', sans-serif; 
      margin: 0; 
      padding: 0; 
      background: #f0f2f5;
      position: relative;
      min-height: 100vh;
      overflow-x: hidden;
      width: 100vw;
      box-sizing: border-box;
    }
    h1 { 
      text-align: center; 
      color: #1a237e; 
      font-size: clamp(16px, 2.5vw, 32px);
      margin-bottom: 2px; 
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      background: #f0f2f5;
      padding: clamp(8px, 1.5vw, 15px);
      z-index: 2000;
      font-weight: 700;
      letter-spacing: 0.5px;
      border-bottom: 2px solid #1a237e;
      width: 100%;
      box-sizing: border-box;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      height: auto;
      min-height: 70px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 15px;  /* 하단 마진 추가 */
    }
    #controls {
      position: fixed;
      top: 0;
      left: 20px;
      z-index: 2000;
      background: #f0f2f5;
      padding: 4px;  /* 6px에서 4px로 감소 */
      border-radius: 4px;  /* 6px에서 4px로 감소 */
      box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      display: flex;
      flex-direction: row;
      align-items: center;
      gap: 4px;  /* 8px에서 4px로 감소 */
      max-width: none;
      transition: all 0.3s ease;
    }
    .file-input-wrapper {
      position: relative;
      min-width: 58px;  /* 65px에서 58px로 감소 */
      cursor: pointer;
      margin-right: 1px;  /* 2px에서 1px로 감소 */
    }
    #file-input {
      position: absolute;
      width: 100%;
      height: 100%;
      opacity: 0;
      cursor: pointer;
      z-index: 2;
    }
    .file-input-label {
      display: block;
      width: 100%;
      padding: 2.5px 3px;  /* 3px 4px에서 2.5px 3px로 감소 */
      background: #e0e0e0;
      color: #666666;
      border: 1px solid #e0e0e0;
      border-radius: 3px;  /* 4px에서 3px로 감소 */
      cursor: pointer;
      font-size: 6.8px;  /* 7px에서 6.8px로 감소 */
      text-align: center;
      transition: all 0.3s ease;
      position: relative;
      z-index: 1;
      white-space: nowrap;
    }
    
    .file-input-label:hover::before {
      content: "CSV 파일을 선택하여 데이터를 업로드합니다";
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 2001;
      margin-top: 5px;
    }
    
    .file-input-wrapper:hover .file-input-label {
      background: #c0c0c0;
      border-color: #e0e0e0;
      transform: translateY(-1px);
    }
    #message {
      display: none;
    }
    #dashboard-container { 
      display: flex; 
      justify-content: center;
      align-items: flex-start;
      gap: 22px;
      padding: 22px;
      flex-wrap: nowrap;
      position: relative;
      width: 100%;
      box-sizing: border-box;
      min-height: calc(100vh - 100px);
      overflow: visible;
      margin-top: 155px;  /* 145px에서 155px로 증가 */
      max-width: 100vw;
      z-index: 1;
    }
    #chart { 
      width: 31.5%;
      max-width: 525px;
      height: calc(100vh - 200px);
      aspect-ratio: 1;
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
      margin: 0;
      padding-left: 30px;  /* 40px에서 30px로 감소 */
      position: relative;
      box-sizing: border-box;
    }
    svg {
      overflow: visible;
      width: 100%;
      height: 100%;
    }
    .node { 
      transform-style: preserve-3d;
      transition: opacity 0.3s ease, filter 0.3s ease;
      cursor: pointer;
      will-change: opacity, filter;
    }
    .node:hover {
      opacity: 0.9;
    }
    .node circle {
      filter: drop-shadow(0 4px 8px rgba(0,0,0,0.2));
      transition: all 0.3s ease;
      will-change: filter, stroke-width;
    }
    .node.selected circle {
      filter: drop-shadow(0 8px 16px rgba(0,0,0,0.3));
      stroke-width: 4;
      opacity: 1 !important;
    }
    .node:not(.selected) circle {
      opacity: 0.3;
      stroke: #cccccc;
    }
    .node text { 
      text-anchor: middle; 
      dominant-baseline: middle; 
      pointer-events: none;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
    }
    .node.selected text {
      font-weight: bold;
      filter: drop-shadow(0 1px 2px rgba(0,0,0,0.3));
      opacity: 1;
    }
    .node:not(.selected) text {
      opacity: 0.3;
    }
    #table-container { 
      width: 77%;
      max-width: 1100px;
      background: white; 
      padding: 16.5px;
      border-radius: 8.8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.1); 
      font-size: 14.3px;
      height: calc(100vh - 200px);
      overflow: auto;
      position: relative;
      flex-shrink: 0;
      box-sizing: border-box;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      justify-content: flex-start;
      margin-top: 16px;
    }
    table { 
      border-collapse: separate; 
      border-spacing: 0;
      width: 100%;
      table-layout: auto;
      position: relative;
      margin-bottom: 30px;
    }
    thead { 
      position: sticky;
      top: 0;
      z-index: 3;
      background: white;
    }
    thead th { 
      background: #f8f9fa; 
      font-size: 13px; 
      padding: 6px;
      border-bottom: 2px solid #dee2e6;
      white-space: normal;
      position: sticky;
      top: 0;
      z-index: 3;
    }
    th, td { 
      padding: 6px; 
      border: 1px solid #dee2e6; 
      text-align: center; 
      font-size: 13px; 
      word-wrap: break-word;
      white-space: normal;
      overflow: hidden;
      max-width: 300px;
    }
    th:nth-child(1), td:nth-child(1) { width: 7%; }  /* 월 */
    th:nth-child(2), td:nth-child(2) { width: 10%; } /* 작업유형 */
    th:nth-child(3), td:nth-child(3) { width: 18%; } /* 절감항목 */
    th:nth-child(4), td:nth-child(4) { width: 10%; } /* A.집행비 */
    th:nth-child(5), td:nth-child(5) { width: 10%; } /* B.공사비 적용시 */
    th:nth-child(6), td:nth-child(6) { width: 10%; } /* 절감비(A-B) */
    th:nth-child(7), td:nth-child(7) { width: 35%; } /* 비고 */
    tr.group-header td { 
      background: #f8f9fa; 
      font-weight: bold; 
      text-align: left; 
    }
    tr.subtotal td { 
      font-weight: bold; 
      background: #e3f2fd; 
      color: #1976d2; 
      font-size: 15.6px;  /* 기존 13px의 20% 증가 */
    }
    tr:hover td {
      background: #f8f9fa;
    }
    .month-checkbox {
      display: flex;
      align-items: center;
      padding: 4px 8px;
      background: transparent;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s ease;
      font-size: 12px;
      color: #999;
    }
    .month-checkbox:hover {
      background: #e9ecef;
    }
    .month-checkbox input[type="checkbox"] {
      display: none;
    }
    .month-checkbox.selected {
      background: #e3f2fd;
      color: #1976d2;
    }
    .month-checkbox.selected::before {
      content: "✓";
      margin-right: 5px;
      color: #1976d2;
    }
    #select-all-container {
      text-align: center;
      margin: 0;
      padding: 3.3px;
      background: #f0f2f5;
      border-radius: 4.4px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.1);
      width: 132px;
      position: fixed;
      top: 95px;  /* 85px에서 95px로 증가 */
      left: 22px;
      z-index: 1999;
      padding-top: 8px;
      padding-bottom: 8px;
      margin-top: 10px;
    }

    #select-all-checkbox {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 3px;
      cursor: pointer;
      padding: 2px 4px;
      font-size: 11px;  /* 크기 조정 */
      color: #666;  /* 글자 색상 */
      transition: all 0.2s ease;
      background: white;  /* 배경색 추가 */
      border-radius: 3px;  /* 모서리 둥글게 */
      padding: 4px 8px;  /* 패딩 추가 */
    }

    #select-all-checkbox input {
      margin: 0;
      width: 12px;  /* 크기 조정 */
      height: 12px;  /* 크기 조정 */
    }

    #select-all-checkbox input:checked + span {
      color: #1a237e;
      font-weight: 500;
    }

    #month-filter-container {
      text-align: center;
      margin: 0 auto 11px;
      padding: 0;
      max-width: 88%;
      position: fixed;
      top: 95px;  /* 85px에서 95px로 증가 */
      left: 198px;
      right: 0;
      z-index: 1999;
      background: #f0f2f5;
      padding: 5.5px 0;
    }
    #month-checkboxes {
      display: flex;
      flex-wrap: wrap;
      gap: 5px;
      justify-content: center;
    }
    @media (max-width: 1400px) {
      #chart {
        width: 25%;
        max-width: 400px;
      }
      #table-container {
        width: 75%;
        max-width: 900px;
      }
      h1 {
        font-size: clamp(14px, 2vw, 28px);  /* 중간 화면용 폰트 크기 */
        padding: clamp(7px, 1.2vw, 12px);  /* 중간 화면용 패딩 */
      }
    }
    @media (max-width: 1200px) {
      #dashboard-container {
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        margin-top: 144px;
        gap: 40px;
      }
      #chart {
        width: 100%;
        max-width: 800px;
        height: 600px;
        margin: 0 auto;
      }
      #table-container {
        width: 100%;
        max-width: 1000px;
        position: static;
        margin: 0 auto;
        height: auto;
        max-height: 600px;
      }
      .file-input-wrapper {
        min-width: 90px;  /* 72px에서 증가 */
      }
      .file-input-label {
        font-size: 9px;  /* 7.2px에서 증가 */
        padding: 4px 6px;  /* 3.6px 4.8px에서 증가 */
      }
      .control-btn {
        min-width: 90px;  /* 72px에서 증가 */
        font-size: 9px;  /* 7.2px에서 증가 */
        padding: 4px 6px;  /* 3.6px 4.8px에서 증가 */
      }
      h1 {
        font-size: clamp(12px, 1.8vw, 24px);  /* 작은 화면용 폰트 크기 */
        padding: clamp(6px, 1vw, 10px);  /* 작은 화면용 패딩 */
      }
      #select-all-container {
        top: 72px;  /* 위치 조정 */
        width: 140px;  /* 크기 조정 */
      }
      #month-filter-container {
        top: 72px;  /* 위치 조정 */
        left: 210px;  /* 위치 조정 */
      }
      th, td {
        font-size: 14px;  /* 13px에서 증가 */
        padding: 7px;  /* 6px에서 증가 */
      }
      .sticky-total-row td {
        font-size: 16px;  /* 15.6px에서 증가 */
      }
      .summary-card h3 {
        font-size: 18px;  /* 16px에서 증가 */
      }
      .summary-item {
        font-size: 15px;  /* 14px에서 증가 */
      }
      .summary-value {
        font-size: 16px;  /* 15px에서 증가 */
      }
    }
    @media (max-width: 1200px) {
      #dashboard-container {
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;  /* flex-start에서 center로 변경 */
        margin-top: 150px;
        gap: 30px;
        padding: 10px;
      }
      #chart {
        width: 100%;
        max-width: 800px;
        height: 600px;
        margin: 0 auto;
      }
      #table-container {
        width: 100%;
        max-width: 1000px;
        position: static;
        margin: 0 auto;
        height: auto;
        max-height: 600px;
      }
    }
    .sticky-total-row { 
      position: sticky; 
      top: 40px;  /* 헤더 높이만큼 아래로 */
      background: #fff5f5; 
      z-index: 2; 
    }
    .sticky-total-row td { 
      font-weight: bold; 
      color: #e74c3c; 
      font-size: 15.6px;
      position: sticky;
      top: 40px;
      z-index: 2;
    }
    tbody {
      margin-top: 80px;  /* 헤더와 총계 행의 높이만큼 여백 추가 */
    }
    tbody tr:not(.sticky-total-row) {
      position: relative;
      z-index: 1;
    }
    /* 비고 열의 텍스트 스타일 */
    td:nth-child(7) {
      font-size: 12px;
      text-align: center;
      padding-left: 10px;
      white-space: normal;
      word-break: break-word;
      cursor: pointer;
      transition: all 0.2s ease;
    }
    /* 하이퍼링크 스타일 */
    .min-labor-cost-link {
      color: #1a237e;
      text-decoration: underline;
      cursor: pointer;
      font-weight: 500;
      transition: all 0.2s ease;
    }

    .min-labor-cost-link:hover {
      color: #0d47a1;
      text-decoration: none;
    }

    /* 하이퍼링크 스타일 */
    .detail-link, .note-link {
      color: #FF33CC;
      text-decoration: underline;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .detail-link:hover, .note-link:hover {
      color: #B800B8;
      text-decoration: none;
    }

    /* 버블 선택 시 비고 열 스타일 변경 */
    .node.selected ~ #table-container td:nth-child(7) {
      font-size: 11px;
      line-height: 1.3;
    }
    /* 절감항목 열 스타일 - 작업유형과 동일하게 */
    th:nth-child(3), td:nth-child(3) {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: auto;
    }
    
    /* 절감항목 열 호버 효과 제거 - 작업유형과 동일하게 */
    td:nth-child(3):hover {
      white-space: nowrap;
      overflow: hidden;
      position: static;
      z-index: auto;
      background-color: transparent;
      box-shadow: none;
    }
    
    /* 버블 선택 시 절감 항목 열 스타일 */
    .node.selected ~ #table-container th:nth-child(3),
    .node.selected ~ #table-container td:nth-child(3) {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    /* B.공사비 적용시 헤더 스타일 - 문자열만 줄바꿈 */
    th:nth-child(5) {
      white-space: normal;
      word-wrap: break-word;
      word-break: break-word;
      line-height: 1.2;
    }
    /* 월, 작업유형 열 스타일 */
    th:nth-child(1), td:nth-child(1),
    th:nth-child(2), td:nth-child(2) {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      width: auto;
    }
    
    /* 월, 작업유형 열 호버 효과 제거 */
    td:nth-child(1):hover,
    td:nth-child(2):hover {
      white-space: nowrap;
      overflow: hidden;
      position: static;
      z-index: auto;
      background-color: transparent;
      box-shadow: none;
    }

    /* 절감비(A-B) 열 스타일 - 중앙 정렬 */
    th:nth-child(6), td:nth-child(6) {
      text-align: center;
    }
    
    .control-btn {
      min-width: 58px;  /* 65px에서 58px로 감소 */
      padding: 2.5px 3px;  /* 3px 4px에서 2.5px 3px로 감소 */
      background: #e0e0e0;
      color: #666666;
      border: 1px solid #e0e0e0;
      border-radius: 3px;  /* 4px에서 3px로 감소 */
      cursor: pointer;
      font-size: 6.8px;  /* 7px에서 6.8px로 감소 */
      transition: all 0.3s ease;
      text-align: center;
      white-space: nowrap;
      margin: 0 1px;  /* 2px에서 1px로 감소 */
      position: relative;
    }
    
    .control-btn:hover {
      background: #c0c0c0;
      border-color: #e0e0e0;
      transform: translateY(-1px);
    }

    .control-btn:hover::before {
      content: attr(data-tooltip);
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.8);
      color: white;
      padding: 5px 10px;
      border-radius: 4px;
      font-size: 12px;
      white-space: nowrap;
      z-index: 2001;
      margin-top: 5px;
    }

    /* 확대된 셀 스타일 */
    .zoomed-cell {
      font-size: 16px !important;
      background-color: #f0f7ff !important;
      border: 2px solid #1a237e !important;
      z-index: 10;
      position: relative;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      padding: 10px !important;
      line-height: 1.5 !important;
      white-space: normal !important;
      overflow: visible !important;
      max-width: none !important;
      width: auto !important;
      height: auto !important;
    }

    /* 확대된 셀을 포함하는 행 스타일 */
    tr:has(.zoomed-cell) {
      position: relative;
      z-index: 100;
      height: auto !important;
    }

    /* 확대된 셀을 포함하는 테이블 스타일 */
    #table-container:has(.zoomed-cell) {
      overflow: visible !important;
    }

    /* 확대된 셀 팝업 스타일 */
    .note-popup {
      position: fixed;
      background-color: #ffffff;
      border: 2px solid #1a237e;
      border-radius: 8px;
      padding: 15px;
      box-shadow: 0 6px 16px rgba(0,0,0,0.3);
      z-index: 1000;
      max-width: 90%;
      max-height: 240px;
      overflow-y: auto;
      font-size: 19px;
      line-height: 1.6;
      white-space: nowrap;
      word-break: keep-all;
      overflow-x: auto;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      color: #1a237e;
      font-weight: 500;
    }

    /* 버블 선택 시 열 너비 조정 */
    .node.selected ~ #table-container th:nth-child(1),
    .node.selected ~ #table-container td:nth-child(1) { width: 6%; }  /* 월 */
    .node.selected ~ #table-container th:nth-child(2),
    .node.selected ~ #table-container td:nth-child(2) { width: 9%; } /* 작업유형 */
    .node.selected ~ #table-container th:nth-child(3),
    .node.selected ~ #table-container td:nth-child(3) { width: 22%; } /* 절감항목 */
    .node.selected ~ #table-container th:nth-child(4),
    .node.selected ~ #table-container td:nth-child(4) { width: 8%; } /* A.집행비 */
    .node.selected ~ #table-container th:nth-child(5),
    .node.selected ~ #table-container td:nth-child(5) { width: 8%; } /* B.공사비 적용시 */
    .node.selected ~ #table-container th:nth-child(6),
    .node.selected ~ #table-container td:nth-child(6) { width: 7%; } /* 절감비(A-B) */
    .node.selected ~ #table-container th:nth-child(7),
    .node.selected ~ #table-container td:nth-child(7) { width: 40%; } /* 비고 - 더 넓게 설정 */

    /* 분석 요약 섹션 스타일 */
    .analysis-summary {
      display: none;
      margin-top: 46px;  /* 40px에서 46px로 증가 (15% 하향) */
      padding: 25px;
      background: #f8f9fa;
      border-radius: 8px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }

    .analysis-summary.show {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: calc(100vh - 300px);
      margin: 0;
      padding: 0;
    }

    .summary-cards {
      display: grid;
      grid-template-columns: 1.5fr 1fr 1.5fr;
      gap: 30px;
      margin-top: 30px;  /* 36px에서 30px로 복원 */
      width: 100%;
      max-width: 1200px;
    }

    .summary-card {
      background: white;
      padding: 25px;
      border-radius: 8px;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      margin-bottom: 24px;  /* 28.8px에서 24px로 복원 */
    }

    /* 총 절감 분석 카드 폭 조정 */
    .summary-card:nth-child(1) {
      min-width: 300px;
    }

    /* 작업 유형별 통계 카드 폭 조정 */
    .summary-card:nth-child(3) {
      min-width: 300px;
    }

    /* 월별 절감 현황 카드 폭 조정 */
    .summary-card:nth-child(2) {
      min-width: 200px;
    }

    .summary-card h3 {
      margin: 0 0 15px 0;
      color: #1a237e;
      font-size: 16px;
      font-weight: 600;
      border-bottom: 2px solid #e3f2fd;
      padding-bottom: 8px;
    }

    .summary-item {
      margin: 18px 0;  /* 21.6px에서 18px로 복원 */
      font-size: 14px;
      line-height: 1.6;
    }

    .summary-item strong {
      color: #1976d2;
      margin-right: 8px;
      font-size: 14px;
    }

    .summary-value {
      font-weight: bold;
      color: #2c3e50;
      font-size: 15px;
    }

    .summary-value.positive {
      color: #2e7d32;
    }

    .summary-value.negative {
      color: #c62828;
    }

    .summary-value small {
      font-size: 12px;
      font-weight: normal;
      margin-left: 2px;
    }

    .summary-item small {
      font-size: 12px;
      color: #666;
      margin-left: 5px;
    }

    /* 반응형 디자인에서의 간격 조정 */
    @media (max-width: 1200px) {
      .analysis-summary {
        margin-top: 57.5px;  /* 50px에서 57.5px로 증가 (15% 하향) */
      }
      .summary-cards {
        gap: 40px;
        margin-top: 42px;  /* 50.4px에서 42px로 복원 */
      }
    }

    /* 메뉴가 제목과 겹칠 때 적용될 스타일 */
    #controls.compact {
      transform: scale(0.8);
      transform-origin: left top;
    }

    #controls.compact .control-btn {
      min-width: 50px;  /* 55px에서 50px로 감소 */
      font-size: 6px;  /* 6.2px에서 6px로 감소 */
      padding: 2px 3px;  /* 2.5px 3.5px에서 2px 3px로 감소 */
    }

    /* 하이퍼링크 기본 스타일 */
    .hyperlink-month,
    .hyperlink-type,
    .hyperlink-detail,
    .hyperlink-note {
      text-decoration: underline;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .hyperlink-month {
      color: #1a237e;
    }

    .hyperlink-type {
      color: #1a237e;
    }

    .hyperlink-detail {
      color: #1a237e;
    }

    .hyperlink-note {
      color: #1a237e;
    }

    .hyperlink-month:hover,
    .hyperlink-type:hover,
    .hyperlink-detail:hover,
    .hyperlink-note:hover {
      opacity: 0.8;
      text-decoration: none;
    }

    /* 하이퍼링크 스타일 조정 패널 스타일 제거 */
    .hyperlink-style-panel {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.2);
      z-index: 2000;
      width: 80%;
      max-width: 800px;
      max-height: 80vh;
      overflow-y: auto;
      display: block !important;
    }

    .hyperlink-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0,0,0,0.5);
      z-index: 1999;
      display: block !important;
    }

    .hyperlink-style-panel h3 {
      color: #1a237e;
      margin: 0 0 20px 0;
      padding-bottom: 10px;
      border-bottom: 2px solid #e3f2fd;
    }

    .hyperlink-type-section {
      margin-bottom: 20px;
      padding: 15px;
      background: #f8f9fa;
      border-radius: 6px;
    }

    .hyperlink-type-section h4 {
      color: #1a237e;
      margin: 0 0 15px 0;
    }

    .style-controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 15px;
    }

    .style-control {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .style-control label {
      font-size: 14px;
      color: #666;
    }

    .style-control input,
    .style-control select {
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
      font-size: 14px;
    }

    .style-preview {
      margin-top: 10px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: white;
    }

    .panel-buttons {
      display: flex;
      justify-content: flex-end;
      gap: 10px;
      margin-top: 20px;
      padding-top: 20px;
      border-top: 1px solid #eee;
    }

    .panel-button {
      padding: 8px 16px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.2s ease;
    }

    .panel-button.apply {
      background: #1a237e;
      color: white;
    }

    .panel-button.cancel {
      background: #e0e0e0;
      color: #666;
    }

    .panel-button:hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }

    /* 모든 신규 하이퍼링크에 대한 기본 스타일 */
    a:not(.min-labor-cost-link):not(.detail-link):not(.note-link) {
      color: #FF00FF !important;
      text-decoration: underline;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    /* 마우스 호버 시 스타일 */
    a:not(.min-labor-cost-link):not(.detail-link):not(.note-link):hover {
      color: #FF00FF !important;
      text-decoration: none;
    }

    /* 기존 하이퍼링크 클래스들도 #FF00FF 색상으로 통일 */
    .min-labor-cost-link,
    .detail-link,
    .note-link,
    .hyperlink-month,
    .hyperlink-type,
    .hyperlink-detail,
    .hyperlink-note {
      color: #FF00FF !important;
      text-decoration: underline;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .min-labor-cost-link:hover,
    .detail-link:hover,
    .note-link:hover,
    .hyperlink-month:hover,
    .hyperlink-type:hover,
    .hyperlink-detail:hover,
    .hyperlink-note:hover {
      color: #FF00FF !important;
      text-decoration: none;
    }
  </style>
</head>
<body>
  <h1>2025년 상반기 유형별 절감 현황 대시보드</h1>
  <div id="controls">
    <div class="file-input-wrapper">
      <input type="file" id="file-input" accept=".csv" title="CSV 파일을 선택하여 데이터를 업로드합니다">
      <label class="file-input-label" for="file-input">로우데이터 업로드</label>
    </div>
    <button id="download-csv-btn" class="control-btn" data-tooltip="현재 데이터를 CSV 파일로 다운로드합니다">로우데이터 다운로드</button>
    <button id="download-html-btn" class="control-btn" data-tooltip="현재 데이터가 포함된 HTML 파일을 다운로드합니다">HTML 다운로드</button>
    <button id="upload-link-btn" class="control-btn" data-tooltip="하이퍼링크 설정을 업로드합니다">하이퍼링크 업로드</button>
    <button id="download-link-btn" class="control-btn" data-tooltip="하이퍼링크 설정을 다운로드합니다">하이퍼링크 다운로드</button>
  </div>
  <div id="select-all-container">
    <label id="select-all-checkbox">
      <input type="checkbox" id="select-all">
      <span>전체 버블 선택/해제</span>
    </label>
  </div>
  <div id="month-filter-container">
    <div id="month-checkboxes"></div>
  </div>
  <div id="dashboard-container">
    <svg id="chart"></svg>
    <div id="table-container">
      <table>
        <thead>
          <tr><th>월</th><th>작업유형</th><th>절감항목</th><th>A.집행비</th><th>B.공사비 적용시</th><th>절감비(A-B)</th><th>비고</th></tr>
        </thead>
        <tbody>
          <tr class="sticky-total-row">
            <td></td>
            <td></td>
            <td>총 절감합계</td>
            <td></td>
            <td></td>
            <td id="total-top">-</td>
            <td></td>
          </tr>
        </tbody>
      </table>
      <div class="analysis-summary">
        <div class="summary-cards">
          <div class="summary-card">
            <h3>총 절감 분석</h3>
            <div id="total-summary"></div>
          </div>
          <div class="summary-card">
            <h3>월별 절감 현황</h3>
            <div id="monthly-summary"></div>
          </div>
          <div class="summary-card">
            <h3>작업 유형별 통계</h3>
            <div id="type-summary"></div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>
    // 페이지 로드 시 확대/축소 초기화
    window.addEventListener('load', function() {
      document.body.style.zoom = '100%';
      localStorage.removeItem('pageZoom');
    });

    let svg = null;
    let width = 0;
    let height = 0;
    const margin = 10;
    let allData = []; // HTML 다운로드 시 이 변수가 실제 데이터로 채워짐
    let selectedTypes = new Set();
    let selectedMonths = new Set();
    let colorScale = null;
    let hyperlinkRules = []; // HTML 다운로드 시 이 변수가 실제 규칙으로 채워짐

    function formatMonth(month) {
      return month.replace('월', '월');
    }

    function updateMonthFilter() {
      const monthCheckboxes = document.getElementById('month-checkboxes');
      const months = [...new Set(allData.map(d => d.month))].sort();
      
      monthCheckboxes.innerHTML = months.map(m => `
        <label class="month-checkbox ${selectedMonths.has(m) ? 'selected' : ''}">
          <input type="checkbox" value="${m}" ${selectedMonths.has(m) ? 'checked' : ''}>
          ${formatMonth(m)}
        </label>
      `).join('');

      // 체크박스 이벤트 리스너 추가
      monthCheckboxes.querySelectorAll('.month-checkbox').forEach(checkbox => {
        checkbox.addEventListener('click', function() {
          const month = this.querySelector('input').value;
          if (selectedMonths.has(month)) {
            selectedMonths.delete(month);
            this.classList.remove('selected');
          } else {
            selectedMonths.add(month);
            this.classList.add('selected');
          }
          updateTable();
          updateBubbleOpacity();
        });
      });
    }

    function updateBubbleOpacity() {
      svg.selectAll('.node').each(function(d) {
        const node = d3.select(this);
        const month = d.data.month;
        const isSelected = selectedMonths.size === 0 || selectedMonths.has(month);
        const isTypeSelected = selectedTypes.has(d.data.type);
        
        if (isTypeSelected) {
          node.style('opacity', 1);
          node.select('circle')
            .attr('stroke', '#000000')
            .attr('stroke-width', 4);
          node.select('text').style('opacity', 1);
        } else {
          node.style('opacity', isSelected ? 0.5 : 0.3);
          node.select('circle')
            .attr('stroke', '#cccccc')
            .attr('stroke-width', 2);
          node.select('text').style('opacity', isSelected ? 0.5 : 0.3);
        }
      });
    }

    function initChart() {
      const chartContainer = document.getElementById('chart');
      const containerWidth = chartContainer.clientWidth;
      const containerHeight = chartContainer.clientHeight;
      width = Math.min(containerWidth, containerHeight);
      height = width; // 정사각형 유지
      
      // 화면 크기에 따라 폰트 크기 조정
      const baseFontSize = Math.min(18, width / 18);
      
      // SVG 요소가 없거나 크기가 변경된 경우에만 새로 생성
      if (!svg || svg.attr('width') !== width || svg.attr('height') !== height) {
        svg = d3.select('#chart')
          .attr('width', width)
          .attr('height', height)
          .attr('viewBox', `0 0 ${width} ${height}`)
          .attr('preserveAspectRatio', 'xMidYMid meet');
      }

      // 버블 내 텍스트 크기 조정을 위한 전역 변수 설정
      window.chartFontSize = baseFontSize;
    }

    function drawChart() {
      if (!svg) initChart();
      
      // SVG 요소가 비어있지 않은 경우에만 제거
      if (svg.selectAll('*').size() > 0) {
        svg.selectAll('*').remove();
      }
      
      // 배경 영역 추가 (버블 외 영역 클릭 감지용)
      svg.append('rect')
        .attr('width', width)
        .attr('height', height)
        .attr('fill', 'transparent')
        .on('click', function() {
          // 버블 외 영역 클릭 시 선택 해제
          selectedTypes.clear();
          selectedMonths.clear();
          
          // 모든 버블 선택 해제
          svg.selectAll('.node')
            .classed('selected', false)
            .select('circle')
            .transition()
            .duration(300)
            .attr('r', d => d.r)
            .attr('stroke', '#cccccc')
            .attr('stroke-width', 2)
            .style('opacity', 0.5);
            
          // 전체 선택 체크박스 상태 업데이트
          document.getElementById('select-all').checked = false;
          
          updateMonthFilter();
          updateTable();
          updateBubbleOpacity();
        });
      
      // 작업유형별 데이터 그룹화 로직 개선
      const packData = d3.rollups(allData,
        v => {
          const validData = v.filter(d => d.month && d.type && d.detail);
          const negativeCount = validData.filter(d => d.saving < 0).length;
          return {
            value: d3.sum(validData, d => Math.abs(d.saving)) || 1,
            total: d3.sum(validData, d => d.saving) || 0,
            months: [...new Set(validData.map(d => d.month))],
            count: negativeCount
          };
        },
        d => d.type
      ).map(([type, stats]) => ({ type, ...stats }));

      const sizeScale = 0.95;
      
      const pack = d3.pack()
        .size([(width - margin*2) * sizeScale, (height - margin*2) * sizeScale])
        .padding(4);

      const root = pack(d3.hierarchy({ children: packData }).sum(d => d.value));
      colorScale = d3.scaleOrdinal().domain(packData.map(d=>d.type)).range(d3.schemeTableau10);
      
      document.getElementById('select-all').checked = selectedTypes.size === packData.length;
      
      const bubbleHeight = d3.max(root.leaves(), d => d.y + d.r) - d3.min(root.leaves(), d => d.y - d.r);
      const offsetY = (height - bubbleHeight) / 2 - d3.min(root.leaves(), d => d.y - d.r);
      const offsetX = margin + 35;  // 45에서 35로 감소

      const nodes = svg.selectAll('g.node').data(root.leaves(), d=>d.data.type).enter().append('g')
        .attr('class', d => `node ${selectedTypes.has(d.data.type) ? 'selected' : ''}`)
        .attr('transform', d=>`translate(${d.x + offsetX},${d.y + offsetY + margin})`)
        .on('click', function(event, d) {
          event.preventDefault();
          event.stopPropagation();
          
          if (event.ctrlKey || event.metaKey) {
            // Ctrl/Cmd 키를 누른 상태에서 클릭하면 다중 선택
            if (selectedTypes.has(d.data.type)) {
              selectedTypes.delete(d.data.type);
              d3.select(this).classed('selected', false);
              d3.select(this).select('circle')
                .transition()
                .duration(300)
                .attr('r', d.r);
            } else {
              selectedTypes.add(d.data.type);
              d3.select(this).classed('selected', true);
              d3.select(this).select('circle')
                .transition()
                .duration(300)
                .attr('r', d.r * 1.3);
            }
          } else {
            // 일반 클릭은 단일 선택
            if (selectedTypes.has(d.data.type)) {
              selectedTypes.clear();
              d3.select(this).classed('selected', false);
              d3.select(this).select('circle')
                .transition()
                .duration(300)
                .attr('r', d.r);
            } else {
              selectedTypes.clear();
              selectedTypes.add(d.data.type);
              svg.selectAll('.node').classed('selected', false);
              svg.selectAll('.node circle')
                .transition()
                .duration(300)
                .attr('r', d => d.r);
              d3.select(this).classed('selected', true);
              d3.select(this).select('circle')
                .transition()
                .duration(300)
                .attr('r', d.r * 1.3);
            }
          }

          document.getElementById('select-all').checked = selectedTypes.size === packData.length;

          const selectedMonthsSet = new Set();
          selectedTypes.forEach(type => {
            const bubble = packData.find(b => b.type === type);
            if (bubble) {
              bubble.months.forEach(month => selectedMonthsSet.add(month));
            }
          });
          selectedMonths = selectedMonthsSet;

          updateMonthFilter();
          updateTable();
          updateBubbleOpacity();
        });

      nodes.append('circle')
        .attr('r', d=>d.r)
        .attr('fill', d=>colorScale(d.data.type))
        .attr('stroke', d=> selectedTypes.has(d.data.type) ? '#000000' : '#cccccc')
        .attr('stroke-width', d=> selectedTypes.has(d.data.type) ? 4 : 2)
        .style('opacity', d => selectedTypes.has(d.data.type) ? 1 : 0.5);

      nodes.append('text')
        .attr('text-anchor','middle')
        .attr('dominant-baseline','middle')
        .style('fill', d=> {
          const c = d3.color(colorScale(d.data.type)).rgb();
          return (0.299*c.r + 0.587*c.g + 0.114*c.b) > 150 ? '#2c3e50' : '#fff';
        })
        .style('opacity', d => selectedTypes.has(d.data.type) ? 1 : 0.5)
        .each(function(d) {
          const t = d3.select(this);
          t.text('');
          
          const typeText = d.data.type;
          const typeWords = typeText.split(' ');
          let currentLine = '';
          let lines = [];
          
          const maxTextWidth = d.r * 1.8;
          const fontSize = Math.min(window.chartFontSize, d.r / 3);
          
          typeWords.forEach(word => {
            if ((currentLine + word).length * fontSize / 2 > maxTextWidth) {
              lines.push(currentLine.trim());
              currentLine = word;
            } else {
              currentLine += (currentLine ? ' ' : '') + word;
            }
          });
          if (currentLine) lines.push(currentLine.trim());
          
          const lineHeight = fontSize * 1.2;
          const amountText = d3.format(',')(d.data.total);
          const amountFontSize = Math.min(fontSize, d.r / 4);
          const selectedAmountFontSize = Math.min(fontSize * 1.8, d.r / 2.5);
          const countText = `${d.data.count}건`;
          const countFontSize = Math.min(amountFontSize, d.r / 5);
          const selectedCountFontSize = Math.min(fontSize * 1.6, d.r / 3);
          
          const totalTextHeight = lines.length * lineHeight + lineHeight * 1.5 + lineHeight * 1.2;
          const startY = -totalTextHeight / 2 + lineHeight / 2;
          
          lines.forEach((line, i) => {
            t.append('tspan')
              .attr('x', 0)
              .attr('dy', i === 0 ? startY + 'px' : lineHeight + 'px')
              .text(line)
              .style('font-size', fontSize + 'px');
          });
          
          const typeToAmountGap = lineHeight * 1.5;
          
          t.append('tspan')
            .attr('x', 0)
            .attr('dy', typeToAmountGap + 'px')
            .text(amountText)
            .style('font-size', selectedTypes.has(d.data.type) ? selectedAmountFontSize + 'px' : amountFontSize + 'px')
            .style('font-weight', selectedTypes.has(d.data.type) ? 'bold' : 'normal');
            
          const amountToCountGap = lineHeight * 1.2;
          
          t.append('tspan')
            .attr('x', 0)
            .attr('dy', amountToCountGap + 'px')
            .text(countText)
            .style('font-size', selectedTypes.has(d.data.type) ? selectedCountFontSize + 'px' : countFontSize + 'px')
            .style('font-weight', selectedTypes.has(d.data.type) ? 'bold' : 'normal');
            
          t.style('font-weight', selectedTypes.has(d.data.type) ? 'bold' : 'normal');
        });
    }

    // 화면 크기 변경 시 차트 다시 그리기
    window.addEventListener('resize', function() {
      if (allData.length > 0) {
        initChart();
        drawChart();
      }
    });

    document.getElementById('file-input').addEventListener('change', function(e) {
      const file = e.target.files[0]; if (!file) return;
      const reader = new FileReader();
      
      // 숫자 포맷팅 함수 추가
      function formatNumberWithCommas(str) {
        if (/^-?\d+$/.test(str)) {
          return str.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        }
        return str.replace(/(\d{3,})/g, function(match) {
          return match.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
        });
      }
      
      reader.onload = function(ev) {
        try {
          const rawData = d3.csvParse(ev.target.result);
          
          if (!rawData || !rawData.length) {
            console.error('CSV 파일을 분석할 수 없습니다.');
            return;
          }
          
          // 데이터 전처리 함수
          function processData(rawData) {
            return rawData.map(d => {
              const month = d['월'] || '';
              const type = d['작업유형'] || '';
              const detail = d['절감항목'] || '';
              const note = d['비고'] || '';
              
              const actual = parseFloat((d['A.집행비'] || '0').replace(/,/g, '')) || 0;
              const estimated = parseFloat((d['B.공사비 적용시'] || '0').replace(/,/g, '')) || 0;
              const saving = parseFloat((d['절감비(A-B)'] || '0').replace(/,/g, '')) || 0;
              
              const formattedDetail = formatNumberWithCommas(detail);
              let formattedNote = formatNumberWithCommas(note);

              // 최소인건비 텍스트를 하이퍼링크로 변환
              const minLaborCostLinks = {
                '기계 최소인건비': 'https://photos.app.goo.gl/od8H1Cn9ZXcyttq6A',
                '건축 최소인건비': 'https://photos.app.goo.gl/RY4GxypvWKuGJnuu7',
                '전기 최소인건비': 'https://photos.app.goo.gl/htiYjUpzb8U7YtdW8'
              };

              Object.entries(minLaborCostLinks).forEach(([text, url]) => {
                if (formattedNote.includes(text)) {
                  formattedNote = formattedNote.replace(
                    text,
                    `<span class="min-labor-cost-link" onclick="window.open('${url}', '_blank')">${text}</span>`
                  );
                }
              });
              
              return {
                month: month, 
                type: type, 
                detail: formattedDetail,
                actual: actual, 
                estimated: estimated, 
                saving: saving,
                note: formattedNote
              };
            }).map(d => {
              const monthMatch = d.month.match(/(\d{4})-(\d{2})/);
              if (monthMatch) {
                d.month = `${monthMatch[1]}-${monthMatch[2]}`;
              }
              return d;
            }).sort((a, b) => {
              if (a.month !== b.month) return a.month.localeCompare(b.month);
              return a.type.localeCompare(b.type);
            });
          }
          
          // 데이터 로드 및 렌더링 함수
          function loadAndRenderData(rawData) {
            allData = processData(rawData);
            // 초기 렌더링 전에 차트 컨테이너 크기 강제 업데이트
            const chartContainer = document.getElementById('chart');
            chartContainer.style.width = '100%';
            chartContainer.style.height = '100%';
            
            // 화면 설정값 표시
            const screenInfo = {
              width: window.innerWidth,
              height: window.innerHeight,
              scale: window.devicePixelRatio,
              chartWidth: chartContainer.clientWidth,
              chartHeight: chartContainer.clientHeight
            };
            // alert(`화면 설정값:\n화면 너비: ${screenInfo.width}px\n화면 높이: ${screenInfo.height}px\n화면 배율: ${screenInfo.scale}\n차트 너비: ${screenInfo.chartWidth}px\n차트 높이: ${screenInfo.chartHeight}px`);
            
            // 약간의 지연 후 렌더링 실행
            setTimeout(() => {
              initChart();
              drawChart();
              updateTable(); // 이 안에서 applyHyperlinkRules가 호출됨
              updateMonthFilter();
              updateAnalysisSummary();
            }, 50);
          }
          
          // 데이터 로드 및 렌더링 실행
          loadAndRenderData(rawData);
          
          selectedTypes = new Set();
          selectedMonths = new Set();
          // updateMonthFilter(); // loadAndRenderData 내부에서 호출됨
          
        } catch (error) {
          console.error('파일 처리 중 오류가 발생했습니다:', error);
        }
      };
      
      reader.readAsText(file);
    });

    function updateTable() {
      const tbody = document.querySelector('tbody');
      const totalRow = document.querySelector('.sticky-total-row');
      tbody.innerHTML = '';
      tbody.appendChild(totalRow);

      // 월 필터 적용
      let filtered = allData.filter(d => selectedTypes.has(d.type));
      if (selectedMonths.size > 0) {
        filtered = filtered.filter(d => selectedMonths.has(d.month));
      }
      
      // 유형별로 그룹화
      const typeGroups = d3.group(filtered, d => d.type);
      let totalSum = 0;

      // 분석 요약 섹션 표시/숨김 제어
      const analysisSummary = document.querySelector('.analysis-summary');
      const tableElement = document.querySelector('table');
      
      if (selectedTypes.size === 0) {
        analysisSummary.classList.add('show');
        tableElement.style.display = 'none';  // 테이블 숨김
        updateAnalysisSummary();
      } else {
        analysisSummary.classList.remove('show');
        tableElement.style.display = 'table';  // 테이블 표시
      }

      // 비고 열의 최대 너비를 계산하기 위한 변수
      let maxNoteWidth = 0;
      let maxNoteText = '';
      
      // 절감 항목 열의 최대 너비를 계산하기 위한 변수
      let maxDetailWidth = 0;
      let maxDetailText = '';
      
      // 먼저 모든 비고 텍스트와 절감 항목 텍스트의 길이를 확인
      typeGroups.forEach((rows, type) => {
        rows.forEach(row => {
          // 비고 텍스트 길이 확인
          if (row.note && row.note.length > maxNoteText.length) {
            maxNoteText = row.note;
            maxNoteWidth = Math.max(maxNoteWidth, row.note.length * 8);
          }
          
          // 절감 항목 텍스트 길이 확인
          if (row.detail && row.detail.length > maxDetailText.length) {
            maxDetailText = row.detail;
            maxDetailWidth = Math.max(maxDetailWidth, row.detail.length * 8);
          }
        });
      });
      
      // 비고 열의 너비를 동적으로 조정 (더 넓게 설정)
      const tableContainer = document.getElementById('table-container');
      const tableWidth = tableContainer.clientWidth;
      
      // 버블 선택 여부에 따라 비고 열 너비 조정
      let noteColumnWidth;
      if (selectedTypes.size === 1) {
        // 단일 버블 선택 시 비고 열 너비를 더 넓게 설정
        noteColumnWidth = Math.min(Math.max(maxNoteWidth + 20, tableWidth * 0.4), tableWidth * 0.5);
      } else {
        // 기본 비고 열 너비
        noteColumnWidth = Math.min(Math.max(maxNoteWidth + 20, tableWidth * 0.35), tableWidth * 0.45);
      }
      
      // 절감 항목 열 너비 계산
      let detailColumnWidth;
      if (selectedTypes.size === 1) {
        // 단일 버블 선택 시 절감 항목 열 너비를 텍스트 길이에 맞게 설정
        detailColumnWidth = Math.min(Math.max(maxDetailWidth + 20, tableWidth * 0.22), tableWidth * 0.3);
      } else {
        // 기본 절감 항목 열 너비
        detailColumnWidth = Math.min(Math.max(maxDetailWidth + 20, tableWidth * 0.18), tableWidth * 0.25);
      }
      
      // 열 너비를 동적으로 설정
      const style = document.createElement('style');
      style.textContent = `
        @media (min-width: 1200px) {
          th:nth-child(7), td:nth-child(7) { 
            width: ${noteColumnWidth}px !important; 
            max-width: ${noteColumnWidth}px !important;
          }
          th:nth-child(3), td:nth-child(3) {
            width: ${detailColumnWidth}px !important;
            max-width: ${detailColumnWidth}px !important;
          }
        }
      `;
      document.head.appendChild(style);

      // B.공사비 적용시 헤더 스타일 적용 - "B.공사비" 이후 줄바꿈
      const bHeader = document.querySelector('th:nth-child(5)');
      if (bHeader) {
        // 기존 내용 가져오기
        const originalText = bHeader.textContent;
        
        // "B.공사비" 이후 줄바꿈 적용
        if (originalText.includes('B.공사비 적용시')) {
          bHeader.innerHTML = 'B.공사비<br>적용시';
        }
        
        // 스타일 적용
        bHeader.style.whiteSpace = 'normal';
        bHeader.style.wordWrap = 'break-word';
        bHeader.style.wordBreak = 'break-word';
        bHeader.style.lineHeight = '1.2';
      }

      typeGroups.forEach((rows, type) => {
        // 각 행 추가
        rows.forEach(row => {
          const tr = document.createElement('tr');
          ['month','type','detail','actual','estimated','saving','note'].forEach(key => {
            const td = document.createElement('td');
            let val = row[key];
            if (['actual','estimated','saving'].includes(key)) {
              if (val === 0) td.textContent = '-';
              else {
                td.textContent = d3.format(',')(val);
                if (val < 0) td.style.color = 'red';
              }
            } else if (key === 'month') {
              td.textContent = formatMonth(val);
            } else if (key === 'note') {
              // 비고 열의 텍스트 처리
              td.innerHTML = val; // HTML로 설정하여 span 태그 등이 렌더링되도록 함
              td.style.textAlign = 'center';
              td.style.paddingLeft = '10px';
              td.style.whiteSpace = 'normal';
              td.style.wordBreak = 'break-word';
              
              // 비고 하이퍼링크 매핑 (기본) - applyHyperlinkRules에서 덮어쓸 수 있음
              if (val && typeof val === 'string' && val.includes('비용 추정(보수적)')) {
                td.innerHTML = val.replace(
                  '비용 추정(보수적)',
                  '<a href="https://photos.app.goo.gl/RmJhxWhF3xZW7zAu8" target="_blank" class="note-link">비용 추정(보수적)</a>'
                );
              }
              
              // 버블 선택 시 비고 텍스트 크기 조정
              if (selectedTypes.size === 1) {
                td.style.fontSize = '11px';
                td.style.lineHeight = '1.3';
              }
              
              // 비고 셀에 클릭 이벤트 추가
              td.addEventListener('click', function(e) {
                e.stopPropagation(); // 이벤트 버블링 방지
                
                // 현재 확대된 셀 확인
                const currentlyZoomed = document.querySelector('.zoomed-cell');
                if (currentlyZoomed && currentlyZoomed !== this) {
                  currentlyZoomed.classList.remove('zoomed-cell');
                  const existingPopup = document.querySelector('.note-popup');
                  if (existingPopup) existingPopup.remove();
                }
                
                this.classList.toggle('zoomed-cell');
                
                if (this.classList.contains('zoomed-cell')) {
                  const popup = document.createElement('div');
                  popup.className = 'note-popup';
                  popup.innerHTML = this.innerHTML; // 현재 셀의 HTML 내용을 팝업에 그대로 복사
                  
                  document.body.appendChild(popup);
                  
                  const closeBtn = document.createElement('button');
                  closeBtn.textContent = '×';
                  closeBtn.style.cssText = `position: absolute; right: 5px; top: 5px; background: none; border: none; font-size: 22px; cursor: pointer; color: #1a237e;`;
                  closeBtn.onclick = function(ev) {
                    ev.stopPropagation();
                    popup.remove();
                    td.classList.remove('zoomed-cell');
                  };
                  popup.appendChild(closeBtn);
                  
                  document.addEventListener('click', function closePopupOnClickOutside(ev) {
                    if (!popup.contains(ev.target) && ev.target !== td) {
                      popup.remove();
                      td.classList.remove('zoomed-cell');
                      document.removeEventListener('click', closePopupOnClickOutside);
                    }
                  }, { once: true }); // 한번 실행 후 자동 제거
                } else {
                  const popup = document.querySelector('.note-popup');
                  if (popup) popup.remove();
                }
              });
            } else if (key === 'detail') {
              // 절감 항목 열의 텍스트 처리
              td.textContent = val;
              td.title = val; // 툴팁 추가
              
              // 하이퍼링크 매핑 (기본) - applyHyperlinkRules에서 덮어쓸 수 있음
              const detailLinks = {
                '사택 102-401 세대내 고장 보일러 교체': 'https://photos.app.goo.gl/ZSpjCao7BtfsuDmU8',
                '사택 9-501 누수탐지 및 바닥 매립배관 보수': 'https://photos.app.goo.gl/VysKu4vh8CJci2s38',
                '기숙사 및 사택 긴급보수 작업(건축)-1차': 'https://photos.app.goo.gl/kgQVvQyvHmAoMDcq7',
                '사택 5-401 누수 난방분배기 교체': 'https://photos.app.goo.gl/wi2X32C25LtwxwV17',
                '기숙사동 및 사택 저수조 안전 브라켓': 'https://photos.app.goo.gl/orM3oQ4oymfL2sAGA',
                '기숙사동 및 사택 소방 지적사항 보완': 'https://photos.app.goo.gl/EzqSAa5XAneNd5E47'
              };

              if (val && typeof val === 'string' && detailLinks[val]) {
                td.innerHTML = `<a href="${detailLinks[val]}" target="_blank" class="detail-link">${val}</a>`;
              }
              
              // 버블 선택 시 절감 항목 텍스트 스타일 조정
              if (selectedTypes.size === 1) {
                td.style.whiteSpace = 'nowrap';
                td.style.overflow = 'hidden';
                td.style.textOverflow = 'ellipsis';
              }
              
              // 절감 항목 셀에 호버 이벤트 추가
              td.addEventListener('mouseenter', function() {
                this.style.whiteSpace = 'normal';
                this.style.overflow = 'visible';
                this.style.position = 'relative';
                this.style.zIndex = '5';
                this.style.backgroundColor = '#f8f9fa';
                this.style.boxShadow = '0 2px 5px rgba(0,0,0,0.1)';
              });
              
              td.addEventListener('mouseleave', function() {
                this.style.whiteSpace = 'nowrap';
                this.style.overflow = 'hidden';
                this.style.position = 'static';
                this.style.zIndex = 'auto';
                this.style.backgroundColor = '';
                this.style.boxShadow = 'none';
              });
            } else {
              td.textContent = val;
            }
            tr.appendChild(td);
          });
          tbody.appendChild(tr);
        });

        // 유형별 소계 추가
        const subtotal = rows.reduce((sum, r) => sum + r.saving, 0);
        totalSum += subtotal;
        const trSub = document.createElement('tr');
        trSub.className = 'subtotal';
        
        // Get the color for this type from the color scale
        const typeColor = colorScale(type);
        
        // 빈 셀 추가
        const tdEmpty1 = document.createElement('td');
        const tdEmpty2 = document.createElement('td');
        
        // 소계 텍스트 셀 (절감항목 열에 위치)
        const tdL = document.createElement('td');
        tdL.textContent = `${type} 소계`;
        tdL.style.color = typeColor;
        
        // 빈 셀 추가
        const tdEmpty3 = document.createElement('td');
        const tdEmpty4 = document.createElement('td');
        
        const tdV = document.createElement('td');
        if (subtotal === 0) tdV.textContent = '-';
        else {
          tdV.textContent = d3.format(',')(subtotal);
          tdV.style.color = typeColor;
        }

        const tdEmpty5 = document.createElement('td');
        
        trSub.appendChild(tdEmpty1);
        trSub.appendChild(tdEmpty2);
        trSub.appendChild(tdL);
        trSub.appendChild(tdEmpty3);
        trSub.appendChild(tdEmpty4);
        trSub.appendChild(tdV);
        trSub.appendChild(tdEmpty5);
        tbody.appendChild(trSub);
      });

      // 총계 업데이트
      const totalTop = document.getElementById('total-top');
      if (totalSum === 0) totalTop.textContent = '-';
      else {
        totalTop.textContent = d3.format(',')(totalSum);
        if (totalSum < 0) totalTop.style.color = 'red';
      }
      
      // 테이블 업데이트 후 하이퍼링크 규칙 적용
      applyHyperlinkRules();
    }

    function updateAnalysisSummary() {
      // 1. allData가 비어있어도 안내 메시지를 표시하도록 개선
      const totalSummary = document.getElementById('total-summary');
      const monthlySummaryContainer = document.getElementById('monthly-summary');
      const typeSummaryContainer = document.getElementById('type-summary');

      if (!totalSummary || !monthlySummaryContainer || !typeSummaryContainer) return; // id 오타/중복 방지

      if (!allData || allData.length === 0) {
        totalSummary.innerHTML = `
          <div class="summary-item" style="color:#c62828;">
            <strong>데이터가 없습니다.</strong><br>
            CSV 파일을 업로드하면 분석 결과가 표시됩니다.
          </div>
        `;
        monthlySummaryContainer.innerHTML = ''; // 월별 요약 비우기
        typeSummaryContainer.innerHTML = '';    // 유형별 요약 비우기
        return;
      }

      // 월별 절감 현황
      const monthlyData = d3.rollups(
        allData.filter(d => d.saving !== 0),
        v => ({
          total: d3.sum(v, d => d.saving),
          count: v.length,
          avg: d3.sum(v, d => d.saving) / v.length
        }),
        d => d.month
      ).sort((a, b) => a[0].localeCompare(b[0]));

      monthlySummaryContainer.innerHTML = monthlyData.map(([month, stats]) => `
        <div class="summary-item">
          <strong>
            <span class="summary-month-label" data-month="${month}" style="color:#1976d2; cursor:pointer; text-decoration:underline;">
              ${formatMonth(month)}
            </span>:
          </strong>
          <span class="summary-value ${stats.total >= 0 ? 'positive' : 'negative'}">
            ${formatNumber(stats.total)}
          </span>
          <br>
          <small>(${stats.count}건, 평균 ${formatNumber(stats.avg)})</small>
        </div>
      `).join('');

      // 작업 유형별 통계
      const typeData = d3.rollups(
        allData.filter(d => d.saving !== 0),
        v => ({
          total: d3.sum(v, d => d.saving),
          count: v.length,
          avg: d3.sum(v, d => d.saving) / v.length
        }),
        d => d.type
      ).sort((a, b) => Math.abs(b[1].total) - Math.abs(a[1].total));

      if (typeSummaryContainer) {
        typeSummaryContainer.innerHTML = typeData.map(([type, stats]) => {
          const typeColor = colorScale ? colorScale(type) : '#1976d2'; // colorScale이 초기화 안됐을 경우 대비
          return `
            <div class="summary-item">
              <strong style="color: ${typeColor}; cursor: pointer;" class="type-label" data-type="${type}">${type}:</strong>
              <span class="summary-value ${stats.total >= 0 ? 'positive' : 'negative'}">
                ${formatNumber(stats.total)}
              </span>
              <br>
              <small>(${stats.count}건, 평균 ${formatNumber(stats.avg)})</small>
            </div>
          `;
        }).join('');
        // 이벤트 바인딩
        document.querySelectorAll('.type-label').forEach(label => {
          label.addEventListener('click', function(e) {
            e.stopPropagation();
            const type = this.getAttribute('data-type');
            if (!svg) return; // svg가 아직 없으면 실행 안함

            svg.selectAll('.node')
              .style('opacity', 0.15)
              .select('circle')
              .attr('stroke', '#e0e0e0')
              .attr('stroke-width', 1)
              .transition()
              .duration(300)
              .attr('r', d => d.r * 0.9);
            svg.selectAll('.node')
              .select('text')
              .style('opacity', 0.15);
            const selectedNode = svg.selectAll('.node')
              .filter(d => d.data.type === type);
            selectedNode
              .style('opacity', 1)
              .raise()
              .select('circle')
              .attr('stroke', '#000000')
              .attr('stroke-width', 4)
              .style('filter', 'drop-shadow(0 0 10px rgba(0,0,0,0.3))')
              .transition()
              .duration(500)
              .ease(d3.easeCubicOut)
              .attr('r', d => d.r * 1.4);
            selectedNode
              .select('text')
              .style('opacity', 1)
              .style('font-weight', 'bold')
              .style('filter', 'drop-shadow(0 0 2px rgba(255,255,255,0.8))');
            
            const packDataForMonths = d3.rollups(allData, v => ({ months: [...new Set(v.map(d => d.month))] }), d => d.type)
                                        .map(([type, stats]) => ({ type, ...stats }));
            const selectedMonthsSet = new Set();
            const bubble = packDataForMonths.find(b => b.type === type);

            if (bubble) {
              bubble.months.forEach(month => selectedMonthsSet.add(month));
            }
            selectedMonths = selectedMonthsSet;
            selectedTypes = new Set([type]);
            updateMonthFilter();
            updateTable();
            const resetBubbles = function(event) {
              if (!event.target.closest('.type-label') && !event.target.closest('svg')) {
                svg.selectAll('.node')
                  .style('opacity', 0.5)
                  .select('circle')
                  .attr('stroke', '#cccccc')
                  .attr('stroke-width', 2)
                  .style('filter', 'none')
                  .transition()
                  .duration(300)
                  .attr('r', d => d.r);
                svg.selectAll('.node')
                  .select('text')
                  .style('opacity', 0.5)
                  .style('font-weight', 'normal')
                  .style('filter', 'none');
                selectedTypes.clear();
                selectedMonths.clear();
                updateMonthFilter();
                updateTable();
                document.removeEventListener('click', resetBubbles);
              }
            };
            document.addEventListener('click', resetBubbles, { once: true });
          });
        });
      }

      // 총 절감 분석 카드
      const totalSaving = d3.sum(allData, d => d.saving);
      const totalCount = allData.length;
      const avgSaving = totalCount > 0 ? totalSaving / totalCount : 0;
      const maxSaving = d3.max(allData, d => Math.abs(d.saving)) || 0; // 0으로 초기화
      const maxSavingItems = allData.filter(d => Math.abs(d.saving) === maxSaving);

      totalSummary.innerHTML = `
        <div class="summary-item">
          <strong>총 절감액:</strong>
          <span class="summary-value ${totalSaving >= 0 ? 'positive' : 'negative'}">
            ${formatNumber(totalSaving)}
          </span>
          <small>(${totalCount}건, 평균 ${formatNumber(avgSaving)})</small>
        </div>
        <div class="summary-item">
          <strong>최대 절감 항목:</strong>
          ${maxSavingItems.map(item => {
            const typeColor = colorScale ? colorScale(item.type) : '#1976d2';
            return `
              <span class="summary-value ${item.saving >= 0 ? 'positive' : 'negative'}">
                ${formatNumber(item.saving)}
              </span>
              <span style="color: ${typeColor}; cursor: pointer;" class="max-saving-type" data-type="${item.type}">${item.detail}</span>
              <small>${formatMonth(item.month)}</small>
            `;
          }).join('') || '<span class="summary-value">데이터 없음</span>'}
        </div>
      `;
      // 최대 절감 항목 클릭 이벤트 바인딩
      document.querySelectorAll('.max-saving-type').forEach(label => {
        label.addEventListener('click', function(e) {
          e.stopPropagation();
          const type = this.getAttribute('data-type');
          if (!svg) return; // svg가 아직 없으면 실행 안함

          svg.selectAll('.node')
            .style('opacity', 0.15)
            .select('circle')
            .attr('stroke', '#e0e0e0')
            .attr('stroke-width', 1)
            .transition()
            .duration(300)
            .attr('r', d => d.r * 0.9);
          svg.selectAll('.node')
            .select('text')
            .style('opacity', 0.15);
          const selectedNode = svg.selectAll('.node')
            .filter(d => d.data.type === type);
          selectedNode
            .style('opacity', 1)
            .raise()
            .select('circle')
            .attr('stroke', '#000000')
            .attr('stroke-width', 4)
            .style('filter', 'drop-shadow(0 0 10px rgba(0,0,0,0.3))')
            .transition()
            .duration(500)
            .ease(d3.easeCubicOut)
            .attr('r', d => d.r * 1.4);
          selectedNode
            .select('text')
            .style('opacity', 1)
            .style('font-weight', 'bold')
            .style('filter', 'drop-shadow(0 0 2px rgba(255,255,255,0.8))');
          
          const packDataForMonths = d3.rollups(allData, v => ({ months: [...new Set(v.map(d => d.month))] }), d => d.type)
                                        .map(([type, stats]) => ({ type, ...stats }));
          const selectedMonthsSet = new Set();
          const bubble = packDataForMonths.find(b => b.type === type);

          if (bubble) {
            bubble.months.forEach(month => selectedMonthsSet.add(month));
          }
          selectedMonths = selectedMonthsSet;
          selectedTypes = new Set([type]);
          updateMonthFilter();
          updateTable();
          const resetBubbles = function(event) {
            if (!event.target.closest('.max-saving-type') && !event.target.closest('svg')) {
              svg.selectAll('.node')
                .style('opacity', 0.5)
                .select('circle')
                .attr('stroke', '#cccccc')
                .attr('stroke-width', 2)
                .style('filter', 'none')
                .transition()
                .duration(300)
                .attr('r', d => d.r);
              svg.selectAll('.node')
                .select('text')
                .style('opacity', 0.5)
                .style('font-weight', 'normal')
                .style('filter', 'none');
              selectedTypes.clear();
              selectedMonths.clear();
              updateMonthFilter();
              updateTable();
              document.removeEventListener('click', resetBubbles);
            }
          };
          document.addEventListener('click', resetBubbles, { once: true });
        });
      });

      document.querySelectorAll('.summary-month-label').forEach(label => {
        label.addEventListener('click', function(e) {
          e.stopPropagation();
          const month = this.getAttribute('data-month');
          // 해당 월만 선택
          selectedMonths = new Set([month]);
          // 해당 월에 포함된 유형만 선택
          const typesInMonth = new Set(allData.filter(d => d.month === month).map(d => d.type));
          selectedTypes = typesInMonth;
          // 전체 선택 체크박스 상태 동기화
          document.getElementById('select-all').checked = (allData.length > 0 && selectedTypes.size === new Set(allData.map(d => d.type)).size);
          updateMonthFilter();
          updateTable();
          updateBubbleOpacity();
          // 해당 월에 포함된 버블만 강조
          if (svg) {
            svg.selectAll('.node')
              .classed('selected', d => typesInMonth.has(d.data.type))
              .select('circle')
              .transition()
              .duration(300)
              .attr('stroke', d => typesInMonth.has(d.data.type) ? '#000000' : '#cccccc')
              .attr('stroke-width', d => typesInMonth.has(d.data.type) ? 4 : 2)
              .style('opacity', d => typesInMonth.has(d.data.type) ? 1 : 0.15)
              .attr('r', d => typesInMonth.has(d.data.type) ? d.r * 1.1 : d.r);
            svg.selectAll('.node text')
              .style('opacity', d => typesInMonth.has(d.data.type) ? 1 : 0.15)
              .style('font-weight', d => typesInMonth.has(d.data.type) ? 'bold' : 'normal');
          }
          // 표로 전환
          document.querySelector('.analysis-summary').classList.remove('show');
          document.querySelector('table').style.display = 'table';
        });
      });
    }

    function formatNumber(num) {
      if (num === 0) return '0';
      if (isNaN(num)) return '0'; // NaN 값 처리
      const absNum = Math.abs(num);
      const suffixes = ['원', '천원', '백만원', '십억원', '조원'];
      // Math.log10(0)은 -Infinity이므로, absNum이 0보다 클 때만 계산
      const suffixNum = absNum > 0 ? Math.floor(Math.log10(absNum) / 3) : 0;
      // suffixNum이 suffixes 배열 범위를 벗어나지 않도록 조정
      const actualSuffixNum = Math.min(suffixNum, suffixes.length - 1);
      const shortNum = absNum / Math.pow(1000, actualSuffixNum);
      const roundedNum = Math.round(shortNum * 100) / 100;
      return `${num < 0 ? '-' : ''}${roundedNum}<small>${suffixes[actualSuffixNum]}</small>`;
    }

    // 전체 선택 체크박스 이벤트 리스너
    document.getElementById('select-all').addEventListener('change', function(e) {
      const allTypes = new Set(allData.map(d => d.type));
      if (e.target.checked) {
        // 전체 선택
        selectedTypes = new Set(allTypes);
        // 모든 월도 선택
        selectedMonths = new Set(allData.map(d => d.month));
        
        // 모든 버블 강조 효과
        if(svg) {
            svg.selectAll('.node')
            .classed('selected', true)
            .select('circle')
            .transition()
            .duration(300)
            .attr('stroke', '#000000')
            .attr('stroke-width', 4)
            .style('opacity', 1)
            .attr('r', d => d.r * 1.1);
            
            svg.selectAll('.node text')
            .style('opacity', 1)
            .style('font-weight', 'bold');
        }
      } else {
        // 전체 해제
        selectedTypes.clear();
        selectedMonths.clear();
        
        // 모든 버블 효과 제거
        if(svg) {
            svg.selectAll('.node')
            .classed('selected', false)
            .select('circle')
            .transition()
            .duration(300)
            .attr('stroke', '#cccccc')
            .attr('stroke-width', 2)
            .style('opacity', 0.5)
            .attr('r', d => d.r);
            
            svg.selectAll('.node text')
            .style('opacity', 0.5)
            .style('font-weight', 'normal');
        }
      }

      updateMonthFilter();
      updateTable();
      updateBubbleOpacity();
    });

    // 문서 전체에 클릭 이벤트 리스너 추가
    document.addEventListener('click', function(event) {
      // SVG 요소나 테이블 내부를 클릭한 경우는 무시
      if (event.target.closest('svg') || event.target.closest('#table-container')) {
        return;
      }
      
      // 컨트롤 영역(체크박스 등)을 클릭한 경우는 무시
      if (event.target.closest('#controls') || 
          event.target.closest('#select-all-container') || 
          event.target.closest('#month-filter-container')) {
        return;
      }
      
      // 버블 외 영역 클릭 시 선택 해제
      selectedTypes.clear();
      selectedMonths.clear();
      
      // 모든 버블 선택 해제
      if(svg) {
        svg.selectAll('.node')
          .classed('selected', false)
          .select('circle')
          .transition()
          .duration(300)
          .attr('r', d => d.r)
          .attr('stroke', '#cccccc')
          .attr('stroke-width', 2)
          .style('opacity', 0.5);
        
        svg.selectAll('.node text')
          .style('opacity', 0.5)
          .style('font-weight', 'normal');
      }
        
      // 전체 선택 체크박스 상태 업데이트
      document.getElementById('select-all').checked = false;
      
      updateMonthFilter();
      updateTable();
      updateBubbleOpacity();
    });

    // 다운로드 기능 구현
    async function downloadCSV() {
      if (!allData || allData.length === 0) {
        alert('다운로드할 데이터가 없습니다.');
        return;
      }
      
      try {
        // CSV 헤더 생성
        const headers = ['월', '작업유형', '절감항목', 'A.집행비', 'B.공사비 적용시', '절감비(A-B)', '비고'];
        
        // CSV 데이터 생성 (비고 HTML 태그 제거)
        const csvRows = [
          headers.join(','),
          ...allData.map(row => [
            row.month,
            row.type,
            row.detail.replace(/<[^>]*>?/gm, ''), // HTML 태그 제거
            row.actual,
            row.estimated,
            row.saving,
            row.note.replace(/<[^>]*>?/gm, '') // HTML 태그 제거
          ].map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')) // 각 필드를 큰따옴표로 감싸고 내부 큰따옴표 이스케이프
        ];
        
        // BOM이 포함된 UTF-8 CSV 데이터 생성
        const csvContent = '\uFEFF' + csvRows.join('\n');
        
        // 현재 날짜를 YY-MM-DD 형식으로 변환
        const today = new Date();
        const year = today.getFullYear().toString().slice(-2);
        const month = String(today.getMonth() + 1).padStart(2, '0');
        const day = String(today.getDate()).padStart(2, '0');
        const dateStr = `${year}-${month}-${day}`;
        
        // File System Access API 사용 시도
        if ('showSaveFilePicker' in window) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: `25년 상반기 유형별 절감 목록_(기숙사 및 사택)_${dateStr}.csv`,
              types: [{
                description: 'CSV 파일',
                accept: { 'text/csv': ['.csv'] }
              }]
            });
            
            const writable = await handle.createWritable();
            await writable.write(csvContent);
            await writable.close();
            return;
          } catch (err) {
            if (err.name !== 'AbortError') {
              console.error('File System Access API 실패:', err);
            }
          }
        }
        
        // 폴백: Blob 방식으로 다운로드
        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `25년 상반기 유형별 절감 목록_(기숙사 및 사택)_${dateStr}.csv`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
      } catch (error) {
        console.error('다운로드 중 오류 발생:', error);
        alert('파일 다운로드 중 오류가 발생했습니다.');
      }
    }
    
    // 다운로드 버튼 이벤트 리스너 추가
    document.getElementById('download-csv-btn').addEventListener('click', downloadCSV);
    
    // HTML 다운로드 기능 구현
    async function downloadHTML() {
      // 데이터 유무 확인 및 사용자에게 빈 템플릿 다운로드 여부 질문
      if (!allData || allData.length === 0) {
        const confirmation = confirm('다운로드할 데이터가 없습니다. 현재 하이퍼링크 설정만 포함된 빈 템플릿 형태의 HTML을 다운로드하시겠습니까?');
        if (!confirmation) {
          return; // 사용자가 취소하면 함수 종료
        }
        // 사용자가 '예'를 선택하면 allData는 빈 배열로, hyperlinkRules는 현재 값으로 진행
      }
      
      try {
        // 현재 HTML 문서의 전체 내용을 가져옴
        let htmlContent = document.documentElement.outerHTML;
        
        // 1. allData를 JSON 문자열로 변환하여 삽입
        //    allData가 null/undefined일 경우 빈 배열로 처리
        const dataString = JSON.stringify(allData || []); 
        //    스크립트 내 'let allData = [];' 부분을 찾아 실제 데이터로 교체
        htmlContent = htmlContent.replace(
          /(let allData\s*=\s*)\[\]\s*;/, // 정규식: 'let allData' 뒤에 '='와 선택적 공백, '[]'와 선택적 공백, ';'
          `$1${dataString};`
        );
        
        // 2. hyperlinkRules를 JSON 문자열로 변환하여 삽입
        //    hyperlinkRules가 null/undefined일 경우 빈 배열로 처리
        const hyperlinkRulesString = JSON.stringify(hyperlinkRules || []); 
        //    스크립트 내 'let hyperlinkRules = [];' 부분을 찾아 실제 규칙으로 교체
        htmlContent = htmlContent.replace(
          /(let hyperlinkRules\s*=\s*)\[\]\s*;/, // 정규식: 'let hyperlinkRules' 뒤에 '='와 선택적 공백, '[]'와 선택적 공백, ';'
          `$1${hyperlinkRulesString};`
        );
        
        // 현재 날짜를 YY-MM-DD 형식으로 파일명에 사용하기 위해 변환
        const today = new Date();
        const year = today.getFullYear().toString().slice(-2); // 년도 마지막 두 자리
        const month = String(today.getMonth() + 1).padStart(2, '0'); // 월 (01-12)
        const day = String(today.getDate()).padStart(2, '0'); // 일 (01-31)
        const dateStr = `${year}-${month}-${day}`; // 최종 날짜 문자열 (YY-MM-DD)
        
        // File System Access API를 사용하여 파일 저장 시도 (지원되는 경우)
        if ('showSaveFilePicker' in window) {
          try {
            const handle = await window.showSaveFilePicker({
              suggestedName: `25년 상반기 유형별 절감 목록_(기숙사 및 사택)_${dateStr}.html`,
              types: [{
                description: 'HTML 파일',
                accept: { 'text/html': ['.html'] }
              }]
            });
            
            const writable = await handle.createWritable();
            await writable.write(htmlContent); // 수정된 HTML 내용을 파일에 씀
            await writable.close(); // 쓰기 스트림 닫기
            return; // 성공적으로 저장 후 함수 종료
          } catch (err) {
            // 사용자가 파일 저장을 취소한 경우(AbortError)는 오류로 처리하지 않음
            if (err.name !== 'AbortError') {
              console.error('File System Access API 실패:', err);
            }
            // API 사용 실패 또는 취소 시 아래의 폴백 방식으로 진행
          }
        }
        
        // 폴백: Blob을 사용한 전통적인 방식의 파일 다운로드
        const blob = new Blob([htmlContent], { type: 'text/html;charset=utf-8' });
        const url = URL.createObjectURL(blob); // Blob URL 생성
        const link = document.createElement('a'); // 임시 다운로드 링크 요소 생성
        link.href = url;
        link.download = `25년 상반기 유형별 절감 목록_(기숙사 및 사택)_${dateStr}.html`; // 다운로드될 파일명 설정
        document.body.appendChild(link); // 링크를 문서에 추가
        link.click(); // 프로그래매틱하게 클릭하여 다운로드 트리거
        document.body.removeChild(link); // 사용된 링크 요소 제거
        URL.revokeObjectURL(url); // 생성된 Blob URL 해제
      } catch (error) {
        console.error('HTML 다운로드 중 오류 발생:', error);
        alert('HTML 파일 다운로드 중 오류가 발생했습니다.');
      }
    }
    
    // 현재 페이지에서도 자동 렌더링 적용
    window.addEventListener('load', function() {
      // allData 와 hyperlinkRules 는 HTML 다운로드 시 파일에 직접 저장되어 로드됨.
      if (allData && allData.length > 0) {
        initChart();
        drawChart();
        updateTable(); // 이 안에서 applyHyperlinkRules()가 호출됨 (저장된 hyperlinkRules 사용)
        updateMonthFilter();
        updateAnalysisSummary();
      } else {
        // 데이터가 없거나 (다운로드된 HTML에서) 빈 데이터로 로드된 경우
        updateMonthFilter(); // 월 필터는 초기화 (빈 데이터 기준)
        updateTable();       // 테이블은 비어있거나 총계만 표시, applyHyperlinkRules는 호출되나 적용할 셀이 적음
        updateAnalysisSummary(); // "데이터 없음" 메시지 표시
      }
    });

    // HTML 다운로드 버튼 이벤트 리스너 추가
    document.getElementById('download-html-btn').addEventListener('click', downloadHTML);

    // 메뉴와 제목 겹침 감지 및 조정
    function checkMenuOverlap() {
      const controls = document.getElementById('controls');
      const title = document.querySelector('h1');
      if (!controls || !title) return; // 요소가 없으면 중단
      const controlsRect = controls.getBoundingClientRect();
      const titleRect = title.getBoundingClientRect();

      if (controlsRect.bottom > titleRect.bottom) {
        controls.classList.add('compact');
      } else {
        controls.classList.remove('compact');
      }
    }

    // 페이지 로드 및 리사이즈 시 겹침 체크
    window.addEventListener('load', checkMenuOverlap);
    window.addEventListener('resize', checkMenuOverlap);

    // 하이퍼링크 CSV 파일 업로드 처리
    function handleHyperlinkUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const data = d3.csvParse(e.target.result);
          hyperlinkRules = data.map(rule => ({
            column: rule['대상열'] ? rule['대상열'].trim() : '',
            searchText: rule['검색텍스트'] ? rule['검색텍스트'].trim() : '',
            linkUrl: rule['링크URL'] ? rule['링크URL'].trim() : '',
            linkType: rule['링크유형'] ? rule['링크유형'].trim() : 'note', // 기본값 설정
            description: rule['설명'] ? rule['설명'].trim() : ''
          })).filter(rule => rule.column && rule.searchText && rule.linkUrl); // 필수 필드 확인
          
          // 하이퍼링크 규칙 적용
          if(allData && allData.length > 0) { // 데이터가 있을 때만 테이블 업데이트
             updateTable(); // 테이블을 다시 그려서 하이퍼링크 규칙 적용
          }
          alert('하이퍼링크 설정이 적용되었습니다.');
        } catch (error) {
          console.error('하이퍼링크 CSV 파싱 오류:', error);
          alert('하이퍼링크 CSV 파일 형식이 올바르지 않습니다. 템플릿을 다운로드하여 사용해주세요.');
        }
      };
      reader.readAsText(file);
    }

    // 하이퍼링크 규칙 적용
    function applyHyperlinkRules() {
      const tbody = document.querySelector('tbody');
      if (!tbody || !hyperlinkRules || hyperlinkRules.length === 0) return;

      // 모든 데이터 행의 셀에 대해 하이퍼링크 규칙 적용
      tbody.querySelectorAll('tr:not(.sticky-total-row):not(.subtotal) td').forEach(cell => {
        const columnIndex = Array.from(cell.parentNode.children).indexOf(cell);
        const headerCell = document.querySelector('thead th:nth-child(' + (columnIndex + 1) + ')');
        if (!headerCell) return;
        
        const columnName = headerCell.textContent.trim(); // 헤더 텍스트 가져오기
        
        // 해당 열에 대한 하이퍼링크 규칙 찾기
        const rulesForColumn = hyperlinkRules.filter(rule => rule.column === columnName);
        
        if (rulesForColumn.length > 0) {
          let currentContent = cell.innerHTML; // 기존 HTML 내용을 유지하며 링크 추가
          let textContentForSearch = cell.textContent; // 검색은 텍스트 기준으로

          rulesForColumn.forEach(rule => {
            // 정규식을 사용하여 검색 텍스트를 찾고, 이미 링크가 적용되지 않은 경우에만 링크 추가
            // 링크 내부의 텍스트는 제외하고 검색
            const regex = new RegExp(rule.searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g');
            let match;
            let newContent = "";
            let lastIndex = 0;

            // 임시 div를 만들어 HTML 파싱 후 텍스트만 추출하여 검색
            const tempDiv = document.createElement('div');
            tempDiv.innerHTML = currentContent;
            const plainText = tempDiv.textContent || "";


            if (plainText.includes(rule.searchText)) {
                 // 이미 적용된 링크인지 확인 (단순 문자열 비교)
                const linkHtml = `<a href="${rule.linkUrl}" target="_blank" class="hyperlink-${rule.linkType || 'note'}" title="${rule.description || rule.searchText}">${rule.searchText}</a>`;
                if (!currentContent.includes(linkHtml)) { // 완전 동일한 링크가 아닐 때만
                    // 텍스트를 기반으로 교체하되, HTML 구조를 최대한 보존하려고 시도
                    // 주의: 이 방식은 복잡한 HTML 구조에서는 완벽하지 않을 수 있음
                    // searchText가 HTML 태그의 일부와 겹치면 문제가 발생할 수 있음
                    // 가장 안전한 방법은 innerText를 기준으로 교체 후 innerHTML로 설정하는 것.
                    // 그러나 이는 기존의 다른 HTML(예: min-labor-cost-link)을 제거할 수 있음.
                    // 여기서는 단순 replace를 사용하되, 중복 적용을 피하는 데 초점.
                    
                    // searchText를 포함하고 있으면서, 그 searchText가 이미 다른 a 태그 내부에 있지 않은 경우에만 교체
                    // 이 부분은 복잡해서, 간단하게는 searchText가 그냥 있으면 교체하는 방식을 유지.
                    // 정교한 DOM 조작은 성능 저하 및 복잡성 증가를 야기.

                    // 현재 셀의 텍스트 내용에서 rule.searchText를 찾아 링크로 교체
                    // cell.innerHTML을 직접 수정하면 이벤트 리스너 등이 날아갈 수 있으므로 주의.
                    // updateTable에서 셀을 새로 생성하므로 이 문제는 없음.

                    // 기존 innerHTML에서 rule.searchText를 찾아 교체
                    // 이미 생성된 HTML 링크(예: min-labor-cost-link) 내의 텍스트와 겹치지 않도록 주의 필요.
                    // 가장 간단한 방법: rule.searchText가 평문으로 존재할 때만 교체
                    if (cell.textContent.includes(rule.searchText)) {
                         currentContent = currentContent.replace(
                            new RegExp(rule.searchText.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'g'), // 전역으로 찾아 바꾸기
                            linkHtml
                        );
                    }
                }
            }
          });
          if (cell.innerHTML !== currentContent) {
            cell.innerHTML = currentContent;
          }
        }
      });
    }

    // 하이퍼링크 다운로드
    function downloadHyperlinkRules() {
      try {
        // 데이터가 로드되었는지 확인 (선택 사항, 규칙만 다운로드 가능)
        // if (!allData || allData.length === 0) {
        //   alert('데이터가 로드되지 않았습니다. CSV 파일을 먼저 업로드해주세요.');
        //   return;
        // }

        // 하이퍼링크 규칙 배열
        let rulesToDownload = [];

        // 업로드된 하이퍼링크 규칙이 있으면 추가
        if (hyperlinkRules && hyperlinkRules.length > 0) {
          rulesToDownload = [...hyperlinkRules];
        }

        // 기본 하이퍼링크 매핑 추가 (중복 방지하며)
        const defaultDetailLinks = {
          '사택 102-401 세대내 고장 보일러 교체': 'https://photos.app.goo.gl/ZSpjCao7BtfsuDmU8',
          '사택 9-501 누수탐지 및 바닥 매립배관 보수': 'https://photos.app.goo.gl/VysKu4vh8CJci2s38',
          // ... (나머지 기본 링크들)
        };
        const defaultMinLaborCostLinks = {
          '기계 최소인건비': 'https://photos.app.goo.gl/od8H1Cn9ZXcyttq6A',
          // ...
        };
        const defaultNoteLinks = {
          '비용 추정(보수적)': 'https://photos.app.goo.gl/RmJhxWhF3xZW7zAu8',
        };

        const addRuleIfNotExists = (rule, targetArray) => {
          const exists = targetArray.some(r => 
            r.column === rule.column && 
            r.searchText === rule.searchText // URL까지 비교하면 수정된 URL을 저장하기 어려움
          );
          if (!exists) {
            targetArray.push(rule);
          } else { // 이미 존재하면, URL 등 다른 정보 업데이트 (선택적)
            const existingRule = targetArray.find(r => r.column === rule.column && r.searchText === rule.searchText);
            if (existingRule && existingRule.linkUrl !== rule.linkUrl) {
                // 기존 규칙을 새 규칙으로 교체하거나, 사용자에게 선택권을 줄 수 있음
                // 여기서는 간단히 새 규칙으로 덮어쓰도록 함 (또는 추가하지 않음)
                // 만약 searchText가 같고 URL이 다르면, 기존 것을 유지할지 새것으로 할지 결정해야함.
                // 여기서는 중복 searchText는 추가하지 않는 것으로 처리.
            }
          }
        };

        Object.entries(defaultDetailLinks).forEach(([text, url]) => {
          addRuleIfNotExists({ column: '절감항목', searchText: text, linkUrl: url, linkType: 'detail', description: '절감항목 상세' }, rulesToDownload);
        });
        Object.entries(defaultMinLaborCostLinks).forEach(([text, url]) => {
          addRuleIfNotExists({ column: '비고', searchText: text, linkUrl: url, linkType: 'note', description: '최소인건비 정보' }, rulesToDownload);
        });
        Object.entries(defaultNoteLinks).forEach(([text, url]) => {
          addRuleIfNotExists({ column: '비고', searchText: text, linkUrl: url, linkType: 'note', description: '비고 상세' }, rulesToDownload);
        });


        if (rulesToDownload.length === 0) {
          alert('저장된 하이퍼링크 규칙이 없습니다. 기본 규칙 또는 업로드된 규칙이 없습니다.');
          return;
        }

        // CSV 데이터 생성
        const csvData = [
          ['대상열', '검색텍스트', '링크URL', '링크유형', '설명'],
          ...rulesToDownload.map(rule => [
            `"${rule.column || ''}"`,
            `"${rule.searchText || ''}"`,
            `"${rule.linkUrl || ''}"`,
            `"${rule.linkType || 'note'}"`,
            `"${rule.description || ''}"`
          ].map(field => field.replace(/""/g, '"'))) // 큰따옴표 복원 (내부적으로만 사용했으므로)
        ];

        // BOM이 포함된 UTF-8 CSV 데이터 생성
        const csvContent = '\uFEFF' + csvData.map(row => row.join(',')).join('\n');
        
        const today = new Date();
        const dateStr = `${today.getFullYear().toString().slice(-2)}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

        const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        link.download = `[CSV 매핑전]25년 유형별 절감 현황_(기숙사 및 사택)_하이퍼링크_${dateStr}.csv`;
        
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        URL.revokeObjectURL(url);
        // 페이지 새로고침은 제거 (사용자 혼란 야기 가능)
      } catch (error) {
        console.error('하이퍼링크 규칙 다운로드 중 오류 발생:', error);
        alert('하이퍼링크 규칙 다운로드 중 오류가 발생했습니다. 페이지를 새로고침하고 다시 시도해주세요.');
      }
    }

    // 하이퍼링크 다운로드 버튼 이벤트 리스너
    document.getElementById('download-link-btn').addEventListener('click', function() {
      try {
        const dialog = document.createElement('div');
        dialog.className = 'hyperlink-download-dialog';
        dialog.style.cssText = `
          position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
          background: white; padding: 20px; border-radius: 8px;
          box-shadow: 0 2px 10px rgba(0,0,0,0.2); z-index: 2000; text-align: center;`;
        
        dialog.innerHTML = `
          <h3 style="margin-top: 0; color: #1a237e;">하이퍼링크 다운로드 선택</h3>
          <p style="margin-bottom: 20px;">다운로드할 항목을 선택해주세요.</p>
          <div style="display: flex; gap: 10px; justify-content: center;">
            <button id="download-template-btn" style="padding: 8px 16px; background: #1a237e; color: white; border: none; border-radius: 4px; cursor: pointer;">
              템플릿 다운로드
            </button>
            <button id="download-current-rules-btn" style="padding: 8px 16px; background: #1a237e; color: white; border: none; border-radius: 4px; cursor: pointer;">
              현재 규칙 다운로드
            </button>
          </div>
          <button id="cancel-download-dialog-btn" style="margin-top: 15px; padding: 6px 12px; background: #e0e0e0; border: none; border-radius: 4px; cursor: pointer;">
            취소
          </button>
        `;
        
        const overlay = document.createElement('div');
        overlay.style.cssText = `
          position: fixed; top: 0; left: 0; right: 0; bottom: 0;
          background: rgba(0,0,0,0.5); z-index: 1999;`;
        
        document.body.appendChild(overlay);
        document.body.appendChild(dialog);

        const closeDialog = () => {
          dialog.remove();
          overlay.remove();
        };

        dialog.querySelector('#download-template-btn').onclick = () => { downloadHyperlinkTemplate(); closeDialog(); };
        dialog.querySelector('#download-current-rules-btn').onclick = () => { downloadHyperlinkRules(); closeDialog(); };
        dialog.querySelector('#cancel-download-dialog-btn').onclick = closeDialog;
        overlay.addEventListener('click', closeDialog);

      } catch (error) {
        console.error('다이얼로그 생성 중 오류 발생:', error);
        alert('다이얼로그 생성 중 오류가 발생했습니다. 페이지를 새로고침하고 다시 시도해주세요.');
      }
    });

    // 하이퍼링크 템플릿 CSV 다운로드
    function downloadHyperlinkTemplate() {
      const templateData = [
        ['대상열', '검색텍스트', '링크URL', '링크유형', '설명'],
        ['월', '2025-01', 'https://example.com/2025-01', 'month', '1월 데이터'],
        ['작업유형', '건축', 'https://example.com/construction', 'type', '건축 작업'],
        ['절감항목', '특정 보일러 모델', 'https://example.com/boiler-model-xyz', 'detail', 'XYZ 보일러 상세 정보'],
        ['비고', '공사 표준 단가표', 'https://example.com/standard-costs', 'note', '관련 표준 단가 정보']
      ];

      const csvContent = '\uFEFF' + templateData.map(row => 
        row.map(field => `"${String(field).replace(/"/g, '""')}"`).join(',')
      ).join('\n');
      
      const today = new Date();
      const dateStr = `${today.getFullYear().toString().slice(-2)}-${String(today.getMonth() + 1).padStart(2, '0')}-${String(today.getDate()).padStart(2, '0')}`;

      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `하이퍼링크_규칙_템플릿_${dateStr}.csv`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
    }

    // 하이퍼링크 업로드 버튼 이벤트 리스너
    document.getElementById('upload-link-btn').addEventListener('click', function() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.csv';
      input.onchange = handleHyperlinkUpload;
      input.click();
    });
  </script>
</body>
</html>