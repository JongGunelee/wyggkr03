<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>주간 업무 회의 안건 (기숙사 및 사택) - 기능 병합</title>
  <meta name="template-type" content="weekly-meeting-merged" />
  <meta name="editable-title" content="YY년 MM월 W주차 주간 업무 회의" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
  
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/flatpickr/dist/flatpickr.min.css">
  <script src="https://cdn.jsdelivr.net/npm/flatpickr"></script>
  <script src="https://npmcdn.com/flatpickr/dist/l10n/ko.js"></script>
  
  <style>
    body {
      font-family: '맑은 고딕', sans-serif;
      background-color: #fcfcfc;
      margin: 0;
      padding: 0;
      color: #2b2b2b;
      line-height: 1.6;
      transition: margin-top 0.3s ease-in-out;
      overflow-x: hidden;
    }

    body.meeting-cursor {
      cursor: cell;
    }

    #appContainer {
        background-color: #fcfcfc;
        position: relative;
    }

    h1#page-title {
      font-size: 1.8em;
      color: #2a4d69;
      margin: 0;
      border-bottom: 2px solid #ccc;
      padding: 15px 40px;
      background: #fff;
      z-index: 999;
      box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      box-sizing: border-box;
    }
    body:not(.true-fullscreen-active) h1#page-title {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
    }
    body.true-fullscreen-active #appContainer > h1#page-title {
        position: sticky;
        top: 0;
        z-index: 10;
    }

    #weeklyNavigatorContainer {
        display: flex;
        flex-direction: row; 
        align-items: center;
        justify-content: center;
        flex-wrap: wrap; 
        padding: 8px 10px;
        background-color: #f0f4f8;
        border-bottom: 1px solid #dce4eb;
        position: fixed;
        width: 100%;
        z-index: 998;
        box-sizing: border-box;
        top: 67px;
        transition: top 0.3s ease-in-out, opacity 0.5s ease-in-out;
        gap: 5px;
    }

    .navigator-controls {
        display: flex;
        align-items: center;
        margin-bottom: 0;
        gap: 5px;
    }

    .navigator-controls button {
        background: none;
        border: 1px solid #a0b4c8;
        color: #334e68;
        padding: 2px 8px;
        font-size: 1.0em;
        border-radius: 4px;
        cursor: pointer;
        transition: background-color 0.2s;
    }
    .navigator-controls button:hover {
        background-color: #dce4eb;
    }
    .navigator-controls .current-display-span {
        margin: 0 5px;
        font-size: 1.0em;
        font-weight: 600;
        color: #2a4d69;
        min-width: 60px;
        text-align: center;
    }

    #weekLinksContainer {
        display: flex;
        flex-wrap: wrap;
        justify-content: center;
        align-items: center;
        gap: 4px;
        margin: 0 10px;
    }

    .week-link {
        display: inline-block;
        padding: 6px 12px;
        margin: 2px;
        border-radius: 4px;
        font-size: 0.9em;
        font-weight: 500;
        text-decoration: none;
        color: #fff;
        transition: background-color 0.2s ease, transform 0.2s ease;
    }
    .week-link.active {
        background-color: rgb(195, 206, 212);
        cursor: pointer;
    }
    .week-link.active:hover {
        background-color: rgb(175, 186, 192);
        transform: translateY(-2px);
    }
    .week-link.disabled {
        background-color: rgb(75, 146, 223);
        color: #f5f5f5;
        cursor: not-allowed;
        opacity: 0.7;
    }
    .week-link.actual-current {
        background-color: #00897b; 
        box-shadow: 0 0 5px rgba(0, 137, 123, 0.8);
    }
    .week-link.current {
        background-color: rgb(215, 65, 31);
        font-weight: bold;
        font-size: 1em;
        box-shadow: none;
        cursor: default;
    }
    .week-link.current:hover {
        transform: none;
        background-color: rgb(215, 65, 31);
    }


    .container {
      padding: 20px 20px 40px;
      display: flex;
      flex-direction: row;
      gap: 20px;
      box-sizing: border-box;
      align-items: flex-start;
      width: 100%;
      max-width: none;
      margin: 0 auto;
      background: #fff;
      min-height: calc(100vh - 160px);
      position: relative;
    }

    body.true-fullscreen-active #appContainer > .container {
        padding-top: 0;
        min-height: calc(100vh - 70px);
    }
     body.true-fullscreen-active #appContainer > .container > .column:first-of-type > .column-title:first-of-type,
     body.true-fullscreen-active #appContainer > .container > .section-block:first-of-type > .section-header:first-of-type {
        margin-top: 0;
    }

    .column {
      flex: 1; background-color: #fff;
      border: 1px solid #ccc;
      border-radius: 6px; padding: 20px;
      display: flex; flex-direction: column;
      box-shadow: 0 0 8px rgba(0,0,0,0.03);
      min-width: 0;
      position: relative;
    }
    .column-title {
      font-weight: bold; font-size: 1.1em;
      color: #00695c; margin-bottom: 16px;
      position: relative;
    }
    .section-block {
        margin-bottom: 30px;
        position: relative;
    }
    .section-header {
      font-weight: bold; background-color: #eee;
      padding: 8px; border-left: 4px solid #333;
      margin-bottom: 10px;
      position: relative;
    }
    .pr-section { color: #0066cc; font-weight: bold; }
    .item.gray span { color: #999; }
    .divider {
      border-top: 3px double #999;
      margin: 12px 0;
      position: relative;
    }

    .item-controls {
        position: absolute;
        top: -10px;
        right: -10px;
        display: none;
        background-color: rgba(220, 220, 220, 0.95);
        border-radius: 5px;
        padding: 3px 5px;
        z-index: 100;
        box-shadow: 0 1px 3px rgba(0,0,0,0.2);
        gap: 4px;
    }

    body.show-icons-all [data-editable-type]:hover > .item-controls {
        display: flex;
    }
    body.show-icons-selected [data-editable-type].controls-active > .item-controls {
        display: flex;
    }

    .item-control-btn {
        background: #fff; border: 1px solid #aaa; color: #333; cursor: pointer;
        font-size: 14px;
        padding: 2px 5px;
        border-radius: 4px;
        line-height: 1;
    }
    .item-control-btn:hover { background-color: #e8e8e8; border-color: #888; }


    .add-sub-insert-area-btn {
        margin-left: 20px;
        margin-top: 8px;
        font-size: 0.9em;
        padding: 4px 8px;
        background-color: #e0e0e0;
        border: 1px solid #ccc;
        border-radius: 4px;
        cursor: pointer;
        position: relative;
    }
     .add-sub-insert-area-btn:hover {
        background-color: #d0d0d0;
     }
     .add-sub-insert-area-btn > span[data-editable-type="button-text-label"] {
        display: inline-block;
        min-width: 20px;
        position: relative;
     }

    .item { font-size: 0.96em; margin-bottom: 8px; padding: 2px; }
    .highlight { font-weight: bold; color: #d84315; }

    .insert-area {
      border: 1px dashed #bbb; background-color: #fff; padding: 8px;
      min-height: 50px; margin: 6px 0 12px 20px; position: relative;
    }
    .section-block > .insert-area {
        margin-left: 20px;
    }

    .floating-menu-icon, .fullscreen-btn-class, #multiZoomTriggerBtn,
    #annotationDisplayToggleBtn, #annotationSettingsToggleBtn, #memoAnnotationToggleBtn, .exit-true-fullscreen-btn {
      position: fixed;
      right: 16px;
      background-color: rgba(150,150,150,0.3);
      color: #555;
      border: 1px solid rgba(0,0,0,0.1);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
      transition: background-color 0.2s ease, opacity 0.3s, visibility 0.3s;
      font-family: 'Segoe UI Emoji', 'Apple Color Emoji', 'Segoe UI Symbol', 'Noto Color Emoji', sans-serif;
      line-height: 1;
      z-index: 10002;
    }

    .floating-menu-icon { bottom: 16px; font-size: 20px; padding: 8px 10px; }
    .fullscreen-btn-class { bottom: 62px; font-size: 20px; padding: 8px 10px; }
    #multiZoomTriggerBtn { bottom: 108px; font-size: 22px; background-color: rgba(0, 123, 255, 0.8); color: white; padding: 10px; }

    #annotationDisplayToggleBtn { bottom: 154px; font-size: 20px; padding: 8px 10px; z-index: 10002;}
    #annotationSettingsToggleBtn { bottom: 200px; font-size: 20px; padding: 8px 10px; z-index: 10002;}
    #memoAnnotationToggleBtn { bottom: 246px; font-size: 20px; padding: 8px 10px; z-index: 10002;}

    .floating-menu-icon:hover, .fullscreen-btn-class:hover, #multiZoomTriggerBtn:hover,
    #annotationDisplayToggleBtn:hover, #annotationSettingsToggleBtn:hover, #memoAnnotationToggleBtn:hover, .exit-true-fullscreen-btn:hover {
        background-color: rgba(120,120,120,0.4);
    }

    #annotationDisplayToggleBtn.active, #annotationSettingsToggleBtn.active, #memoAnnotationToggleBtn.active,
    .fullscreen-btn-class.fs-active {
        background-color: rgba(128, 0, 128, 0.6);
        color: white;
        opacity: 1;
    }
    #annotationDisplayToggleBtn:not(.active),
    #annotationSettingsToggleBtn:not(.active),
    #memoAnnotationToggleBtn:not(.active) {
        opacity: 0.6;
    }
    .exit-true-fullscreen-btn {
      top: 10px; right: 16px; font-size: 28px; padding: 0px 10px;
      background-color: rgba(255,255,255,0.6);
      z-index: 10005;
      display: none;
    }
     body.true-fullscreen-active .exit-true-fullscreen-btn { display: block; }
    .exit-true-fullscreen-btn:hover { color: #000; background-color: rgba(230,230,230,0.8); }

    /* =================================================================== */
    /* 시간 및 날짜 표시 스타일 */
    /* =================================================================== */
    #time-display-container {
        position: fixed;
        top: 15px;
        right: 15px;
        z-index: 10003;
        background-color: rgba(43, 43, 43, 0.65);
        color: #f0f0f0;
        padding: 5px 12px;
        border-radius: 8px;
        font-size: 0.8em;
        font-family: 'Segoe UI', '맑은 고딕', sans-serif;
        display: flex;
        align-items: center;
        gap: 10px;
        user-select: none;
        transition: right 0.3s ease-in-out;
    }
    body.true-fullscreen-active #time-display-container {
        right: 60px; /* 전체 화면 종료 버튼과 겹치지 않도록 조정 */
    }
    #time-display-container .time-separator {
        border-left: 1px solid rgba(255, 255, 255, 0.4);
        height: 14px;
    }
    #time-display-container span {
      white-space: nowrap;
    }
    #current-date {
        cursor: pointer;
        text-decoration: underline;
        text-decoration-thickness: 1px;
        text-underline-offset: 3px;
    }
    #current-date:hover {
        color: #fff;
    }
    /* =================================================================== */

    #annotationSettingsPanel {
        position: fixed;
        right: 70px;
        bottom: 200px;
        background-color: rgba(245, 245, 245, 0.97);
        padding: 10px;
        padding-top: 30px;
        border-radius: 8px;
        box-shadow: -2px 0px 5px rgba(0,0,0,0.2);
        z-index: 10004;
        display: none;
        flex-direction: column;
        gap: 8px;
        width: 190px;
    }
    #closeAnnotationSettingsBtn {
        position: absolute;
        top: 5px;
        right: 8px;
        font-size: 24px;
        color: #777;
        background-color: transparent;
        border: none;
        cursor: pointer;
        padding: 2px 5px;
        line-height: 1;
    }
    #closeAnnotationSettingsBtn:hover {
        color: #333;
    }
    #annotationSettingsPanel button.tool-active {
        background-color: #007bff;
        color: white;
        border-color: #0056b3;
        box-shadow: inset 0 1px 3px rgba(0,0,0,0.2);
    }


    .floating-panel {
      position: fixed; bottom: 16px; right: 16px; width: 300px;
      background-color: #f5f5f5; border: 1px solid #ccc; border-radius: 8px;
      padding: 15px; padding-top: 35px; display: none; z-index: 10004;
      font-size: 14px; color: #333; box-shadow: 0 2px 8px rgba(0,0,0,0.15);
      max-height: calc(100vh - 80px); overflow: auto; cursor: grab;
      resize: both;
      min-width: 250px;
      min-height: 200px;
    }
    .floating-panel.dragging { cursor: grabbing; user-select: none; }
    /* --- [MODIFIED] 닫기 버튼 위치 변경 (우측 -> 좌측) --- */
    .floating-panel-close-btn {
        position: absolute; top: 8px; left: 10px; font-size: 20px;
        color: #777; cursor: pointer; padding: 2px 5px;
    }
    .floating-panel-close-btn:hover { color: #333; }
    .floating-panel hr { margin: 12px 0; border-top: 1px solid #ddd; border-bottom: none; }
    .floating-panel label { display: block; margin-bottom: 8px; font-weight: bold; color: #00695c; }
    .floating-panel input, .floating-panel button, .floating-panel select {
      width: 100%; margin-bottom: 10px; font-size: 13px; padding: 8px;
      box-sizing: border-box; border-radius: 4px; border: 1px solid #ddd;
    }
    .floating-panel input[type="color"] {
        width: auto; height: 35px; padding: 2px;
        vertical-align: middle; margin-left: 0;
    }
    .floating-panel input[type="radio"],
    .floating-panel input[type="checkbox"] {
        width: auto; margin-right: 5px; vertical-align: middle;
    }
    .floating-panel .checkbox-label {
        font-weight: normal; display: inline-block; margin-bottom: 5px; color: #333;
    }
    #editIconsOptionsContainer {
        display: flex;
        flex-direction: column;
        gap: 5px;
    }

    #weeklyNavUrlHelpText {
      font-size: 11px;
      color: #555;
      margin-top: -8px;
      margin-bottom: 10px;
      display: block;
      line-height: 1.4;
    }
    #weeklyNavUrlBtnContainer {
      display: flex;
      gap: 10px;
    }

    .floating-panel .format-controls {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        margin-bottom: 10px;
    }
    .floating-panel .format-controls button {
        width: auto;
        min-width: 35px;
        padding: 6px 8px;
        margin-right: 5px;
        margin-bottom: 5px;
    }
    .floating-panel .format-controls select {
        flex-grow: 1;
        margin-right: 5px;
    }

    .floating-panel .char-insert-container {
        display: flex;
        align-items: center;
        gap: 5px;
        margin-bottom: 10px;
    }

    .floating-panel input:focus, .floating-panel select:focus {
        border-color: #00897b; outline: none; box-shadow: 0 0 0 2px rgba(0, 137, 123, 0.2);
    }
    .floating-panel button {
        background-color: #00897b; color: white; border: none; cursor: pointer;
        transition: background-color 0.2s ease;
    }
    .floating-panel button:hover { background-color: #00695c; }
    .floating-panel button.secondary { background-color: #b0bec5; color: #333; }
    .floating-panel button.secondary:hover { background-color: #90a4ae; }

    #elementStyleControls { margin-top: 15px; }
    #elementStyleControls h4 { font-size: 1.1em; color: #00695c; margin-top:0; margin-bottom: 10px; border-bottom: 1px solid #ddd; padding-bottom: 5px;}

    .common-item-template { display: none; }
    body.true-fullscreen-active { overflow: hidden !important; }
    #appContainer:fullscreen { background: #fcfcfc; width: 100%; height: 100%; overflow-y: auto; }

    #selectionZoomOverlay {
        position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
        background-color: rgba(240, 240, 240, 0.97);
        z-index: 3000; display: none;
        padding: 20px; box-sizing: border-box; overflow-y: auto;
        cursor: zoom-out;
    }
    #selectionZoomContent {
        background-color: #ffffff;
        padding: 25px; border: 1px solid #ccc; border-radius: 8px;
        box-shadow: 0 4px 15px rgba(0,0,0,0.2);
        max-width: 90%;
        margin: 20px auto;
    }
    .close-selection-zoom-btn {
        position: absolute; top: 10px; right: 10px; font-size: 24px; color: #aaa;
        background-color: transparent; border: none; cursor: pointer; z-index: 3001;
    }
    .close-selection-zoom-btn:hover { color: #777; }
    
    .custom-message-box {
        position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
        background-color: #ffc107; color: #333; padding: 15px 25px;
        border-radius: 5px; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        z-index: 10010;
        display: none; font-size: 1em;
    }
    .custom-message-box.error { background-color: #f44336; color: white; }
    .custom-message-box.success { background-color: #4CAF50; color: white; }
    
    #content a { color: purple; cursor: pointer; text-decoration: underline; }
    #content a:hover { text-decoration: none; }

    .multi-zoom-selected {
        outline: 2px dashed #007bff; outline-offset: 2px;
        box-shadow: 0 0 8px rgba(0, 123, 255, 0.5);
    }

    [data-editable-type] { cursor: default; }
    [data-editable-type][contenteditable="true"],
    .insert-area[contenteditable="true"],
    span[data-editable-type="button-text-label"] { cursor: text; }
    body.ctrl-pressed [data-editable-type]:hover { cursor: zoom-in; }
    body.ctrl-pressed span[data-editable-type="button-text-label"]:hover { cursor: text; }

    .emoji-dropdown { position: relative; display: inline-block; }
    .emoji-dropdown-btn {
        width: auto !important; padding: 8px 10px !important;
        margin-left: 0 !important; margin-bottom: 10px !important;
    }
    .emoji-dropdown-content {
        display: none; position: absolute; background-color: #f9f9f9;
        min-width: 200px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 10005; border-radius: 5px; padding: 10px;
        bottom: 100%; right: 0; max-height: 200px; overflow-y: auto;
        flex-wrap: wrap; gap: 5px; justify-content: space-around;
    }
    .emoji-dropdown-content button.emoji-btn {
        color: black; padding: 6px 8px; text-decoration: none; display: inline-block;
        font-size: 18px; border: none; background: none; cursor: pointer;
        width: auto; margin: 2px;
    }
    .emoji-dropdown-content button.emoji-btn:hover {background-color: #f1f1f1}
    .emoji-dropdown:hover .emoji-dropdown-content,
    .emoji-dropdown .emoji-dropdown-content.show { display: flex; }

    #annotationCanvas, #annotationCanvasImage {
        position: absolute;
        top: 0;
        left: 0;
        pointer-events: none;
        z-index: 9;
    }
     #annotationCanvas {
        display: none;
     }

    .text-annotation-memo {
        position: absolute;
        background-color: #ffffe0;
        border: 1px solid #ccc;
        padding: 8px;
        min-width: 150px;
        min-height: 70px;
        cursor: move;
        z-index: 10;
        box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
        resize: both;
        overflow: auto;
        font-size: 14px;
        line-height: 1.4;
        box-sizing: border-box;
    }
    .text-annotation-memo:focus-within {
        border-color: #007bff;
        box-shadow: 0 0 5px rgba(0,123,255,0.5);
    }
    .text-annotation-memo .memo-delete-btn {
        position: absolute;
        top: 2px;
        right: 4px;
        cursor: pointer;
        font-size: 14px;
        color: #aaa;
        padding: 0 2px;
        line-height: 1;
    }
    .text-annotation-memo .memo-delete-btn:hover {
        color: #333;
    }
    
    body.screensaver-active #weeklyNavigatorContainer,
    body.screensaver-active #time-display-container {
        opacity: 0;
        pointer-events: none;
    }
    
    body.true-fullscreen-active .floating-menu-icon,
    body.true-fullscreen-active .fullscreen-btn-class {
        display: none;
    }

    #annotationDisplayToggleBtn, 
    #annotationSettingsToggleBtn, 
    #memoAnnotationToggleBtn {
        display: none;
    }
    body.true-fullscreen-active #annotationDisplayToggleBtn, 
    body.true-fullscreen-active #annotationSettingsToggleBtn, 
    body.true-fullscreen-active #memoAnnotationToggleBtn {
        display: block;
    }
    
    .simulated-fullscreen {
        position: fixed !important;
        top: 0 !important;
        left: 0 !important;
        width: 100vw !important;
        height: 100vh !important;
        z-index: 20000 !important;
        overflow-y: auto !important;
        background-color: #fcfcfc;
    }


    @media print {
      @page {
        size: a4 landscape;
        margin: 5mm !important;
      }
      body, html {
        margin: 0 !important; padding: 0 !important;
        width: 100% !important; height: auto !important;
        overflow: visible !important;
        -webkit-print-color-adjust: exact !important;
        color-adjust: exact !important;
      }
      #weeklyNavigatorContainer,
      .floating-menu-icon, .fullscreen-btn-class, #multiZoomTriggerBtn,
      .floating-panel, #customMessageBox, #selectionZoomOverlay,
      .exit-true-fullscreen-btn, .item-controls, .add-sub-insert-area-btn,
      #annotationDisplayToggleBtn, #annotationSettingsToggleBtn, #annotationSettingsPanel, #memoAnnotationToggleBtn,
       .text-annotation-memo .memo-delete-btn, #time-display-container {
        display: none !important;
      }
      .text-annotation-memo {
        border: 1px solid #ddd !important;
        background-color: #fff !important;
        box-shadow: none !important;
        page-break-inside: avoid;
      }
      h1#page-title {
        position: relative !important;
        border-bottom: 1px solid #ccc !important;
        padding: 5mm 0 !important;
        margin: 0 0 5mm 0 !important;
        width: 100% !important;
        box-sizing: border-box !important;
        text-align: center;
      }
       #appContainer, .container {
         margin: 0 !important; padding: 0 !important;
         width: 100% !important;
         border: none !important; box-shadow: none !important;
         overflow: visible !important; height: auto !important;
       }
      .container {
        padding-top: 0 !important;
        flex-direction: row !important;
        gap: 10px !important;
      }
      .column, .section-block, .box {
        page-break-inside: avoid;
      }
      .column {
        width: 48% !important;
        float: left;
        margin: 1% !important;
        box-sizing: border-box !important;
      }
      a {
        color: purple !important;
        text-decoration: underline !important;
      }
    }
  </style>
</head>
<body>

<div id="appContainer">
    <div id="time-display-container">
        <span>⏱️</span>
        <span id="initial-time" title="회의 경과 시간">00:00</span>
        <div class="time-separator"></div>
        <span id="current-time">--:-- --</span>
        <span id="current-date" title="날짜 클릭 시 달력 열기">----.--.--</span>
    </div>

    <button class="exit-true-fullscreen-btn" id="exitTrueFullscreenBtnActual" title="기본 보기로 돌아가기">✕</button>
    <button class="fullscreen-btn-class" id="trueFullscreenBtn" title="전체 화면 보기/나가기">⛶</button>
    <button class="floating-menu-icon" id="floatingMenuToggleBtn" title="메뉴 열기">☰</button>
    <button id="multiZoomTriggerBtn" title="선택된 항목 모두 확대" style="display: none;">🔍</button>

    <button id="annotationDisplayToggleBtn" title="주석 켜기/끄기">👁️</button>
    <button id="annotationSettingsToggleBtn" title="주석 설정">⚙️</button>
    <button id="memoAnnotationToggleBtn" title="텍스트 메모 추가 (전체 화면에서 내용 영역 클릭)">📝</button>

    <h1 id="page-title" data-editable-type="page-title" contenteditable="true">’25년 6월 1주차 주간 업무 회의 (기숙사 및 사택)</h1>
    
    <div id="weeklyNavigatorContainer"></div>

    <div class="container" id="content">
      <canvas id="annotationCanvas"></canvas>
      <div class="column" data-editable-type="column">
        <div class="column-title" data-editable-type="column-title" contenteditable="true">전주 (5/26 ~ 6/1)</div>
        <div class="section-block" data-editable-type="section-block">
          <div class="section-header" data-editable-type="section-header" contenteditable="true">■ 협의 항목</div>
          <div class="item" data-editable-type="item"><span contenteditable="true">- 내용 삽입</span></div>
          <button class="add-sub-insert-area-btn" contenteditable="false">
            <span contenteditable="true" data-editable-type="button-text-label">+ 항목 추가</span>
          </button>
        </div>
        <div class="divider" data-editable-type="divider"></div>
        <div class="section-block gray" data-editable-type="section-block">
          <div class="section-header" data-editable-type="section-header" contenteditable="true">■ 기타 항목</div>
          <div class="item" data-editable-type="item"><span contenteditable="true">- 내용 삽입</span></div>
          <button class="add-sub-insert-area-btn" contenteditable="false">
            <span contenteditable="true" data-editable-type="button-text-label">+ 항목 추가</span>
          </button>
        </div>
        <div class="section-block" data-editable-type="section-block">
          <div class="section-header pr-section" data-editable-type="section-header" contenteditable="true">■ PR발송 목록</div>
          <div class="item" data-editable-type="item"><span contenteditable="true">- 내용 삽입</span></div>
          <button class="add-sub-insert-area-btn" contenteditable="false">
            <span contenteditable="true" data-editable-type="button-text-label">+ 항목 추가</span>
          </button>
        </div>
      </div>
      <div class="column" data-editable-type="column">
        <div class="column-title" data-editable-type="column-title" contenteditable="true">금주 (6/2 ~ 6/8)</div>
        <div class="section-block" data-editable-type="section-block">
          <div class="section-header" data-editable-type="section-header" contenteditable="true">■ 협의 항목</div>
          <div class="item" data-editable-type="item"><span contenteditable="true">- 내용 삽입</span></div>
          <button class="add-sub-insert-area-btn" contenteditable="false">
            <span contenteditable="true" data-editable-type="button-text-label">+ 항목 추가</span>
          </button>
        </div>
        <div class="divider" data-editable-type="divider"></div>
        <div class="section-block gray" data-editable-type="section-block">
          <div class="section-header" data-editable-type="section-header" contenteditable="true">■ 기타 항목</div>
          <div class="item" data-editable-type="item"><span contenteditable="true">- 내용 삽입</span></div>
           <button class="add-sub-insert-area-btn" contenteditable="false">
            <span contenteditable="true" data-editable-type="button-text-label">+ 항목 추가</span>
          </button>
        </div>
        <div class="section-block" data-editable-type="section-block">
          <div class="section-header pr-section" data-editable-type="section-header" contenteditable="true">■ PR발송 목록</div>
          <div class="item" data-editable-type="item"><span contenteditable="true">- 내용 삽입</span></div>
          <button class="add-sub-insert-area-btn" contenteditable="false">
            <span contenteditable="true" data-editable-type="button-text-label">+ 항목 추가</span>
          </button>
        </div>
      </div>
    </div>

    <div id="annotationSettingsPanel" style="display: none;">
        <span id="closeAnnotationSettingsBtn" title="설정 적용 및 닫기">&times;</span>
        <div>
            <button id="annoToolPen" data-tool="pen" title="펜">펜</button>
            <button id="annoToolHighlighter" data-tool="highlighter" title="형광펜">형광펜</button>
            <button id="annoToolCircle" data-tool="circle" title="원">○</button>
            <button id="annoToolEllipse" data-tool="ellipse" title="타원">◌</button>
            <button id="annoToolOrthoLine" data-tool="orthoLine" title="직각선">📐</button>
        </div>
        <div>
            <label for="annoColorPicker">색:</label>
            <input type="color" id="annoColorPicker" title="색상 선택">
        </div>
        <div>
            <label for="annoLineWidth">굵기:</label>
            <input type="range" id="annoLineWidth" min="1" max="20" title="선 굵기">
        </div>
        <div id="annoHighlighterOpacityContainer" style="display: none;">
            <label for="annoHighlighterOpacity">투명도:</label>
            <input type="range" id="annoHighlighterOpacity" min="0.1" max="1" step="0.1" value="0.3" title="형광펜 투명도">
        </div>
        <div>
            <button id="annoToolEraser" data-tool="eraser" title="지우개">지우개</button>
            <button id="annoClearCanvas" title="모두 지우기">전체삭제</button>
        </div>
        <div>
            <input type="checkbox" id="annoKeepDrawingsVisible" checked>
            <label for="annoKeepDrawingsVisible" style="font-size:11px; white-space: nowrap;">그림 유지(비활성시)</label>
        </div>
    </div>
    <div id="customMessageBox" class="custom-message-box"></div>
    <div class="floating-panel" id="menuPanel">
      <span class="floating-panel-close-btn" id="closeMenuPanelBtn" title="메뉴 닫기">✕</span>
      <label>⚙️ 설정</label>
      <div id="editIconsOptionsContainer">
          <label class="checkbox-label" for="editIconsModeOff">
            <input type="radio" id="editIconsModeOff" name="editIconsMode" value="off">
            아이콘 숨김
          </label>
          <label class="checkbox-label" for="editIconsModeAll">
            <input type="radio" id="editIconsModeAll" name="editIconsMode" value="all">
            전체 아이콘 표시
          </label>
          <label class="checkbox-label" for="editIconsModeSelected">
            <input type="radio" id="editIconsModeSelected" name="editIconsMode" value="selected">
            선택 아이콘만 표시
          </label>
      </div>
      <hr>
      <label>🔗 링크 편집</label>
      <input type="text" id="linkURL" placeholder="링크 URL (선택된 텍스트에 적용)" />
      <button id="applyLinkBtn">선택 영역에 링크 삽입</button>
      <button id="removeLinkBtn" class="secondary">선택 영역 링크 제거</button>
      
      <div id="weeklyNavUrlSettings">
          <hr>
          <label>주간 회의록 URL 설정</label>
          <input type="text" id="weeklyNavUrlTemplate" placeholder="회의록 파일 경로 템플릿">
          <span id="weeklyNavUrlHelpText">
              {YYYY}: 4자리 연도, {YY}: 2자리 연도<br>
              {MM}: 2자리 월, {WW}: 2자리 주
          </span>
          <div id="weeklyNavUrlBtnContainer">
            <button id="applyWeeklyNavUrlBtn">URL 적용</button>
            <button id="removeWeeklyNavUrlBtn" class="secondary">네비게이션 제거</button>
          </div>
      </div>
      
      <hr>
      <label>✍️ 텍스트 서식</label>
      <div class="format-controls">
        <button id="applyBoldBtn" title="굵게"><b>B</b></button>
        <button id="applyItalicBtn" title="기울임꼴"><i>I</i></button>
        <button id="applyUnderlineBtn" title="밑줄"><u>U</u></button>
        <button id="applyStrikethroughBtn" title="취소선" style="text-decoration: line-through;">S</button>
        <button id="applySuperscriptBtn" title="위 첨자">A<sup>+</sup></button>
        <button id="applySubscriptBtn" title="아래 첨자">A<sub>-</sub></button>
      </div>
      <div class="format-controls">
        <select id="fontSizeSelector" title="글꼴 크기">
          <option value="1">아주 작게</option> <option value="2">작게</option> <option value="3" selected>보통</option>
          <option value="4">조금 크게</option> <option value="5">크게</option> <option value="6">아주 크게</option> <option value="7">최대로 크게</option>
        </select>
        <input type="color" id="fontColorSelector" title="글꼴 색상" value="#000000">
        <input type="color" id="backColorSelector" title="텍스트 배경색" value="#ffffff">
      </div>
      <hr>
      <label>💡 아이콘/특수문자 삽입</label>
      <div class="char-insert-container">
        <input type="text" id="charInput" placeholder="문자 입력 (예: ⭐, ✔, ►)">
        <div class="emoji-dropdown">
            <button type="button" class="emoji-dropdown-btn" id="emojiDropdownBtn">▼</button>
            <div class="emoji-dropdown-content" id="emojiPalette">
            </div>
        </div>
      </div>
       <button id="insertCharFromInputBtn" title="선택 위치에 삽입" style="width:100%; margin-top: 5px;">입력 문자 삽입</button>
      <hr>
      <label>✒️ 주석 도구</label>
      <div>
          <input type="checkbox" id="menuAnnoKeepDrawingsVisible">
          <label for="menuAnnoKeepDrawingsVisible" class="checkbox-label">그림 유지(비활성시)</label>
      </div>
      <button id="menuAnnoDrawingToggle" style="width:100%; margin-top:5px;">주석 켜기/끄기</button>
      <button id="menuAnnoSettingsPanelToggle" style="width:100%; margin-top:5px;">주석 설정 열기/닫기</button>
      <button id="menuMemoAnnotationBtn" style="width:100%; margin-top:5px;">메모 추가 (전체화면)</button>
      <hr>
      <label>📄 문서 저장</label>
      <button id="saveHtmlBtn">💾 HTML로 저장</button>
      <button id="printPdfBtn">📄 PDF로 인쇄</button>
      <hr>
      <div id="elementStyleControls" style="display:none;">
          <h4>선택 요소 스타일</h4>
          <div class="color-input-container">
            <label for="elementBgColor">배경색:</label>
            <input type="color" id="elementBgColor">
          </div>
          <div class="color-input-container">
            <label for="elementTextColor">글자색:</label>
            <input type="color" id="elementTextColor">
          </div>
          <div>
            <label for="elementBorderRadius">테두리 굴곡 (px):</label>
            <input type="number" id="elementBorderRadius" min="0" step="1" placeholder="예: 5">
          </div>
          <div>
            <label for="elementShapeSelector">모양:</label>
            <select id="elementShapeSelector">
              <option value="default">기본 모양</option>
              <option value="rectangle">직사각형</option>
              <option value="rounded-rectangle">둥근 직사각형</option>
              <option value="oval">타원형/원형</option>
            </select>
          </div>
        </div>
    </div>
    <div id="areaSelectionRectangle" style="display: none;"></div>
    <div id="selectionZoomOverlay">
        <button class="close-selection-zoom-btn" id="closeSelectionZoomBtn" title="닫기 (또는 바깥 클릭)">✕</button>
        <div id="selectionZoomContent"></div>
    </div>
</div>

<div class="common-item-template">
  <div class="item" data-editable-type="item" contenteditable="true">새로운 기본 항목...</div>
  <div class="default-shape-item" data-editable-type="item" contenteditable="true">새로운 항목 내용...</div>
  <div class="insert-area templated-insert-area" contenteditable="true" data-editable-type="insert-area">### 입력 ##...</div>
  <div class="box" data-editable-type="box" style="margin-left: 0; background-color: #e9e9e9;">새 박스
      <div class="section-subtitle" data-editable-type="section-subtitle" style="margin-left:0;">새 하위 제목</div>
  </div>
  <span data-editable-type="flow-span" style="background-color: #cceeff;">새 흐름 단계</span>
</div>

<script id="mainAppScript">
let weeklyNavigatorConfig = {
  enabled: true, 
  baseURL: 'https://jonggunelee.github.io/wyggkr03/', 
  filenameStructureTemplate: '{YYYY}/{YYYY}_{MM}_{WW}_회의록.html',
  pastFilenameStructureTemplate: '{YYYY}/{YYYY}_{MM}_{WW}_회의록.pdf'
};
// 스크립트 실행 시점의 시간을 기록 (타이머 기준 시간)
const initialTime = new Date();

const appContainer = document.getElementById('appContainer');
const contentArea = document.getElementById('content');
const pageTitle = document.getElementById("page-title");
const menuPanel = document.getElementById("menuPanel");
const floatingMenuToggleBtn = document.getElementById("floatingMenuToggleBtn");
const closeMenuPanelBtn = document.getElementById("closeMenuPanelBtn");
const trueFullscreenBtn = document.getElementById('trueFullscreenBtn');
const exitTrueFullscreenBtnActual = document.getElementById('exitTrueFullscreenBtnActual');
const multiZoomTriggerBtn = document.getElementById('multiZoomTriggerBtn');
const selectionZoomOverlay = document.getElementById('selectionZoomOverlay');
const selectionZoomContent = document.getElementById('selectionZoomContent');
const annotationDisplayToggleBtn = document.getElementById('annotationDisplayToggleBtn');
const annotationSettingsToggleBtn = document.getElementById('annotationSettingsToggleBtn');
const annotationSettingsPanel = document.getElementById('annotationSettingsPanel');
const closeAnnotationSettingsBtn = document.getElementById('closeAnnotationSettingsBtn');
const annotationCanvas = document.getElementById('annotationCanvas');
const annoToolPenBtn = document.getElementById('annoToolPen');
const annoToolHighlighterBtn = document.getElementById('annoToolHighlighter');
const annoToolCircleBtn = document.getElementById('annoToolCircle');
const annoToolEllipseBtn = document.getElementById('annoToolEllipse');
const annoToolOrthoLineBtn = document.getElementById('annoToolOrthoLine');
const annoColorPicker = document.getElementById('annoColorPicker');
const annoLineWidthSlider = document.getElementById('annoLineWidth');
const annoToolEraserBtn = document.getElementById('annoToolEraser');
const annoClearCanvasBtn = document.getElementById('annoClearCanvas');
const annoHighlighterOpacityContainer = document.getElementById('annoHighlighterOpacityContainer');
const annoHighlighterOpacitySlider = document.getElementById('annoHighlighterOpacity');
const annoKeepDrawingsVisibleCheckbox = document.getElementById('annoKeepDrawingsVisible');
const menuAnnoKeepDrawingsVisible = document.getElementById('menuAnnoKeepDrawingsVisible');
const menuAnnoDrawingToggle = document.getElementById('menuAnnoDrawingToggle');
const menuAnnoSettingsPanelToggle = document.getElementById('menuAnnoSettingsPanelToggle');
const menuMemoAnnotationBtn = document.getElementById('menuMemoAnnotationBtn');
const memoAnnotationToggleBtn = document.getElementById('memoAnnotationToggleBtn');

let isMemoModeActive = false;
let annotationCtx = annotationCanvas.getContext('2d');
let isDrawingFeatureActive = false;
let isAnnotationPanelOpen = false;
let isDrawingAnnotation = false;
let lastAnnotationX, lastAnnotationY;
let shapeStartX, shapeStartY;
let isShiftKeyDown = false;
let previewImageData = null;
let drawingSettings = {
  tool: 'pen', penColor: '#800080', penLineWidth: '5',
  highlighterColor: '#FFFFE0', highlighterLineWidth: '20', highlighterOpacity: '0.3',
};
let panelUISettings = { ...drawingSettings };
let keepDrawingsVisibleOnDeactivate = true;
let drawnStrokes = [];
let isDraggingPanel = false, panelOffsetX, panelOffsetY;
let currentlySelectedElementForStyling = null;
let currentlyActiveItemControlsElement = null;
let elementsForMultiZoom = [];
let displayedYearInNav, displayedMonthInNav;
let documentYear, documentMonth, documentWeek;
let idleTimer = null;
let scrollInterval = null;
let isScreensaverActive = false;
const IDLE_TIMEOUT = 5000;
const SCROLL_SPEED = 30;

function showMessage(message, type = 'warning', duration = 3000) {
  const messageBox = document.getElementById('customMessageBox');
  if (!messageBox) return;
  messageBox.textContent = message;
  messageBox.className = 'custom-message-box';
  if (type === 'error') messageBox.classList.add('error');
  else if (type === 'success') messageBox.classList.add('success');
  messageBox.style.display = 'block';
  setTimeout(() => { messageBox.style.display = 'none'; }, duration);
}

// ===================================================================
// [NEW] 회의 시간 타이머, 현재 시간, 달력 기능 초기화 함수
// ===================================================================
function initializeTimeAndDateFeature(startTime) {
    const initialTimeEl = document.getElementById('initial-time');
    const currentTimeEl = document.getElementById('current-time');
    const currentDateEl = document.getElementById('current-date');

    if (!initialTimeEl || !currentTimeEl || !currentDateEl) return;

    // 1. 회의 경과 시간 타이머 (Stopwatch)
    initialTimeEl.textContent = '00:00';
    initialTimeEl.title = '회의 경과 시간';
    setInterval(() => {
        const elapsedMinutes = Math.floor((new Date() - startTime) / 60000);
        const hours = Math.floor(elapsedMinutes / 60).toString().padStart(2, '0');
        const minutes = (elapsedMinutes % 60).toString().padStart(2, '0');
        initialTimeEl.textContent = `${hours}:${minutes}`;
    }, 60000); // 1분마다 업데이트

    // 2. 현재 시간 / 날짜 표시
    function updateCurrentClock() {
        const now = new Date();
        // 시간 포맷팅 (AM/PM HH:MM)
        let hours = now.getHours();
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const ampm = hours >= 12 ? 'PM' : 'AM';
        hours = hours % 12;
        hours = hours ? hours : 12; // 0시를 12시로 표시
        const timeString = `${ampm} ${hours.toString().padStart(2, '0')}:${minutes}`;
        currentTimeEl.textContent = timeString;

        // 날짜 포맷팅 (YY-MM-DD)
        const year = now.getFullYear().toString().slice(-2);
        const month = (now.getMonth() + 1).toString().padStart(2, '0');
        const day = now.getDate().toString().padStart(2, '0');
        const dateString = `${year}-${month}-${day}`;
        currentDateEl.textContent = dateString;
    }
    updateCurrentClock(); // 즉시 실행
    setInterval(updateCurrentClock, 1000); // 1초마다 업데이트

    // 3. 달력 기능 (Flatpickr)
    if (typeof flatpickr === 'function') {
        flatpickr("#current-date", {
            locale: "ko",
            dateFormat: "y-m-d",
        });
    }
}
// ===================================================================

function startScreensaver() {
    // --- [MODIFIED] 전체 화면 모드에서도 스크린세이버가 동작하도록 조건 수정 ---
    if (isScreensaverActive) {
        resetIdleTimer();
        return;
    }
    
    isScreensaverActive = true;
    appContainer.classList.add('simulated-fullscreen');
    document.body.classList.add('screensaver-active');
    fullscreenChangeHandler(); 

    scrollInterval = setInterval(() => {
        const el = document.fullscreenElement || appContainer; // --- [MODIFIED] 전체 화면 요소를 우선으로 사용
        if ((el.clientHeight + el.scrollTop) >= el.scrollHeight - 2) {
            el.scrollTop = 0;
        } else {
            el.scrollBy(0, 1);
        }
    }, SCROLL_SPEED);
}

function stopScreensaver() {
    if (!isScreensaverActive) return;

    clearInterval(scrollInterval);
    scrollInterval = null;

    appContainer.classList.remove('simulated-fullscreen');
    document.body.classList.remove('screensaver-active');
    isScreensaverActive = false;

    if (!document.fullscreenElement) {
        fullscreenChangeHandler();
    }
}

function resetIdleTimer() {
    if (isScreensaverActive) {
        stopScreensaver();
    }
    clearTimeout(idleTimer);
    idleTimer = setTimeout(startScreensaver, IDLE_TIMEOUT);
}

function handleScrollForIdleReset() {
    if (isScreensaverActive) return;
    resetIdleTimer();
}

function adjustContainerPadding() {
    const titleEl = pageTitle;
    const navigatorEl = document.getElementById('weeklyNavigatorContainer');
    const contentEl = contentArea;

    if (titleEl && contentEl) {
        requestAnimationFrame(() => {
            const titleHeight = titleEl.offsetHeight;
            const navigatorHeight = navigatorEl && getComputedStyle(navigatorEl).display !== 'none' ? navigatorEl.offsetHeight : 0;
            const totalHeaderHeight = titleHeight + navigatorHeight;

            if (navigatorEl && getComputedStyle(navigatorEl).display !== 'none') {
               navigatorEl.style.top = `${titleHeight}px`;
            }

            contentEl.style.paddingTop = `${totalHeaderHeight + 20}px`;
        });
    }
}


function getSaveFileName(extension) {
  const titleText = (pageTitle.textContent || '').trim();
  const match = titleText.match(/(\d{2,4})년\s*(\d{1,2})월\s*(\d{1,2})주차/);
  if (match) {
      let year = parseInt(match[1], 10);
      if (year < 100) year += 2000;
      let month = String(parseInt(match[2], 10)).padStart(2, '0');
      let week = String(parseInt(match[3], 10)).padStart(2, '0');
      
      const filename = weeklyNavigatorConfig.filenameStructureTemplate
            .replace(/{YYYY}/g, year)
            .replace(/{YY}/g, String(year).slice(-2))
            .replace(/{MM}/g, month)
            .replace(/{M}/g, parseInt(month, 10))
            .replace(/{WW}/g, week)
            .replace(/{W}/g, parseInt(week, 10));

      return filename.substring(filename.lastIndexOf('/') + 1).replace('.html', `.${extension}`);
  }
  
  const now = new Date();
  const year = now.getFullYear();
  const month = (now.getMonth() + 1).toString().padStart(2, '0');
  const day = now.getDate().toString().padStart(2, '0');
  return `주간회의_${year}${month}${day}.${extension}`;
}

function getWeekOfMonth(date) {
    const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay();
    return Math.ceil((date.getDate() + firstDayOfMonth) / 7);
};

function updateDateTitles() {
    if(window.__SAVED_APP_STATE__) return;
    const now = new Date();
    
    const yearYY = now.getFullYear().toString().slice(-2);
    const monthMM = (now.getMonth() + 1).toString();
    const weekW = getWeekOfMonth(now);
    const newPageTitleText = `’${yearYY}년 ${monthMM}월 ${weekW}주차 주간 업무 회의 (기숙사 및 사택)`;
    const newMetaTitleText = `’${yearYY}년 ${monthMM}월 ${weekW}주차 주간 업무 회의`;
    
    if (pageTitle) pageTitle.innerHTML = newPageTitleText;
    
    const titleMeta = document.querySelector('meta[name="editable-title"]');
    if (titleMeta) titleMeta.content = newMetaTitleText;
    document.title = newPageTitleText;

    const formatDate = (date) => `${(date.getMonth() + 1)}/${date.getDate()}`;
    const dayOfWeek = now.getDay();
    const diffToMonday = dayOfWeek === 0 ? -6 : 1 - dayOfWeek; 
    const thisMonday = new Date(now);
    thisMonday.setDate(now.getDate() + diffToMonday);
    const thisSunday = new Date(thisMonday);
    thisSunday.setDate(thisMonday.getDate() + 6);
    const lastMonday = new Date(thisMonday);
    lastMonday.setDate(thisMonday.getDate() - 7);
    const lastSunday = new Date(thisSunday);
    lastSunday.setDate(thisSunday.getDate() - 7);
    const columnTitles = document.querySelectorAll('.column-title');
    if (columnTitles.length >= 2) {
        columnTitles[0].innerHTML = `전주 (${formatDate(lastMonday)} ~ ${formatDate(lastSunday)})`;
        columnTitles[1].innerHTML = `금주 (${formatDate(thisMonday)} ~ ${formatDate(thisSunday)})`;
    }
}

function getNumberOfWeeksInMonth(year, month) {
    const firstDay = new Date(year, month - 1, 1);
    const lastDay = new Date(year, month, 0);
    const firstDayOfWeek = firstDay.getDay(); 
    const totalDays = lastDay.getDate();
    return Math.ceil((totalDays + firstDayOfWeek) / 7);
}

function renderWeeklyNavigator() {
  const navContainer = document.getElementById('weeklyNavigatorContainer');
  if (!weeklyNavigatorConfig.enabled || !displayedYearInNav || !displayedMonthInNav) {
      if(navContainer) navContainer.style.display = 'none';
      adjustContainerPadding();
      return;
  }
  navContainer.innerHTML = '';

  const yearControls = document.createElement('div');
  yearControls.className = 'navigator-controls';
  const prevYearBtn = document.createElement('button');
  prevYearBtn.id = 'prevYearBtn';
  prevYearBtn.textContent = '◀';
  prevYearBtn.title = '이전 연도';
  prevYearBtn.onclick = () => {
      displayedYearInNav--;
      renderWeeklyNavigator();
  };
  const currentYearSpan = document.createElement('span');
  currentYearSpan.id = 'currentYearSpan';
  currentYearSpan.className = 'current-display-span';
  currentYearSpan.textContent = `${displayedYearInNav}년`;
  const nextYearBtn = document.createElement('button');
  nextYearBtn.id = 'nextYearBtn';
  nextYearBtn.textContent = '▶';
  nextYearBtn.title = '다음 연도';
  nextYearBtn.onclick = () => {
      displayedYearInNav++;
      renderWeeklyNavigator();
  };
  yearControls.appendChild(prevYearBtn);
  yearControls.appendChild(currentYearSpan);
  yearControls.appendChild(nextYearBtn);
  navContainer.appendChild(yearControls);

  const weekLinksContainer = document.createElement('div');
  weekLinksContainer.id = 'weekLinksContainer';
  const weeksInMonth = getNumberOfWeeksInMonth(displayedYearInNav, displayedMonthInNav);
  const now = new Date();
  const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
  const actualCurrentYear = now.getFullYear();
  const actualCurrentMonth = now.getMonth() + 1;
  const actualCurrentWeek = getWeekOfMonth(now);

  for (let w = 1; w <= weeksInMonth; w++) {
      const weekLink = document.createElement('span');
      weekLink.className = 'week-link';
      weekLink.textContent = `${w}주`;
      const firstDayOfMonth = new Date(displayedYearInNav, displayedMonthInNav - 1, 1).getDay();
      const linkDate = new Date(displayedYearInNav, displayedMonthInNav - 1, (w - 1) * 7 + 1 - firstDayOfMonth);

      if (linkDate > today) {
          weekLink.classList.add('disabled');
          weekLink.title = '아직 작성되지 않은 회의록';
      } else {
          let pathTemplate = (linkDate < today) 
              ? weeklyNavigatorConfig.pastFilenameStructureTemplate 
              : weeklyNavigatorConfig.filenameStructureTemplate;
          
          const url = (weeklyNavigatorConfig.baseURL || '') + pathTemplate
              .replace(/{YYYY}/g, displayedYearInNav)
              .replace(/{YY}/g, String(displayedYearInNav).slice(-2))
              .replace(/{MM}/g, String(displayedMonthInNav).padStart(2, '0'))
              .replace(/{M}/g, displayedMonthInNav)
              .replace(/{WW}/g, String(w).padStart(2, '0'))
              .replace(/{W}/g, w);

          weekLink.classList.add('active');
          weekLink.onclick = () => window.open(url, '_blank');
          weekLink.title = `${displayedYearInNav}년 ${displayedMonthInNav}월 ${w}주차 회의록 보기`;

          if (displayedYearInNav === actualCurrentYear && displayedMonthInNav === actualCurrentMonth && w === actualCurrentWeek) {
              weekLink.classList.add('actual-current');
              weekLink.title += ' (이번 주)';
          }
      }
      
      if (displayedYearInNav === documentYear && displayedMonthInNav === documentMonth && w === documentWeek) {
          weekLink.classList.add('current');
          weekLink.classList.remove('active');
          weekLink.title = '현재 보고 있는 문서';
          weekLink.onclick = null;
      }
      
      weekLinksContainer.appendChild(weekLink);
  }
  navContainer.appendChild(weekLinksContainer);

  const monthControls = document.createElement('div');
  monthControls.className = 'navigator-controls';
  const prevMonthBtn = document.createElement('button');
  prevMonthBtn.id = 'prevMonthBtn';
  prevMonthBtn.textContent = '◀';
  prevMonthBtn.title = '이전 월';
  prevMonthBtn.onclick = () => {
      displayedMonthInNav--;
      if (displayedMonthInNav < 1) {
          displayedMonthInNav = 12;
          displayedYearInNav--;
      }
      renderWeeklyNavigator();
  };
  const currentMonthSpan = document.createElement('span');
  currentMonthSpan.id = 'currentMonthSpan';
  currentMonthSpan.className = 'current-display-span';
  currentMonthSpan.textContent = `${displayedMonthInNav}월`;
  const nextMonthBtn = document.createElement('button');
  nextMonthBtn.id = 'nextMonthBtn';
  nextMonthBtn.textContent = '▶';
  nextMonthBtn.title = '다음 월';
  nextMonthBtn.onclick = () => {
      displayedMonthInNav++;
      if (displayedMonthInNav > 12) {
          displayedMonthInNav = 1;
          displayedYearInNav++;
      }
      renderWeeklyNavigator();
  };
  monthControls.appendChild(prevMonthBtn);
  monthControls.appendChild(currentMonthSpan);
  monthControls.appendChild(nextMonthBtn);
  navContainer.appendChild(monthControls);
  
  navContainer.style.display = 'flex';
  requestAnimationFrame(adjustContainerPadding);
}

function initializeWeeklyNavigator() {
  const navContainer = document.getElementById('weeklyNavigatorContainer');
  if (!navContainer) return;

  const urlTemplateInput = document.getElementById('weeklyNavUrlTemplate');
  const applyUrlBtn = document.getElementById('applyWeeklyNavUrlBtn');
  const removeUrlBtn = document.getElementById('removeWeeklyNavUrlBtn');

  if (urlTemplateInput && applyUrlBtn && removeUrlBtn) {
      urlTemplateInput.value = weeklyNavigatorConfig.filenameStructureTemplate;
      applyUrlBtn.addEventListener('click', () => {
          const newTemplate = urlTemplateInput.value.trim();
          if (newTemplate) {
              weeklyNavigatorConfig.enabled = true;
              if (newTemplate.startsWith('http://') || newTemplate.startsWith('https://')) {
                  weeklyNavigatorConfig.baseURL = '';
                  weeklyNavigatorConfig.filenameStructureTemplate = newTemplate;
                   showMessage('전체 URL 템플릿이 적용되었습니다.', 'success');
              } else {
                   weeklyNavigatorConfig.baseURL = 'https://jonggunelee.github.io/wyggkr03/';
                   weeklyNavigatorConfig.filenameStructureTemplate = newTemplate;
                   showMessage('URL 경로 템플릿이 적용되었습니다.', 'success');
              }
              renderWeeklyNavigator();
          } else {
              showMessage('URL 템플릿을 입력하세요.', 'error');
          }
      });

      removeUrlBtn.addEventListener('click', () => {
          weeklyNavigatorConfig.enabled = false;
          showMessage('주간 네비게이션이 비활성화되었습니다.', 'success');
          renderWeeklyNavigator();
      });
  }

  const titleText = pageTitle.textContent || '';
  const match = titleText.match(/(\d{2,4})년\s*(\d{1,2})월\s*(\d{1,2})주차/);

  if (!match) {
      weeklyNavigatorConfig.enabled = false;
      documentYear = null;
      documentMonth = null;
      documentWeek = null;
      const now = new Date();
      displayedYearInNav = now.getFullYear();
      displayedMonthInNav = now.getMonth() + 1;
  } else {
      let year = parseInt(match[1], 10);
      if (year < 100) year += 2000; 
      documentYear = year;
      documentMonth = parseInt(match[2], 10);
      documentWeek = parseInt(match[3], 10);
      displayedYearInNav = documentYear;
      displayedMonthInNav = documentMonth;
  }
  renderWeeklyNavigator();
}


function toggleTrueFullscreen() {
  try {
      if (!document.fullscreenElement) {
          appContainer.requestFullscreen().catch(err => {
              showMessage("전체 화면 모드를 시작할 수 없습니다: " + err.message, "error");
          });
      } else {
          document.exitFullscreen();
      }
  } catch (e) {
      showMessage("전체 화면 기능에 접근할 수 없습니다.", "error");
  }
}

function exitTrueFullscreen() {
    if (document.fullscreenElement) {
        document.exitFullscreen();
    }
}

function fullscreenChangeHandler() {
  const isRealFs = !!document.fullscreenElement;
  const isSimulatedFs = appContainer.classList.contains('simulated-fullscreen');
  const isTrueFullscreenView = isRealFs || isSimulatedFs;

  document.body.classList.toggle('true-fullscreen-active', isTrueFullscreenView);
  
  if (multiZoomTriggerBtn) {
      multiZoomTriggerBtn.style.display = (isTrueFullscreenView && elementsForMultiZoom.length > 0 && !document.body.classList.contains('selection-zoom-active')) ? 'block' : 'none';
  }
  
  if (document.body.classList.contains('selection-zoom-active')) {
      [floatingMenuToggleBtn, trueFullscreenBtn, multiZoomTriggerBtn, annotationDisplayToggleBtn, annotationSettingsToggleBtn, memoAnnotationToggleBtn, annotationSettingsPanel].forEach(el => {
          if(el) el.style.display = 'none';
      });
  }

  adjustContainerPadding();
  updateAnnotationDisplayToggleBtnStyle();
  setupAnnotationCanvas();
}

function togglePanel() {
  const isPanelCurrentlyOpen = menuPanel.style.display === "block";
  menuPanel.style.display = isPanelCurrentlyOpen ? "none" : "block";

  if (isPanelCurrentlyOpen) {
      floatingMenuToggleBtn.innerHTML = '☰';
      floatingMenuToggleBtn.title = "메뉴 열기";
      hideElementStyleControls();
  } else {
      floatingMenuToggleBtn.innerHTML = '✕';
      floatingMenuToggleBtn.title = "메뉴 닫기";
      menuAnnoKeepDrawingsVisible.checked = keepDrawingsVisibleOnDeactivate;
      menuAnnoDrawingToggle.classList.toggle('active', isDrawingFeatureActive);
      menuAnnoSettingsPanelToggle.classList.toggle('active', isAnnotationPanelOpen && isDrawingFeatureActive);
      menuMemoAnnotationBtn.classList.toggle('active', isMemoModeActive && document.body.classList.contains('true-fullscreen-active'));
  }
}

function handleCloseMenuPanel() {
  menuPanel.style.display = "none";
  floatingMenuToggleBtn.innerHTML = '☰';
  floatingMenuToggleBtn.title = "메뉴 열기";
  hideElementStyleControls();
}

function handlePanelDragStart(e) {
    if (e.target.closest('button, input, select, .floating-panel-close-btn, .checkbox-label, .emoji-dropdown-content, .emoji-btn')) return;
    isDraggingPanel = true;
    const targetPanel = e.currentTarget;
    targetPanel.classList.add('dragging');
    panelOffsetX = e.clientX - targetPanel.getBoundingClientRect().left;
    panelOffsetY = e.clientY - targetPanel.getBoundingClientRect().top;
    if (!targetPanel.style.left || !targetPanel.style.top) {
      const rect = targetPanel.getBoundingClientRect();
      targetPanel.style.left = `${rect.left}px`; targetPanel.style.top = `${rect.top}px`;
      targetPanel.style.right = 'auto'; targetPanel.style.bottom = 'auto';
    }
}

function handlePanelDragMove(e) {
  if (!isDraggingPanel) return;
  e.preventDefault();
  const targetPanel = document.querySelector('.floating-panel.dragging, #annotationSettingsPanel.dragging');
  if (!targetPanel) { isDraggingPanel = false; return; }

  let newX = e.clientX - panelOffsetX;
  let newY = e.clientY - panelOffsetY;
  const panelRect = targetPanel.getBoundingClientRect();
  newX = Math.max(0, Math.min(newX, window.innerWidth - panelRect.width));
  newY = Math.max(0, Math.min(newY, window.innerHeight - panelRect.height));
  targetPanel.style.left = `${newX}px`; targetPanel.style.top = `${newY}px`;
}

function handlePanelDragEnd() {
  if (isDraggingPanel) {
    isDraggingPanel = false;
    const targetPanel = document.querySelector('.floating-panel.dragging, #annotationSettingsPanel.dragging');
    if(targetPanel) targetPanel.classList.remove('dragging');
  }
}

function triggerZoomOnElement(zoomTarget) {
  if (!zoomTarget || !appContainer.contains(zoomTarget) || selectionZoomOverlay.style.display === 'block') return;
  const activeEl = document.activeElement;
  if (activeEl && activeEl !== zoomTarget && appContainer.contains(activeEl) && ['INPUT', 'TEXTAREA', 'SELECT'].includes(activeEl.tagName)) return;
  if (window.getSelection().toString().length > 0 && activeEl === zoomTarget && zoomTarget.isContentEditable) return;

  const clone = zoomTarget.cloneNode(true);
  clone.querySelectorAll('.item-controls').forEach(ctrl => ctrl.remove());
  clone.classList.remove('controls-active', 'multi-zoom-selected');
  Object.assign(clone.style, { transform: 'none', cursor: 'auto' });

  const originalStyle = getComputedStyle(zoomTarget);
  for (let i = 0; i < originalStyle.length; i++) {
      const propName = originalStyle[i];
      const styleBlacklist = ['position', 'top', 'right', 'left', 'bottom', 'z-index', 'margin', 'float', 'clear', 'outline', 'box-shadow', 'transform', 'transition'];
      if (!styleBlacklist.includes(propName)) {
          try { clone.style.setProperty(propName, originalStyle.getPropertyValue(propName), originalStyle.getPropertyPriority(propName)); } catch(e) {}
      }
  }
  Object.assign(clone.style, {
      display: originalStyle.display, margin: '0 auto', marginBottom: '0',
      width: originalStyle.width, height: 'auto', minHeight: originalStyle.minHeight,
      boxSizing: 'border-box', outline: 'none', boxShadow: 'none',
      backgroundColor: (originalStyle.backgroundColor === 'rgba(0, 0, 0, 0)' || originalStyle.backgroundColor === 'transparent') ? 'white' : originalStyle.backgroundColor,
      background: originalStyle.background,
      whiteSpace: (zoomTarget.tagName === 'SPAN' && zoomTarget.parentElement && getComputedStyle(zoomTarget.parentElement).display.includes('flex')) ? 'nowrap' : originalStyle.whiteSpace
  });

  selectionZoomContent.innerHTML = '';
  selectionZoomContent.appendChild(clone);
  selectionZoomOverlay.style.display = 'block';
  document.body.classList.add('selection-zoom-active');
  document.body.style.overflow = 'hidden';
  fullscreenChangeHandler();
}

function displayMultiZoom(elementsToZoom) {
  if (!elementsToZoom || elementsToZoom.length === 0 || selectionZoomOverlay.style.display === 'block') return;
  selectionZoomContent.innerHTML = '';

  let isOriginalLayoutFlex = false;
  let originalParentFlexProperties = { display: 'flex', flexDirection: 'column', alignItems: 'center', gap: '15px' };

  if (elementsToZoom.length > 0 && elementsToZoom[0].parentElement) {
      const parentStyle = getComputedStyle(elementsToZoom[0].parentElement);
      if (parentStyle.display.includes('flex')) {
          isOriginalLayoutFlex = true;
          Object.assign(originalParentFlexProperties, {
              display: parentStyle.display, flexDirection: parentStyle.flexDirection, flexWrap: parentStyle.flexWrap,
              justifyContent: parentStyle.justifyContent, alignItems: parentStyle.alignItems,
              gap: parentStyle.gap === 'normal' ? '10px' : parentStyle.gap
          });
      }
  }
  Object.assign(selectionZoomContent.style, originalParentFlexProperties);

  elementsToZoom.forEach(originalEl => {
      const clone = originalEl.cloneNode(true);
      clone.querySelectorAll('.item-controls').forEach(ctrl => ctrl.remove());
      clone.classList.remove('controls-active', 'multi-zoom-selected');
      Object.assign(clone.style, { transform: 'none', cursor: 'auto' });

      const originalStyle = getComputedStyle(originalEl);
      const blacklist = ['position', 'top', 'right', 'left', 'bottom', 'z-index', 'float', 'clear', 'outline', 'box-shadow', 'transform', 'transition'];
      if (isOriginalLayoutFlex) blacklist.push('margin', 'margin-top', 'margin-right', 'margin-bottom', 'margin-left');

      for (let i = 0; i < originalStyle.length; i++) {
          const propName = originalStyle[i];
          if (!blacklist.includes(propName) && propName !== 'white-space') {
              try { clone.style.setProperty(propName, originalStyle.getPropertyValue(propName), originalStyle.getPropertyPriority(propName)); } catch(e) {}
          }
      }
      Object.assign(clone.style, {
          display: originalStyle.display, width: originalStyle.width, height: 'auto', minHeight: originalStyle.minHeight,
          boxSizing: 'border-box', outline: 'none', boxShadow: 'none',
          backgroundColor: (originalStyle.backgroundColor === 'rgba(0, 0, 0, 0)' || originalStyle.backgroundColor === 'transparent') ? 'white' : originalStyle.backgroundColor,
          background: originalStyle.background,
          whiteSpace: (originalEl.tagName === 'SPAN' && originalEl.parentElement && getComputedStyle(originalEl.parentElement).display.includes('flex')) ? 'nowrap' : originalStyle.whiteSpace
      });
      if (isOriginalLayoutFlex) clone.style.margin = '';
      else Object.assign(clone.style, { marginTop: '0', marginLeft: 'auto', marginRight: 'auto', marginBottom: '15px' });

      selectionZoomContent.appendChild(clone);
  });
  if (!isOriginalLayoutFlex && selectionZoomContent.lastChild) selectionZoomContent.lastChild.style.marginBottom = '0';

  selectionZoomOverlay.style.display = 'block';
  document.body.classList.add('selection-zoom-active');
  document.body.style.overflow = 'hidden';
  fullscreenChangeHandler();
}

function handleMultiZoomTrigger() {
  if (elementsForMultiZoom.length > 0) {
      elementsForMultiZoom.length === 1 ? triggerZoomOnElement(elementsForMultiZoom[0]) : displayMultiZoom([...elementsForMultiZoom]);
  }
}

function closeSelectionZoom() {
  selectionZoomOverlay.style.display = 'none';
  selectionZoomContent.innerHTML = '';
  document.body.classList.remove('selection-zoom-active');
  document.body.style.overflow = '';
  fullscreenChangeHandler();
}

function handleSelectionZoomOverlayClick(event) {
  if (event.target === selectionZoomOverlay || event.target.closest('.close-selection-zoom-btn')) closeSelectionZoom();
}

function activateControls(elementToActivate, focusAndSelect = false) {
    if (currentlyActiveItemControlsElement && currentlyActiveItemControlsElement !== elementToActivate) {
        currentlyActiveItemControlsElement.classList.remove('controls-active');
        if (currentlySelectedElementForStyling === currentlyActiveItemControlsElement) hideElementStyleControls();
    }
    if (elementToActivate) {
        elementToActivate.classList.add('controls-active');
        currentlyActiveItemControlsElement = elementToActivate;
        if (focusAndSelect && elementToActivate.dataset.editableType !== 'page-title') {
            setTimeout(() => {
                elementToActivate.focus();
                if (typeof elementToActivate.select === 'function') {
                    elementToActivate.select();
                } else if (elementToActivate.isContentEditable) {
                    const selection = window.getSelection(), range = document.createRange();
                    if (elementToActivate.firstChild) range.selectNodeContents(elementToActivate);
                    else { range.setStart(elementToActivate, 0); range.collapse(true); }
                    try { selection.removeAllRanges(); selection.addRange(range); } catch(e) { console.warn("Could not set selection:", e); }
                }
            }, 0);
        }
    } else if (currentlyActiveItemControlsElement) {
        currentlyActiveItemControlsElement.classList.remove('controls-active');
        if (currentlySelectedElementForStyling === currentlyActiveItemControlsElement) hideElementStyleControls();
        currentlyActiveItemControlsElement = null;
    }
}

function generateItemControls(element) {
  if (element.querySelector(':scope > .item-controls')) return;
  const controlsDiv = document.createElement('div');
  controlsDiv.className = 'item-controls';

  if (element.dataset.editableType !== 'button-text-label' && element.dataset.editableType !== 'page-title') {
      const addBtn = document.createElement('button');
      addBtn.className = 'item-control-btn item-control-clone-btn';
      addBtn.innerHTML = '➕'; addBtn.title = '항목 복제';
      controlsDiv.appendChild(addBtn);
  }

  const styleBtn = document.createElement('button');
  styleBtn.className = 'item-control-btn item-control-style-btn';
  styleBtn.innerHTML = '🎨'; styleBtn.title = '스타일 변경';
  controlsDiv.appendChild(styleBtn);

  if (element.dataset.editableType !== 'page-title') {
      const delBtn = document.createElement('button');
      delBtn.className = 'item-control-btn item-control-delete-btn';
      delBtn.innerHTML = '🗑️'; delBtn.title = '삭제';
      controlsDiv.appendChild(delBtn);
  }

  if (controlsDiv.children.length > 0 && !element.querySelector(':scope > .item-controls')) {
      element.appendChild(controlsDiv);
  }
}

function cloneAndInsertElement(sourceElement) {
  let newItem = sourceElement.cloneNode(true);
  newItem.removeAttribute('id');
  newItem.querySelectorAll('.item-controls').forEach(ctrl => ctrl.remove());
  newItem.classList.remove('controls-active', 'multi-zoom-selected');

  const computedStyle = getComputedStyle(sourceElement);
  for (let i = 0; i < computedStyle.length; i++) {
      const propName = computedStyle[i];
      const styleBlacklist = ['position','top','right','left','bottom','z-index','display','visibility','opacity','transform','margin','margin-top','margin-right','margin-bottom','margin-left','outline','outline-color','outline-style','outline-width','outline-offset','box-shadow', 'transition', 'cursor'];
      if (!styleBlacklist.includes(propName)) {
          try { newItem.style.setProperty(computedStyle[i], computedStyle.getPropertyValue(computedStyle[i]), computedStyle.getPropertyPriority(computedStyle[i])); } catch (e) {}
      }
  }
  newItem.style.display = computedStyle.display || 'block';

  sourceElement.parentNode.insertBefore(newItem, sourceElement.nextSibling);
  generateItemControls(newItem);
  newItem.querySelectorAll('[data-editable-type]').forEach(desc => generateItemControls(desc));
  activateControls(newItem, true);
  showMessage('항목이 복제되었습니다.', 'success');
}

function toggleMultiZoomSelection(element) {
  const index = elementsForMultiZoom.indexOf(element);
  if (index > -1) { elementsForMultiZoom.splice(index, 1); element.classList.remove('multi-zoom-selected'); }
  else { elementsForMultiZoom.push(element); element.classList.add('multi-zoom-selected'); }
  updateMultiZoomTriggerVisibility();
}

function updateMultiZoomTriggerVisibility() {
  if (multiZoomTriggerBtn) {
      const isSelectionZoomActive = document.body.classList.contains('selection-zoom-active');
      const shouldBeVisible = elementsForMultiZoom.length >= 1 && !isSelectionZoomActive && document.body.classList.contains('true-fullscreen-active');
      multiZoomTriggerBtn.style.display = shouldBeVisible ? 'block' : 'none';
  }
}

function clearMultiZoomSelectionVisuals() {
  elementsForMultiZoom.forEach(e => e.classList.remove('multi-zoom-selected'));
  updateMultiZoomTriggerVisibility();
}

function handleAppContainerClick(event) {
  const target = event.target;

  const controlButton = target.closest('.item-control-btn');
  if (controlButton) {
      event.stopPropagation();
      const element = controlButton.closest('[data-editable-type]');
      if (!element) return;

      if (controlButton.classList.contains('item-control-clone-btn')) {
          cloneAndInsertElement(element);
      } else if (controlButton.classList.contains('item-control-style-btn')) {
          activateElementStyling(element);
      } else if (controlButton.classList.contains('item-control-delete-btn')) {
          const itemText = (element.textContent.substring(0,20) || "이 항목").trim();
          if (element.dataset.editableType === 'button-text-label' && element.parentElement?.classList.contains('add-sub-insert-area-btn')) {
              element.parentElement.remove();
          } else {
              element.remove();
          }
          showMessage(`'${itemText}...' 항목 삭제됨.`, 'success');
          if (currentlySelectedElementForStyling === element) { hideElementStyleControls(); currentlySelectedElementForStyling = null; }
          if (currentlyActiveItemControlsElement === element) activateControls(null);
          const indexInMultiZoom = elementsForMultiZoom.indexOf(element);
          if (indexInMultiZoom > -1) { elementsForMultiZoom.splice(indexInMultiZoom, 1); updateMultiZoomTriggerVisibility(); }
      }
      return;
  }

  const addInsertAreaButton = target.closest('.add-sub-insert-area-btn');
  if (addInsertAreaButton && !target.closest('[data-editable-type="button-text-label"]')) {
      event.stopPropagation();
      const containerElement = addInsertAreaButton.closest('.box, .section-block');
      if (containerElement) {
           addInsertAreaToContainer(containerElement);
      }
      return;
  }

  const clickedItem = target.closest('[data-editable-type]');
  if (!clickedItem) {
      activateControls(null);
      if (elementsForMultiZoom.length > 0 && !target.closest('#multiZoomTriggerBtn')) {
          clearMultiZoomSelectionVisuals(); elementsForMultiZoom = [];
      } return;
  }

  if (clickedItem.dataset.editableType === 'button-text-label' && target === clickedItem) {
      activateControls(clickedItem, true); event.stopPropagation(); return;
  }
  const interactiveChild = target.closest('a, button:not(.add-sub-insert-area-btn), input, select, textarea');
  if (interactiveChild && clickedItem.contains(interactiveChild) && interactiveChild !== clickedItem) {
      if (interactiveChild.tagName === 'A' && interactiveChild.href && !(event.ctrlKey || event.metaKey)) {
           event.preventDefault(); window.open(interactiveChild.href, '_blank', 'noopener,noreferrer');
      } return;
  }
  event.stopPropagation();

  if (event.ctrlKey || event.metaKey) {
      event.preventDefault();
      if (!(clickedItem.dataset.editableType === 'page-title' && elementsForMultiZoom.length > 0 && !elementsForMultiZoom.includes(clickedItem)) &&
          !(clickedItem.dataset.editableType === 'page-title' && elementsForMultiZoom.length === 0 && elementsForMultiZoom.includes(clickedItem) && elementsForMultiZoom.length > 1) ) {
          toggleMultiZoomSelection(clickedItem);
      }
      if (elementsForMultiZoom.length === 1 && elementsForMultiZoom[0] === clickedItem) activateControls(clickedItem);
      else if (elementsForMultiZoom.length !== 1 && currentlyActiveItemControlsElement === clickedItem) activateControls(null);
      else if (elementsForMultiZoom.length > 1 && currentlyActiveItemControlsElement) activateControls(null);

  } else {
      if (elementsForMultiZoom.length > 0 && !elementsForMultiZoom.includes(clickedItem)) {
          clearMultiZoomSelectionVisuals(); elementsForMultiZoom = [];
      }
      if (elementsForMultiZoom.length === 1 && elementsForMultiZoom[0] === clickedItem && clickedItem.dataset.editableType === 'page-title') {
          toggleMultiZoomSelection(clickedItem);
      }
      activateControls(clickedItem);
  }
}

function handleDocumentClick(event) {
  const isClickInsideAppOrGlobalControls = appContainer.contains(event.target) ||
                                       (menuPanel && menuPanel.contains(event.target)) ||
                                       (annotationSettingsPanel && annotationSettingsPanel.contains(event.target)) ||
                                       event.target.closest('.floating-menu-icon, .fullscreen-btn-class, #multiZoomTriggerBtn, .exit-true-fullscreen-btn, #annotationDisplayToggleBtn, #annotationSettingsToggleBtn, #memoAnnotationToggleBtn');

  if (!isClickInsideAppOrGlobalControls) {
      if (currentlyActiveItemControlsElement) {
           activateControls(null);
      }
      if (elementsForMultiZoom.length > 0) {
          clearMultiZoomSelectionVisuals();
          elementsForMultiZoom = [];
      }
  }
}

function handleKeyDown(event) {
    resetIdleTimer();

    if (event.key === 'Shift') {
      isShiftKeyDown = true;
    }
    if (event.ctrlKey || event.metaKey) {
      document.body.classList.add('ctrl-pressed');
      if ((event.key === 'z' || event.key === 'Z') && !event.shiftKey) {
          event.preventDefault(); try { document.execCommand('undo', false, null); showMessage('실행 취소됨', 'success', 1500); }
          catch (e) { showMessage('실행 취소 실패.', 'error'); console.error("Undo failed:", e); }
      } else if ((event.key === 'y' || event.key === 'Y') && !event.shiftKey) {
          event.preventDefault(); try { document.execCommand('redo', false, null); showMessage('다시 실행됨', 'success', 1500); }
          catch (e) { showMessage('다시 실행 실패.', 'error'); console.error("Redo failed:", e); }
      }
    }
}

function handleKeyUp(event) {
  if (event.key === 'Shift') {
      isShiftKeyDown = false;
  }
  if (!event.ctrlKey && !event.metaKey) document.body.classList.remove('ctrl-pressed');
}

function addInsertAreaToContainer(containerElement) {
  if (!containerElement) return;
  const template = document.querySelector('.common-item-template .insert-area.templated-insert-area');
  if (!template) { console.error("Insert area template not found!"); showMessage('템플릿을 찾을 수 없습니다.', 'error'); return; }
  let newInsertArea = template.cloneNode(true);
  newInsertArea.textContent = "### 입력 ##...";
  newInsertArea.classList.remove('templated-insert-area');

  const lastButton = containerElement.querySelector('.add-sub-insert-area-btn:last-of-type');
  if (lastButton) {
      containerElement.insertBefore(newInsertArea, lastButton);
  } else {
      containerElement.appendChild(newInsertArea);
  }

  generateItemControls(newInsertArea);
  activateControls(newInsertArea, true);
  showMessage('하위 입력창이 추가되었습니다.', 'success');
}

function activateElementStyling(element) {
  currentlySelectedElementForStyling = element;
  const styleControls = document.getElementById('elementStyleControls');
  if (!menuPanel || !styleControls) return;

  document.getElementById('elementBgColor').value = rgbToHex(getComputedStyle(element).backgroundColor);
  document.getElementById('elementTextColor').value = rgbToHex(getComputedStyle(element).color);
  const borderRadiusInput = document.getElementById('elementBorderRadius');
  const shapeSelector = document.getElementById('elementShapeSelector');
  const currentBorderRadiusStyle = getComputedStyle(element).borderRadius;

  borderRadiusInput.value = parseInt(currentBorderRadiusStyle) || 0;

  if (currentBorderRadiusStyle === '50%') shapeSelector.value = 'oval';
  else if (currentBorderRadiusStyle.split(' ').every(r => parseFloat(r) === 0 || r === '0px')) shapeSelector.value = 'rectangle';
  else if (parseFloat(currentBorderRadiusStyle) > 0) shapeSelector.value = 'rounded-rectangle';
  else shapeSelector.value = 'default';

  styleControls.style.display = 'block';
  if (menuPanel.style.display !== 'block') togglePanel();
  styleControls.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
  showMessage(`'${(element.dataset.editableType || element.tagName).toLowerCase()}' 스타일 편집 중`, 'success', 2000);
}

function hideElementStyleControls() {
    const styleControls = document.getElementById('elementStyleControls');
    if (styleControls) styleControls.style.display = 'none';
}

function applySelectedElementStyle(property, value) {
  if (currentlySelectedElementForStyling) {
    currentlySelectedElementForStyling.style[property] = value;
    if (currentlySelectedElementForStyling === pageTitle) requestAnimationFrame(adjustContainerPadding);
  }
}

function applySelectedElementShape(shapeValue) {
  if (!currentlySelectedElementForStyling) return;
  const element = currentlySelectedElementForStyling;
  const borderRadiusInput = document.getElementById('elementBorderRadius');
  let radiusToApply = borderRadiusInput ? parseInt(borderRadiusInput.value) : 5;
  if (isNaN(radiusToApply) || radiusToApply < 0) radiusToApply = 5;

  switch (shapeValue) {
      case 'rectangle': element.style.borderRadius = '0px'; if (borderRadiusInput) borderRadiusInput.value = 0; break;
      case 'rounded-rectangle':
          const currentRadius = parseInt(element.style.borderRadius);
          radiusToApply = (currentRadius === 0 || element.style.borderRadius === '50%') ? 4 : (currentRadius || 4);
          element.style.borderRadius = `${radiusToApply}px`; if (borderRadiusInput) borderRadiusInput.value = radiusToApply; break;
      case 'oval': element.style.borderRadius = '50%'; break;
      case 'default': element.style.borderRadius = '';
          if (borderRadiusInput) borderRadiusInput.value = parseInt(getComputedStyle(element).borderRadius) || 0; break;
  }
  if (element === pageTitle) requestAnimationFrame(adjustContainerPadding);
}

function rgbToHex(rgb) {
  if (!rgb || typeof rgb !== 'string' || rgb.indexOf('rgb') === -1) return '#000000';
  if (rgb === 'rgba(0, 0, 0, 0)' || rgb === 'transparent') return '#ffffff';
  let parts = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*([\d.]+))?\)$/);
  if (!parts) return '#000000';
  delete parts[0];
  for (let i = 1; i <= 3; ++i) { parts[i] = parseInt(parts[i]).toString(16); if (parts[i].length == 1) parts[i] = '0' + parts[i]; }
  return `#${parts[1]}${parts[2]}${parts[3]}`;
}

function applyLink() {
  const linkURLInput = document.getElementById("linkURL"); const linkURL = linkURLInput.value.trim();
  if (!linkURL) { showMessage("링크 URL을 입력하세요.", "error"); return; }
  const selection = window.getSelection();
  if (!selection || selection.rangeCount === 0 || selection.isCollapsed) { showMessage("텍스트를 먼저 선택해주세요.", "error"); return; }

  let prefixedURL = linkURL;
  if (!linkURL.startsWith('http://')&&!linkURL.startsWith('https://')&&!linkURL.startsWith('mailto:')&&!linkURL.startsWith('#')&&!linkURL.includes('://')) {
      prefixedURL = 'http://' + linkURL;
  }
  try { if (!prefixedURL.includes(':') && !prefixedURL.startsWith('#') && !prefixedURL.startsWith('/')) new URL(prefixedURL); }
  catch (_) { showMessage("유효한 URL 형식이 아닙니다.", "error"); return; }

  document.execCommand('createLink', false, prefixedURL);
  let createdLink = selection.anchorNode?.nodeType === Node.TEXT_NODE ? selection.anchorNode.parentElement : selection.anchorNode;
  if (createdLink && createdLink.tagName !== 'A') createdLink = createdLink.closest('a');
  if(createdLink?.tagName === 'A'){ createdLink.target = '_blank'; createdLink.rel = 'noopener noreferrer'; }

  showMessage("링크가 삽입되었습니다.", "success"); linkURLInput.value = '';
}

function removeLink() { document.execCommand('unlink', false, null); showMessage("링크가 제거되었습니다.", "success");}
function applyBold() { document.execCommand('bold', false, null); }
function applyItalic() { document.execCommand('italic', false, null); }
function applyUnderline() { document.execCommand('underline', false, null); }
function applyStrikethrough() { document.execCommand('strikeThrough', false, null); }
function applySuperscript() { document.execCommand('superscript', false, null); }
function applySubscript() { document.execCommand('subscript', false, null); }
function changeFontSize(size) { if (size) document.execCommand('fontSize', false, size); }
function changeFontColor(color) { if (color) document.execCommand('foreColor', false, color); }
function changeBackColor(color) { if (color) document.execCommand('backColor', false, color); }
function insertCharacterFromInput() { const charToInsert=document.getElementById('charInput').value; if(!charToInsert){showMessage("삽입할 문자를 입력하세요.","warning");return;} insertCharacter(charToInsert); }
function insertCharacter(char) { if (!char) {showMessage("삽입할 문자를 입력하세요.","warning");return;} document.execCommand('insertText', false, char); }

function toggleEmojiPalette(event) {
  event.stopPropagation();
  const emojiPalette = document.getElementById('emojiPalette');
  emojiPalette.classList.toggle('show');
}

function saveHTML() {
    if (menuPanel.style.display === "block") handleCloseMenuPanel();
    if(currentlyActiveItemControlsElement) activateControls(null);

    const doc = document.cloneNode(true);

    const elementsToRemove = [
        ...doc.querySelectorAll('.item-controls, .add-sub-insert-area-btn, .common-item-template, .custom-message-box'),
        doc.getElementById('mainAppScript'),
        doc.getElementById('menuPanel'), 
        doc.getElementById('annotationSettingsPanel')
    ];
    elementsToRemove.forEach(el => el && el.remove());

    doc.querySelectorAll('[contenteditable], [data-editable-type]').forEach(el => {
        el.removeAttribute('contenteditable');
        el.removeAttribute('data-editable-type');
        el.classList.remove('controls-active');
    });

    const canvasInDoc = doc.getElementById('annotationCanvas');
    if (canvasInDoc) {
        if (drawnStrokes.length > 0) {
            try {
                const dataUrl = annotationCanvas.toDataURL('image/png');
                if (dataUrl && dataUrl !== 'data:,') {
                    const img = doc.createElement('img');
                    img.id = 'annotationCanvasImage';
                    img.src = dataUrl;
                    Object.assign(img.style, {
                        position: 'absolute', top: '0', left: '0',
                        width: '100%', height: '100%',
                        pointerEvents: 'none', zIndex: '9', display: 'block'
                    });
                    canvasInDoc.parentElement.insertBefore(img, canvasInDoc);
                }
            } catch(e) { console.error("Canvas toDataURL failed:", e); }
        }
        canvasInDoc.remove();
    }
    doc.querySelectorAll('.text-annotation-memo .memo-delete-btn').forEach(btn => btn.remove());

    const viewerControlsHTML = `
        <button class="fullscreen-btn-class" id="viewer_fullscreenBtn" title="전체 화면 보기/나가기" style="bottom: 62px;">⛶</button>
        <button class="exit-true-fullscreen-btn" id="viewer_exitFullscreenBtn" title="기본 보기로 돌아가기">✕</button>
        <button class="floating-menu-icon" id="viewer_menuToggleBtn" title="메뉴 열기">☰</button>
        <div class="floating-panel" id="viewer_menuPanel" style="display: none; width:250px; min-height:100px; height:auto;">
            <span class="floating-panel-close-btn" id="viewer_closeMenuBtn" title="메뉴 닫기">✕</span>
            <label>📄 문서</label>
            <button id="viewer_printPdfBtn">📄 PDF로 인쇄</button>
        </div>
        <button id="viewer_annoToggleBtn" title="주석 켜기/끄기" style="bottom: 108px;">👁️</button>
    `;
    const viewerControlsContainer = doc.createElement('div');
    viewerControlsContainer.innerHTML = viewerControlsHTML;

    const appContainerInDoc = doc.getElementById('appContainer');
    if (appContainerInDoc) {
        while(viewerControlsContainer.firstChild){
            appContainerInDoc.appendChild(viewerControlsContainer.firstChild);
        }
    }
    
    const viewerScript = doc.createElement('script');
    viewerScript.id = 'viewerScript';
    viewerScript.textContent = `
        // [NEW] HTML 저장 시 타이머/달력 기능을 위한 스크립트
        (function() {
            // 원본 스크립트의 초기화 함수를 문자열로 가져와서 사용
            const initializeTimeAndDateFeature = ${initializeTimeAndDateFeature.toString()};

            let weeklyNavConfig = ${JSON.stringify(weeklyNavigatorConfig)};
            let documentYear, documentMonth, documentWeek;
            let displayedYearInNav, displayedMonthInNav;
            
            let idleTimer = null;
            let scrollInterval = null;
            let isScreensaverActive = false;
            const IDLE_TIMEOUT = 5000;
            const SCROLL_SPEED = 30;

            function startScreensaver() {
                const app = document.getElementById('appContainer');
                // --- [MODIFIED] 전체 화면 모드에서도 스크린세이버가 동작하도록 조건 수정 ---
                if (!app || isScreensaverActive) {
                    resetIdleTimer();
                    return;
                }
                isScreensaverActive = true;
                app.classList.add('simulated-fullscreen');
                document.body.classList.add('screensaver-active');
                
                scrollInterval = setInterval(() => {
                    const el = document.fullscreenElement || app; // --- [MODIFIED] 전체 화면 요소를 우선으로 사용
                    if ((el.clientHeight + el.scrollTop) >= el.scrollHeight - 2) {
                        el.scrollTop = 0;
                    } else {
                        el.scrollBy(0, 1);
                    }
                }, SCROLL_SPEED);
            }

            function stopScreensaver() {
                const app = document.getElementById('appContainer');
                if (!app || !isScreensaverActive) return;
                clearInterval(scrollInterval);
                scrollInterval = null;
                app.classList.remove('simulated-fullscreen');
                document.body.classList.remove('screensaver-active');
                isScreensaverActive = false;
            }

            function resetIdleTimer() {
                if (isScreensaverActive) {
                    stopScreensaver();
                }
                clearTimeout(idleTimer);
                idleTimer = setTimeout(startScreensaver, IDLE_TIMEOUT);
            }
            
            function handleScrollForIdleReset() {
                if (isScreensaverActive) return;
                resetIdleTimer();
            }

            function getWeekOfMonth(date) {
                const firstDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay();
                return Math.ceil((date.getDate() + firstDayOfMonth) / 7);
            };

            function getNumberOfWeeksInMonth(year, month) {
                const firstDay = new Date(year, month - 1, 1);
                const lastDay = new Date(year, month, 0);
                const firstDayOfWeek = firstDay.getDay(); 
                const totalDays = lastDay.getDate();
                return Math.ceil((totalDays + firstDayOfWeek) / 7);
            }

            function adjustViewerPadding() {
                const titleEl = document.getElementById('page-title');
                const navigatorEl = document.getElementById('weeklyNavigatorContainer');
                const contentEl = document.getElementById('content');
                if (!titleEl || !contentEl) return;
                
                requestAnimationFrame(() => {
                    const titleHeight = titleEl.offsetHeight;
                    const navHeight = navigatorEl && getComputedStyle(navigatorEl).display !== 'none' ? navigatorEl.offsetHeight : 0;
                    const totalHeaderHeight = titleHeight + navHeight;

                    if (navigatorEl && getComputedStyle(navigatorEl).display !== 'none') {
                       navigatorEl.style.top = \`\${titleHeight}px\`;
                    }
                    contentEl.style.paddingTop = \`\${totalHeaderHeight + 20}px\`;
                });
            }

            function renderViewerWeeklyNavigator() {
                const navContainer = document.getElementById('weeklyNavigatorContainer');
                if (!weeklyNavConfig.enabled || !displayedYearInNav || !displayedMonthInNav) {
                    if(navContainer) navContainer.style.display = 'none';
                    adjustViewerPadding();
                    return;
                }
                navContainer.innerHTML = '';

                const yearControls = document.createElement('div');
                yearControls.className = 'navigator-controls';
                const prevYearBtn = document.createElement('button');
                prevYearBtn.textContent = '◀';
                prevYearBtn.title = '이전 연도';
                prevYearBtn.onclick = () => { displayedYearInNav--; renderViewerWeeklyNavigator(); };
                const currentYearSpan = document.createElement('span');
                currentYearSpan.className = 'current-display-span';
                currentYearSpan.textContent = \`\${displayedYearInNav}년\`;
                const nextYearBtn = document.createElement('button');
                nextYearBtn.textContent = '▶';
                nextYearBtn.title = '다음 연도';
                nextYearBtn.onclick = () => { displayedYearInNav++; renderViewerWeeklyNavigator(); };
                yearControls.appendChild(prevYearBtn);
                yearControls.appendChild(currentYearSpan);
                yearControls.appendChild(nextYearBtn);
                navContainer.appendChild(yearControls);

                const weekLinksContainer = document.createElement('div');
                weekLinksContainer.id = 'weekLinksContainer';
                const weeksInMonth = getNumberOfWeeksInMonth(displayedYearInNav, displayedMonthInNav);
                const now = new Date();
                const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
                const actualCurrentYear = now.getFullYear();
                const actualCurrentMonth = now.getMonth() + 1;
                const actualCurrentWeek = getWeekOfMonth(now);

                for (let w = 1; w <= weeksInMonth; w++) {
                    const weekLink = document.createElement('span');
                    weekLink.className = 'week-link';
                    weekLink.textContent = \`\${w}주\`;
                    const firstDayOfMonth = new Date(displayedYearInNav, displayedMonthInNav - 1, 1).getDay();
                    const linkDate = new Date(displayedYearInNav, displayedMonthInNav - 1, (w - 1) * 7 + 1 - firstDayOfMonth);

                    if (linkDate > today) {
                        weekLink.classList.add('disabled');
                        weekLink.title = '아직 작성되지 않은 회의록';
                    } else {
                        let pathTemplate = (linkDate < today) ? weeklyNavConfig.pastFilenameStructureTemplate : weeklyNavConfig.filenameStructureTemplate;
                        const url = (weeklyNavConfig.baseURL || '') + pathTemplate
                            .replace(/{YYYY}/g, displayedYearInNav).replace(/{YY}/g, String(displayedYearInNav).slice(-2))
                            .replace(/{MM}/g, String(displayedMonthInNav).padStart(2, '0')).replace(/{M}/g, displayedMonthInNav)
                            .replace(/{WW}/g, String(w).padStart(2, '0')).replace(/{W}/g, w);
                        weekLink.classList.add('active');
                        weekLink.onclick = () => window.open(url, '_blank');
                        weekLink.title = \`\${displayedYearInNav}년 \${displayedMonthInNav}월 \${w}주차 회의록 보기\`;
                        if (displayedYearInNav === actualCurrentYear && displayedMonthInNav === actualCurrentMonth && w === actualCurrentWeek) {
                            weekLink.classList.add('actual-current');
                            weekLink.title += ' (이번 주)';
                        }
                    }
                    if (displayedYearInNav === documentYear && displayedMonthInNav === documentMonth && w === documentWeek) {
                        weekLink.classList.add('current');
                        weekLink.classList.remove('active');
                        weekLink.title = '현재 보고 있는 문서';
                        weekLink.onclick = null;
                    }
                    weekLinksContainer.appendChild(weekLink);
                }
                navContainer.appendChild(weekLinksContainer);

                const monthControls = document.createElement('div');
                monthControls.className = 'navigator-controls';
                const prevMonthBtn = document.createElement('button');
                prevMonthBtn.textContent = '◀';
                prevMonthBtn.title = '이전 월';
                prevMonthBtn.onclick = () => {
                    displayedMonthInNav--;
                    if (displayedMonthInNav < 1) { displayedMonthInNav = 12; displayedYearInNav--; }
                    renderViewerWeeklyNavigator();
                };
                const currentMonthSpan = document.createElement('span');
                currentMonthSpan.className = 'current-display-span';
                currentMonthSpan.textContent = \`\${displayedMonthInNav}월\`;
                const nextMonthBtn = document.createElement('button');
                nextMonthBtn.textContent = '▶';
                nextMonthBtn.title = '다음 월';
                nextMonthBtn.onclick = () => {
                    displayedMonthInNav++;
                    if (displayedMonthInNav > 12) { displayedMonthInNav = 1; displayedYearInNav++; }
                    renderViewerWeeklyNavigator();
                };
                monthControls.appendChild(prevMonthBtn);
                monthControls.appendChild(currentMonthSpan);
                monthControls.appendChild(nextMonthBtn);
                navContainer.appendChild(monthControls);
                
                navContainer.style.display = 'flex';
                requestAnimationFrame(adjustViewerPadding);
            }

            function initializeViewerWeeklyNavigator() {
                const pageTitleEl = document.getElementById("page-title");
                const titleText = pageTitleEl ? pageTitleEl.textContent || '' : '';
                const match = titleText.match(/(\\d{2,4})년\\s*(\\d{1,2})월\\s*(\\d{1,2})주차/);

                if (!match) {
                    weeklyNavConfig.enabled = false;
                    const now = new Date();
                    displayedYearInNav = now.getFullYear();
                    displayedMonthInNav = now.getMonth() + 1;
                } else {
                    let year = parseInt(match[1], 10);
                    if (year < 100) year += 2000;
                    documentYear = year;
                    documentMonth = parseInt(match[2], 10);
                    documentWeek = parseInt(match[3], 10);
                    displayedYearInNav = documentYear;
                    displayedMonthInNav = documentMonth;
                }
                renderViewerWeeklyNavigator();
            }

            function getViewerSaveFileName(extension) {
                const pageTitleEl = document.getElementById('page-title');
                if (!pageTitleEl) return \`download.\${extension}\`;
                const titleText = (pageTitleEl.textContent || '').trim();
                const match = titleText.match(/(\\d{2,4})년\\s*(\\d{1,2})월\\s*(\\d{1,2})주차/);
                if (match) {
                    let year = parseInt(match[1], 10);
                    if (year < 100) year += 2000;
                    let month = String(parseInt(match[2], 10)).padStart(2, '0');
                    let week = String(parseInt(match[3], 10)).padStart(2, '0');
                     const filename = weeklyNavConfig.filenameStructureTemplate
                        .replace(/{YYYY}/g, year).replace(/{YY}/g, String(year).slice(-2))
                        .replace(/{MM}/g, month).replace(/{M}/g, parseInt(month, 10))
                        .replace(/{WW}/g, week).replace(/{W}/g, parseInt(week, 10));
                    return filename.substring(filename.lastIndexOf('/') + 1).replace('.html', \`.\${extension}\`);
                }
                const now = new Date();
                const year = now.getFullYear();
                const month = (now.getMonth() + 1).toString().padStart(2, '0');
                const day = now.getDate().toString().padStart(2, '0');
                return \`주간회의_\${year}\${month}\${day}.\${extension}\`;
            }

            function viewerPrintPDF() {
                const app = document.getElementById('appContainer');
                const viewerControls = [
                    document.getElementById('viewer_fullscreenBtn'),
                    document.getElementById('viewer_exitFullscreenBtn'),
                    document.getElementById('viewer_menuToggleBtn'),
                    document.getElementById('viewer_menuPanel'),
                    document.getElementById('viewer_annoToggleBtn'),
                    document.getElementById('time-display-container')
                ];
                const originalDisplays = viewerControls.map(el => el ? getComputedStyle(el).display : null);
                viewerControls.forEach(el => { if(el) el.style.display = 'none'; });

                const pdfOptions = {
                    margin: [5, 5, 5, 5],
                    filename: getViewerSaveFileName('pdf'),
                    image: { type: 'jpeg', quality: 0.98 },
                    html2canvas: {
                        scale: 2, useCORS: true, logging: false, removeContainer: true, scrollY: 0,
                        windowWidth: document.documentElement.scrollWidth, windowHeight: document.documentElement.scrollHeight
                    },
                    jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
                    enableLinks: true
                };
                
                html2pdf().from(app).set(pdfOptions).save().finally(() => {
                    viewerControls.forEach((el, i) => { if(el) el.style.display = originalDisplays[i] || ''; });
                });
            }

            document.addEventListener('DOMContentLoaded', () => {
                const viewerStartTime = new Date(); // 저장된 파일이 열린 시간 기준
                initializeTimeAndDateFeature(viewerStartTime);

                const app = document.getElementById('appContainer');
                const menuToggle = document.getElementById('viewer_menuToggleBtn');
                const menuPanel = document.getElementById('viewer_menuPanel');
                const closeMenu = document.getElementById('viewer_closeMenuBtn');
                const printBtn = document.getElementById('viewer_printPdfBtn');
                const fsBtn = document.getElementById('viewer_fullscreenBtn');
                const exitFsBtn = document.getElementById('viewer_exitFullscreenBtn');
                const annoToggleBtn = document.getElementById('viewer_annoToggleBtn');
                const annoImg = document.getElementById('annotationCanvasImage');
                const memos = document.querySelectorAll('.text-annotation-memo');

                fsBtn.addEventListener('click', () => app.requestFullscreen().catch(console.error));
                exitFsBtn.addEventListener('click', () => document.exitFullscreen().catch(console.error));
                printBtn.addEventListener('click', viewerPrintPDF);
                
                menuToggle.addEventListener('click', () => {
                    const isHidden = menuPanel.style.display === 'none';
                    menuPanel.style.display = isHidden ? 'block' : 'none';
                    menuToggle.innerHTML = isHidden ? '✕' : '☰';
                });
                closeMenu.addEventListener('click', () => {
                    menuPanel.style.display = 'none';
                    menuToggle.innerHTML = '☰';
                });

                if (annoImg || memos.length > 0) {
                    annoToggleBtn.style.display = 'block';
                    let areAnnotationsVisible = true;
                    if(annoImg || memos.length > 0) annoToggleBtn.classList.add('active');

                    annoToggleBtn.addEventListener('click', () => {
                        areAnnotationsVisible = !areAnnotationsVisible;
                        if (annoImg) annoImg.style.display = areAnnotationsVisible ? 'block' : 'none';
                        memos.forEach(memo => memo.style.display = areAnnotationsVisible ? 'block' : 'none');
                        annoToggleBtn.classList.toggle('active', areAnnotationsVisible);
                    });
                } else {
                    annoToggleBtn.style.display = 'none';
                }

                document.addEventListener('fullscreenchange', () => {
                    const isFs = !!document.fullscreenElement;
                    document.body.classList.toggle('true-fullscreen-active', isFs);
                    if(menuToggle) menuToggle.style.display = isFs ? 'none' : 'block';
                    if(fsBtn) fsBtn.style.display = isFs ? 'none' : 'block';
                    if(exitFsBtn) exitFsBtn.style.display = isFs ? 'block' : 'none';
                    if (annoToggleBtn) annoToggleBtn.style.display = isFs && (annoImg || memos.length > 0) ? 'block' : 'none';
                    adjustViewerPadding();
                });
                
                initializeViewerWeeklyNavigator();

                if (document.fonts) {
                    document.fonts.ready.then(() => requestAnimationFrame(adjustViewerPadding));
                } else {
                    adjustViewerPadding();
                }
                window.addEventListener('resize', adjustViewerPadding);
                
                window.addEventListener('mousemove', resetIdleTimer);
                window.addEventListener('mousedown', resetIdleTimer);
                window.addEventListener('touchstart', resetIdleTimer);
                window.addEventListener('scroll', handleScrollForIdleReset, true);
                window.addEventListener('keydown', resetIdleTimer);
                resetIdleTimer();
            });
        })();
    `;
    doc.body.appendChild(viewerScript);

    const htmlOutput = `<!DOCTYPE html>\n${doc.documentElement.outerHTML}`;

    const blob = new Blob([htmlOutput], { type: "text/html;charset=utf-8" });
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = getSaveFileName('html');
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(a.href);
    showMessage("HTML 파일이 뷰어 모드로 저장되었습니다.", "success");
}


function printPDF() {
    if(currentlyActiveItemControlsElement) activateControls(null);
    hideElementStyleControls();
    clearMultiZoomSelectionVisuals(); elementsForMultiZoom = [];

    showMessage("PDF 생성 준비 중...", "success", 4000);

    const elementsToHide = [
        floatingMenuToggleBtn, trueFullscreenBtn, multiZoomTriggerBtn, menuPanel,
        selectionZoomOverlay, exitTrueFullscreenBtnActual, 
        annotationDisplayToggleBtn, annotationSettingsToggleBtn, annotationSettingsPanel, memoAnnotationToggleBtn,
        document.getElementById('time-display-container')
    ];
    const originalDisplays = elementsToHide.map(el => el ? el.style.display : null);
    elementsToHide.forEach(el => { if(el) el.style.display = 'none'; });
    document.querySelectorAll('.item-controls').forEach(ctrl => ctrl.style.display = 'none');
    
    const navContainer = document.getElementById('weeklyNavigatorContainer');
    const originalNavNodes = []; 

    if (navContainer) {
        const clickableLinks = navContainer.querySelectorAll('.week-link.active');
        clickableLinks.forEach(span => {
            const weekText = span.textContent; 
            const weekMatch = weekText.match(/(\d+)/);
            if (!weekMatch) return;
            const w = parseInt(weekMatch[1], 10);

            const now = new Date();
            const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
            const firstDayOfMonth = new Date(displayedYearInNav, displayedMonthInNav - 1, 1).getDay();
            const linkDate = new Date(displayedYearInNav, displayedMonthInNav - 1, (w - 1) * 7 + 1 - firstDayOfMonth);
            
            let pathTemplate = (linkDate < today) 
                ? weeklyNavigatorConfig.pastFilenameStructureTemplate 
                : weeklyNavigatorConfig.filenameStructureTemplate;

            const url = (weeklyNavigatorConfig.baseURL || '') + pathTemplate
                .replace(/{YYYY}/g, displayedYearInNav)
                .replace(/{YY}/g, String(displayedYearInNav).slice(-2))
                .replace(/{MM}/g, String(displayedMonthInNav).padStart(2, '0'))
                .replace(/{M}/g, displayedMonthInNav)
                .replace(/{WW}/g, String(w).padStart(2, '0'))
                .replace(/{W}/g, w);

            const anchor = document.createElement('a');
            anchor.href = url;
            anchor.target = '_blank';
            anchor.className = span.className;
            anchor.style.cssText = span.style.cssText;
            anchor.textContent = span.textContent;
            anchor.style.cursor = 'pointer';

            originalNavNodes.push({
                parent: span.parentNode,
                original: span,
                replacement: anchor
            });
            span.parentNode.replaceChild(anchor, span);
        });
    }

    let tempImgForPrint = null;
    if (annotationCanvas.width > 0 && annotationCanvas.height > 0 && (isDrawingFeatureActive || (keepDrawingsVisibleOnDeactivate && drawnStrokes.length > 0))) {
        try {
            const dataUrl = annotationCanvas.toDataURL('image/png');
            if (dataUrl !== 'data:,') {
                tempImgForPrint = document.createElement('img');
                tempImgForPrint.src = dataUrl;
                Object.assign(tempImgForPrint.style, {
                    position: 'absolute', top: annotationCanvas.offsetTop + 'px', left: annotationCanvas.offsetLeft + 'px',
                    width: annotationCanvas.width + 'px', height: annotationCanvas.height + 'px',
                    zIndex: '4', pointerEvents: 'none', display: 'block'
                });
                contentArea.appendChild(tempImgForPrint);
            }
        } catch (e) { console.error("Error generating annotation image for PDF:", e); }
    }
    const originalCanvasDisplay = annotationCanvas.style.display;
    if(annotationCanvas) annotationCanvas.style.display = 'none';

    const navBar = document.getElementById('weeklyNavigatorContainer');
    const originalNavBarPosition = navBar ? navBar.style.position : null;
    const originalPageTitlePosition = pageTitle.style.position;
    
    if (navBar) navBar.style.position = 'relative';
    pageTitle.style.position = 'relative';

    const titleHeight = pageTitle.offsetHeight;
    contentArea.style.paddingTop = `${titleHeight + 15}px`;

    window.scrollTo(0, 0);

    const pdfOptions = {
        margin: [5, 5, 5, 5],
        filename: getSaveFileName('pdf'),
        image: { type: 'jpeg', quality: 0.98 },
        html2canvas: {
            scale: 2, useCORS: true, logging: false, removeContainer: true, scrollY: -window.scrollY,
            windowWidth: document.documentElement.scrollWidth, windowHeight: document.documentElement.scrollHeight,
            ignoreElements: (element) => element.id === 'customMessageBox'
        },
        jsPDF: { unit: 'mm', format: 'a4', orientation: 'landscape' },
        enableLinks: true
    };

    setTimeout(() => {
        html2pdf().from(appContainer).set(pdfOptions).save()
        .then(() => { showMessage("PDF 생성이 완료되었습니다.", "success"); })
        .catch(err => { console.error("PDF 생성 오류:", err); showMessage("PDF 생성 중 오류가 발생했습니다.", "error"); })
        .finally(() => {
            if (tempImgForPrint && contentArea.contains(tempImgForPrint)) contentArea.removeChild(tempImgForPrint);
            if(annotationCanvas) annotationCanvas.style.display = originalCanvasDisplay;
            elementsToHide.forEach((el, i) => { if(el) el.style.display = originalDisplays[i] || ''; });
            const checkedMode = document.querySelector('input[name="editIconsMode"]:checked');
            if(checkedMode) toggleEditIconsVisibility(checkedMode.value);
            
            pageTitle.style.position = originalPageTitlePosition;
            if (navBar) navBar.style.position = originalNavBarPosition;
            
            originalNavNodes.forEach(item => {
                item.parent.replaceChild(item.original, item.replacement);
            });
            
            adjustContainerPadding();
            fullscreenChangeHandler();
        });
    }, 300);
}

function toggleEditIconsVisibility(mode) {
    if(!mode) return;
    localStorage.setItem('editIconsMode', mode);
    document.body.classList.remove('show-icons-all', 'show-icons-selected');
    if (mode === 'all') document.body.classList.add('show-icons-all');
    else if (mode === 'selected') document.body.classList.add('show-icons-selected');
}

function updateAnnotationDisplayToggleBtnStyle() {
  if (!annotationDisplayToggleBtn) return;
  annotationDisplayToggleBtn.classList.toggle('active', isDrawingFeatureActive);
  annotationDisplayToggleBtn.title = isDrawingFeatureActive ? "주석 끄기" : "주석 켜기";
  const shouldBeVisible = isDrawingFeatureActive || (keepDrawingsVisibleOnDeactivate && drawnStrokes.length > 0);
  annotationCanvas.style.display = shouldBeVisible ? 'block' : 'none';
}

function loadPanelUIWithSettings(settings) {
  [annoToolPenBtn, annoToolHighlighterBtn, annoToolCircleBtn, annoToolEllipseBtn, annoToolOrthoLineBtn, annoToolEraserBtn].forEach(btn => {
      if(btn) btn.classList.remove('tool-active');
  });
  const activeBtn = document.querySelector(`#annotationSettingsPanel button[data-tool="${settings.tool}"]`);
  if (activeBtn) activeBtn.classList.add('tool-active');

  if (settings.tool === 'highlighter') {
      annoColorPicker.value = settings.highlighterColor;
      annoLineWidthSlider.value = settings.highlighterLineWidth;
      annoHighlighterOpacitySlider.value = settings.highlighterOpacity;
      if(annoHighlighterOpacityContainer) annoHighlighterOpacityContainer.style.display = 'flex';
  } else if (['pen', 'circle', 'ellipse', 'orthoLine'].includes(settings.tool)) {
      annoColorPicker.value = settings.penColor;
      annoLineWidthSlider.value = settings.penLineWidth;
      if(annoHighlighterOpacityContainer) annoHighlighterOpacityContainer.style.display = 'none';
  } else {
      annoLineWidthSlider.value = settings.penLineWidth;
      if(annoHighlighterOpacityContainer) annoHighlighterOpacityContainer.style.display = 'none';
  }
}

function applySettingsToContext(settings) {
  if (!annotationCtx) return;
  annotationCtx.globalCompositeOperation = 'source-over';

  if (settings.tool === 'highlighter') {
      annotationCtx.strokeStyle = settings.highlighterColor;
      annotationCtx.lineWidth = settings.highlighterLineWidth;
      annotationCtx.globalAlpha = 1.0 - parseFloat(settings.highlighterOpacity);
  } else if (['pen', 'circle', 'ellipse', 'orthoLine'].includes(settings.tool)) {
      annotationCtx.strokeStyle = settings.penColor;
      annotationCtx.lineWidth = settings.penLineWidth;
      annotationCtx.globalAlpha = 1.0;
  } else if (settings.tool === 'eraser') {
      annotationCtx.lineWidth = settings.penLineWidth;
      annotationCtx.globalAlpha = 1.0;
  }
}

function setAnnotationDefaults() {
  // --- [MODIFIED] 주석 기본값을 '직각선', '빨간색'으로 변경 ---
  drawingSettings = {
      tool: 'orthoLine', penColor: '#FF0000', penLineWidth: '5',
      highlighterColor: '#FFFFE0', highlighterLineWidth: '20', highlighterOpacity: '0.3',
  };
  panelUISettings = { ...drawingSettings };
  if(annoKeepDrawingsVisibleCheckbox) keepDrawingsVisibleOnDeactivate = annoKeepDrawingsVisibleCheckbox.checked;
  if(menuAnnoKeepDrawingsVisible) menuAnnoKeepDrawingsVisible.checked = keepDrawingsVisibleOnDeactivate;
  if(annoHighlighterOpacitySlider) annoHighlighterOpacitySlider.value = drawingSettings.highlighterOpacity;
}

function redrawAllStrokes() {
  if (!annotationCtx || !annotationCanvas) return;
  annotationCtx.clearRect(0, 0, annotationCanvas.width, annotationCanvas.height);
  drawnStrokes.forEach(stroke => {
      annotationCtx.beginPath();
      annotationCtx.lineWidth = stroke.lineWidth;
      annotationCtx.strokeStyle = stroke.color;
      annotationCtx.globalAlpha = stroke.opacity;
      annotationCtx.globalCompositeOperation = 'source-over';

      if (stroke.type === 'path' || stroke.type === 'line') {
          annotationCtx.moveTo(stroke.points[0].x, stroke.points[0].y);
          for (let i = 1; i < stroke.points.length; i++) {
              annotationCtx.lineTo(stroke.points[i].x, stroke.points[i].y);
          }
          annotationCtx.stroke();
      } else if (stroke.type === 'circle') {
          annotationCtx.arc(stroke.x, stroke.y, stroke.radius, 0, Math.PI * 2);
          annotationCtx.stroke();
      } else if (stroke.type === 'ellipse') {
          annotationCtx.ellipse(stroke.x, stroke.y, stroke.radiusX, stroke.radiusY, 0, 0, Math.PI * 2);
          annotationCtx.stroke();
      }
  });
  applySettingsToContext(drawingSettings);
}

function setupAnnotationCanvas() {
  if (!contentArea || !annotationCanvas) return;
  const newWidth = contentArea.scrollWidth;
  const newHeight = contentArea.scrollHeight;

  if (annotationCanvas.width !== newWidth || annotationCanvas.height !== newHeight) {
      annotationCanvas.width = newWidth;
      annotationCanvas.height = newHeight;
  }
  annotationCtx = annotationCanvas.getContext('2d');
  annotationCtx.lineCap = 'round';
  annotationCtx.lineJoin = 'round';
  redrawAllStrokes();
  applySettingsToContext(drawingSettings);
}

function getAnnotationMousePos(event) {
  const rect = annotationCanvas.getBoundingClientRect();
  const scaleX = annotationCanvas.width / rect.width;
  const scaleY = annotationCanvas.height / rect.height;
  let clientX = event.clientX;
  let clientY = event.clientY;
  if (event.touches && event.touches.length > 0) {
      clientX = event.touches[0].clientX;
      clientY = event.touches[0].clientY;
  }
  return {
      x: (clientX - rect.left) * scaleX,
      y: (clientY - rect.top) * scaleY
  };
}

function startAnnotationDrawing(e) {
  if (!isDrawingFeatureActive || (e.button !== undefined && e.button !== 0) ) return;
  if(isDrawingFeatureActive) e.preventDefault();
  if (isMemoModeActive) return;

  const pos = getAnnotationMousePos(e);

  if (drawingSettings.tool === 'eraser') {
      eraseStrokeAtPoint(pos);
      isDrawingAnnotation = false;
      return;
  }

  applySettingsToContext(drawingSettings);
  isDrawingAnnotation = true;
  shapeStartX = pos.x;
  shapeStartY = pos.y;
  lastAnnotationX = pos.x;
  lastAnnotationY = pos.y;

  if (drawingSettings.tool === 'orthoLine' || drawingSettings.tool === 'circle' || drawingSettings.tool === 'ellipse' || (isShiftKeyDown && (drawingSettings.tool === 'pen' || drawingSettings.tool === 'highlighter'))) {
      if (annotationCanvas.width > 0 && annotationCanvas.height > 0) {
          previewImageData = annotationCtx.getImageData(0, 0, annotationCanvas.width, annotationCanvas.height);
      } else { previewImageData = null;}
      currentStroke = null;
  } else if (drawingSettings.tool === 'pen' || drawingSettings.tool === 'highlighter') {
      annotationCtx.beginPath();
      annotationCtx.moveTo(pos.x, pos.y);
      currentStroke = {
          type: 'path', tool: drawingSettings.tool,
          color: drawingSettings.tool === 'highlighter' ? drawingSettings.highlighterColor : drawingSettings.penColor,
          lineWidth: drawingSettings.tool === 'highlighter' ? drawingSettings.highlighterLineWidth : drawingSettings.penLineWidth,
          opacity: drawingSettings.tool === 'highlighter' ? (1.0 - parseFloat(drawingSettings.highlighterOpacity)) : 1.0,
          points: [pos]
      };
  }
}

function drawAnnotation(e) {
  if (!isDrawingAnnotation || !isDrawingFeatureActive ) return;
  if (isMemoModeActive || drawingSettings.tool === 'eraser') return;
  if(isDrawingFeatureActive) e.preventDefault();
  const pos = getAnnotationMousePos(e);

  if (previewImageData) annotationCtx.putImageData(previewImageData, 0, 0);
  applySettingsToContext(drawingSettings);
  annotationCtx.beginPath();

  if ((isShiftKeyDown && (drawingSettings.tool === 'pen' || drawingSettings.tool === 'highlighter')) || drawingSettings.tool === 'orthoLine') {
      let endX = pos.x;
      let endY = pos.y;
      if (drawingSettings.tool === 'orthoLine') {
          if (Math.abs(pos.x - shapeStartX) > Math.abs(pos.y - shapeStartY)) { endY = shapeStartY; }
          else { endX = shapeStartX; }
      }
      annotationCtx.moveTo(shapeStartX, shapeStartY);
      annotationCtx.lineTo(endX, endY);
  } else if (drawingSettings.tool === 'circle') {
      const radius = Math.sqrt(Math.pow(pos.x - shapeStartX, 2) + Math.pow(pos.y - shapeStartY, 2));
      annotationCtx.arc(shapeStartX, shapeStartY, radius, 0, Math.PI * 2);
  } else if (drawingSettings.tool === 'ellipse') {
      const radiusX = Math.abs(pos.x - shapeStartX) / 2;
      const radiusY = Math.abs(pos.y - shapeStartY) / 2;
      const centerX = shapeStartX + (pos.x - shapeStartX) / 2;
      const centerY = shapeStartY + (pos.y - shapeStartY) / 2;
      annotationCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
  } else {
      if (!currentStroke) return;
      annotationCtx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
      for(let i = 1; i < currentStroke.points.length; i++) {
          annotationCtx.lineTo(currentStroke.points[i].x, currentStroke.points[i].y);
      }
      annotationCtx.lineTo(pos.x, pos.y);
  }
  annotationCtx.stroke();

  if (!isShiftKeyDown && !['circle', 'ellipse', 'orthoLine'].includes(drawingSettings.tool) && currentStroke) {
      currentStroke.points.push(pos);
  }

  lastAnnotationX = pos.x;
  lastAnnotationY = pos.y;
}

function stopAnnotationDrawing(e) {
  if (!isDrawingAnnotation) return;
  if (isMemoModeActive || drawingSettings.tool === 'eraser') {
      isDrawingAnnotation = false;
      currentStroke = null;
      previewImageData = null;
      return;
  }
  if(isDrawingFeatureActive) e.preventDefault();

  const pos = getAnnotationMousePos(e);
  if (previewImageData) {
      annotationCtx.putImageData(previewImageData, 0, 0);
      previewImageData = null;
  }
  applySettingsToContext(drawingSettings);
  annotationCtx.beginPath();

  let newStroke = null;
  
  if (drawingSettings.tool === 'orthoLine' || (isShiftKeyDown && (drawingSettings.tool === 'pen' || drawingSettings.tool === 'highlighter'))) {
      let endX = pos.x, endY = pos.y;
      if (drawingSettings.tool === 'orthoLine') {
          if (Math.abs(pos.x - shapeStartX) > Math.abs(pos.y - shapeStartY)) { endY = shapeStartY; } else { endX = shapeStartX; }
      }
      annotationCtx.moveTo(shapeStartX, shapeStartY);
      annotationCtx.lineTo(endX, endY);
      newStroke = { type: 'line', tool: drawingSettings.tool, points: [{x: shapeStartX, y: shapeStartY}, {x: endX, y: endY}] };
  } else if (drawingSettings.tool === 'circle') {
      const radius = Math.sqrt(Math.pow(pos.x - shapeStartX, 2) + Math.pow(pos.y - shapeStartY, 2));
      if (radius > 0.1) {
          annotationCtx.arc(shapeStartX, shapeStartY, radius, 0, Math.PI * 2);
          newStroke = { type: 'circle', tool: drawingSettings.tool, x: shapeStartX, y: shapeStartY, radius: radius };
      }
  } else if (drawingSettings.tool === 'ellipse') {
      const radiusX = Math.abs(pos.x - shapeStartX) / 2;
      const radiusY = Math.abs(pos.y - shapeStartY) / 2;
      if (radiusX > 0.1 && radiusY > 0.1) {
          const centerX = shapeStartX + (pos.x - shapeStartX) / 2;
          const centerY = shapeStartY + (pos.y - shapeStartY) / 2;
          annotationCtx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, Math.PI * 2);
          newStroke = { type: 'ellipse', tool: drawingSettings.tool, x: centerX, y: centerY, radiusX: radiusX, radiusY: radiusY };
      }
  } else if (currentStroke && currentStroke.points.length > 0) {
       currentStroke.points.push(pos);
       annotationCtx.moveTo(currentStroke.points[0].x, currentStroke.points[0].y);
       for(let i=1; i < currentStroke.points.length; i++) {
          annotationCtx.lineTo(currentStroke.points[i].x, currentStroke.points[i].y);
       }
       newStroke = { ...currentStroke };
  }

  if (newStroke) {
      newStroke.color = drawingSettings.tool === 'highlighter' ? drawingSettings.highlighterColor : drawingSettings.penColor;
      newStroke.lineWidth = drawingSettings.tool === 'highlighter' ? drawingSettings.highlighterLineWidth : drawingSettings.penLineWidth;
      newStroke.opacity = drawingSettings.tool === 'highlighter' ? (1.0 - parseFloat(drawingSettings.highlighterOpacity)) : 1.0;
      drawnStrokes.push(newStroke);
      annotationCtx.stroke();
  }

  isDrawingAnnotation = false;
  currentStroke = null;
}

function distToSegmentSquared(p, v, w) {
  const l2 = (v.x - w.x)**2 + (v.y - w.y)**2;
  if (l2 === 0) return (p.x - v.x)**2 + (p.y - v.y)**2;
  let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
  t = Math.max(0, Math.min(1, t));
  const closestX = v.x + t * (w.x - v.x);
  const closestY = v.y + t * (w.y - v.y);
  return (p.x - closestX)**2 + (p.y - closestY)**2;
}

function eraseStrokeAtPoint(clickPos) {
  let erased = false;
  const clickTolerance = 10;

  for (let i = drawnStrokes.length - 1; i >= 0; i--) {
      const stroke = drawnStrokes[i];
      const strokeWidth = parseFloat(stroke.lineWidth || drawingSettings.penLineWidth);
      const tolerance = (strokeWidth / 2) + clickTolerance;
      let hit = false;
      if (stroke.type === 'path' || stroke.type === 'line') {
          for (let j = 0; j < stroke.points.length - 1; j++) {
              if (distToSegmentSquared(clickPos, stroke.points[j], stroke.points[j+1]) < tolerance**2) { hit = true; break; }
          }
          if (!hit && stroke.points.length === 1) { if (distToSegmentSquared(clickPos, stroke.points[0], stroke.points[0]) < tolerance**2) hit = true; }
      } else if (stroke.type === 'circle') {
          const dist = Math.sqrt(Math.pow(clickPos.x - stroke.x, 2) + Math.pow(clickPos.y - stroke.y, 2));
          if (Math.abs(dist - stroke.radius) < tolerance ) hit = true;
      } else if (stroke.type === 'ellipse') {
          const dx = clickPos.x - stroke.x, dy = clickPos.y - stroke.y;
          if ((dx**2 / (stroke.radiusX + tolerance)**2) + (dy**2 / (stroke.radiusY + tolerance)**2) <= 1) hit = true;
      }
      if (hit) {
          drawnStrokes.splice(i, 1);
          erased = true;
          break;
      }
  }
  if (erased) {
      redrawAllStrokes();
      updateAnnotationDisplayToggleBtnStyle();
      showMessage("주석이 삭제되었습니다.", "success", 1000);
  }
}

function toggleDrawingFeature() {
    if (isMemoModeActive) { toggleMemoMode(); }
    isDrawingFeatureActive = !isDrawingFeatureActive;
    updateAnnotationDisplayToggleBtnStyle();
    if (isDrawingFeatureActive) {
        annotationCanvas.style.pointerEvents = 'auto';
        showMessage("주석 그리기 활성화됨.", "success", 1500);
    } else {
        annotationCanvas.style.pointerEvents = 'none';
        if (isAnnotationPanelOpen) { toggleAnnotationSettingsPanel(); }
        showMessage("주석 그리기 비활성화됨.", "success", 1500);
    }
}

function toggleAnnotationSettingsPanel() {
    if (!isDrawingFeatureActive) {
        showMessage("주석 그리기를 먼저 켜주세요 (👁️ 아이콘).", "warning"); return;
    }
    isAnnotationPanelOpen = !isAnnotationPanelOpen;
    annotationSettingsPanel.style.display = isAnnotationPanelOpen ? 'flex' : 'none';
    annotationSettingsToggleBtn.classList.toggle('active', isAnnotationPanelOpen);
    if(menuAnnoSettingsPanelToggle) menuAnnoSettingsPanelToggle.classList.toggle('active', isAnnotationPanelOpen);

    if (isAnnotationPanelOpen) {
        panelUISettings = { ...drawingSettings };
        loadPanelUIWithSettings(panelUISettings);
    } else {
        drawingSettings = { ...panelUISettings };
        applySettingsToContext(drawingSettings);
    }
}

function handleAnnotationToolClick(e) {
  const newTool = e.target.closest('button').dataset.tool;
  if (newTool === 'eraser') {
      panelUISettings.tool = (panelUISettings.tool === 'eraser') ? 'pen' : 'eraser';
  } else {
      panelUISettings.tool = newTool;
  }
  loadPanelUIWithSettings(panelUISettings);
  applySettingsToContext(panelUISettings);
}

function handleCloseAnnotationSettings() {
  drawingSettings = { ...panelUISettings };
  applySettingsToContext(drawingSettings);
  isAnnotationPanelOpen = false;
  annotationSettingsPanel.style.display = 'none';
  annotationSettingsToggleBtn.classList.remove('active');
  if(menuAnnoSettingsPanelToggle) menuAnnoSettingsPanelToggle.classList.remove('active');
  showMessage("주석 설정 적용됨.", "success", 1500);
}

function handleMenuKeepDrawingsToggle(isChecked) {
  keepDrawingsVisibleOnDeactivate = isChecked;
  if(annoKeepDrawingsVisibleCheckbox) annoKeepDrawingsVisibleCheckbox.checked = keepDrawingsVisibleOnDeactivate;
  if (!isDrawingFeatureActive) updateAnnotationDisplayToggleBtnStyle();
}

function handleClearCanvasClick() {
  if (!isDrawingFeatureActive) { showMessage("주석 그리기 기능이 활성화되어야 합니다.", "warning"); return; }
  drawnStrokes = [];
  redrawAllStrokes();
  updateAnnotationDisplayToggleBtnStyle();
  showMessage("모든 주석이 삭제되었습니다.", "success", 1500);
}

function handleMemoToggleClick() {
  if (!document.body.classList.contains('true-fullscreen-active')) {
      showMessage("메모 추가는 전체 화면 모드에서 사용 가능합니다.", "warning"); return;
  }
  toggleMemoMode();
}

function handleMenuMemoToggleClick() {
  handleMemoToggleClick();
  if(menuPanel.style.display === "block") togglePanel();
}

function toggleMemoMode() {
    isMemoModeActive = !isMemoModeActive;
    memoAnnotationToggleBtn.classList.toggle('active', isMemoModeActive);
    if(menuMemoAnnotationBtn) menuMemoAnnotationBtn.classList.toggle('active', isMemoModeActive);
    contentArea.style.cursor = isMemoModeActive ? 'copy' : 'auto';

    if (isMemoModeActive) {
        if (isDrawingFeatureActive) toggleDrawingFeature();
        showMessage("메모 추가 모드 활성화. 내용을 클릭하여 메모를 추가하세요.", "success", 2500);
    } else {
        showMessage("메모 추가 모드 비활성화.", "success", 1500);
    }
}

function createMemoAnnotation(x, y) {
  const memoDiv = document.createElement('div');
  memoDiv.className = 'text-annotation-memo';
  memoDiv.setAttribute('contenteditable', 'true');
  memoDiv.style.left = Math.max(0, x - 10) + 'px';
  memoDiv.style.top = Math.max(0, y - 10) + 'px';
  memoDiv.textContent = '메모 입력...';

  const deleteBtn = document.createElement('span');
  deleteBtn.innerHTML = '&times;';
  deleteBtn.className = 'memo-delete-btn';
  deleteBtn.title = '메모 삭제';
  memoDiv.appendChild(deleteBtn);

  contentArea.appendChild(memoDiv);
  makeMemoDraggable(memoDiv);
  setTimeout(() => {
      memoDiv.focus();
      const selection = window.getSelection();
      const range = document.createRange();
      if (memoDiv.firstChild && memoDiv.firstChild.nodeType === Node.TEXT_NODE) {
          range.selectNodeContents(memoDiv.firstChild);
          selection.removeAllRanges();
          selection.addRange(range);
      }
  }, 0);
}

function makeMemoDraggable(memoElement) {
  let currentX, currentY, initialMouseX, initialMouseY, isDraggingMemo = false;
  memoElement.addEventListener('mousedown', (e) => {
      if (e.target.closest('.memo-delete-btn') || memoElement.contains(document.activeElement) && document.activeElement.isContentEditable) return;
      isDraggingMemo = true;
      memoElement.style.cursor = 'grabbing';
      currentX = memoElement.offsetLeft;
      currentY = memoElement.offsetTop;
      initialMouseX = e.clientX;
      initialMouseY = e.clientY;
      document.addEventListener('mousemove', onMemoDrag);
      document.addEventListener('mouseup', onMemoDragEnd);
      e.stopPropagation();
  });
  function onMemoDrag(e) {
      if (!isDraggingMemo) return;
      e.preventDefault();
      let newLeft = currentX + (e.clientX - initialMouseX);
      let newTop = currentY + (e.clientY - initialMouseY);
      newLeft = Math.max(0, Math.min(newLeft, contentArea.scrollWidth - memoElement.offsetWidth));
      newTop = Math.max(0, Math.min(newTop, contentArea.scrollHeight - memoElement.offsetHeight));
      memoElement.style.left = newLeft + 'px';
      memoElement.style.top = newTop + 'px';
  }
  function onMemoDragEnd() {
      if (!isDraggingMemo) return;
      isDraggingMemo = false;
      memoElement.style.cursor = 'move';
      document.removeEventListener('mousemove', onMemoDrag);
      document.removeEventListener('mouseup', onMemoDragEnd);
  }
}

function initializeEventListeners() {
  exitTrueFullscreenBtnActual.addEventListener('click', exitTrueFullscreen);
  trueFullscreenBtn.addEventListener('click', toggleTrueFullscreen);
  document.addEventListener('fullscreenchange', fullscreenChangeHandler);
  document.addEventListener('webkitfullscreenchange', fullscreenChangeHandler);
  document.addEventListener('mozfullscreenchange', fullscreenChangeHandler);
  document.addEventListener('MSFullscreenChange', fullscreenChangeHandler);
  floatingMenuToggleBtn.addEventListener('click', togglePanel);
  closeMenuPanelBtn.addEventListener('click', handleCloseMenuPanel);
  menuPanel.addEventListener('mousedown', handlePanelDragStart);
  document.addEventListener('mousemove', handlePanelDragMove);
  document.addEventListener('mouseup', handlePanelDragEnd);
  annotationSettingsPanel.addEventListener('mousedown', handlePanelDragStart);
  multiZoomTriggerBtn.addEventListener('click', handleMultiZoomTrigger);
  selectionZoomOverlay.addEventListener('click', handleSelectionZoomOverlayClick);
  const closeZoomBtn = document.getElementById('closeSelectionZoomBtn');
  if (closeZoomBtn) closeZoomBtn.addEventListener('click', closeSelectionZoom);
  appContainer.addEventListener('click', handleAppContainerClick);
  document.addEventListener('click', handleDocumentClick);
  document.addEventListener('keydown', handleKeyDown);
  document.addEventListener('keyup', handleKeyUp);
  window.addEventListener('blur', () => {
      document.body.classList.remove('ctrl-pressed');
      isShiftKeyDown = false;
  });
  document.querySelectorAll('input[name="editIconsMode"]').forEach(radio => radio.addEventListener('change', (e) => toggleEditIconsVisibility(e.target.value)));
  document.getElementById('applyLinkBtn').addEventListener('click', applyLink);
  document.getElementById('removeLinkBtn').addEventListener('click', removeLink);
  document.getElementById('applyBoldBtn').addEventListener('click', applyBold);
  document.getElementById('applyItalicBtn').addEventListener('click', applyItalic);
  document.getElementById('applyUnderlineBtn').addEventListener('click', applyUnderline);
  document.getElementById('applyStrikethroughBtn').addEventListener('click', applyStrikethrough);
  document.getElementById('applySuperscriptBtn').addEventListener('click', applySuperscript);
  document.getElementById('applySubscriptBtn').addEventListener('click', applySubscript);
  document.getElementById('fontSizeSelector').addEventListener('change', (e) => changeFontSize(e.target.value));
  document.getElementById('fontColorSelector').addEventListener('input', (e) => changeFontColor(e.target.value));
  document.getElementById('backColorSelector').addEventListener('input', (e) => changeBackColor(e.target.value));
  document.getElementById('emojiDropdownBtn').addEventListener('click', toggleEmojiPalette);
  document.getElementById('emojiPalette').addEventListener('click', (e) => {
      const btn = e.target.closest('.emoji-btn');
      if (btn) insertCharacter(btn.textContent);
  });
  document.addEventListener('click', (e) => {
      const palette = document.getElementById('emojiPalette');
      const dropdown = document.querySelector('.emoji-dropdown');
      if (palette && dropdown && !dropdown.contains(e.target) && palette.classList.contains('show')) {
          palette.classList.remove('show');
      }
  });
  document.getElementById('insertCharFromInputBtn').addEventListener('click', insertCharacterFromInput);
  document.getElementById('saveHtmlBtn').addEventListener('click', saveHTML);
  document.getElementById('printPdfBtn').addEventListener('click', printPDF);
  document.getElementById('elementBgColor').addEventListener('input', (e) => applySelectedElementStyle('backgroundColor', e.target.value));
  document.getElementById('elementTextColor').addEventListener('input', (e) => applySelectedElementStyle('color', e.target.value));
  document.getElementById('elementBorderRadius').addEventListener('input', (e) => applySelectedElementStyle('borderRadius', e.target.value + 'px'));
  document.getElementById('elementShapeSelector').addEventListener('change', (e) => applySelectedElementShape(e.target.value));
  annotationDisplayToggleBtn.addEventListener('click', toggleDrawingFeature);
  annotationSettingsToggleBtn.addEventListener('click', toggleAnnotationSettingsPanel);
  memoAnnotationToggleBtn.addEventListener('click', handleMemoToggleClick);
  closeAnnotationSettingsBtn.addEventListener('click', handleCloseAnnotationSettings);
  annoColorPicker.addEventListener('input', (e) => {
    if (panelUISettings.tool === 'highlighter') panelUISettings.highlighterColor = e.target.value;
    else panelUISettings.penColor = e.target.value;
    applySettingsToContext(panelUISettings);
  });
  annoLineWidthSlider.addEventListener('input', (e) => {
      const newWidth = e.target.value;
      if (panelUISettings.tool === 'highlighter') panelUISettings.highlighterLineWidth = newWidth;
      else if (['pen', 'circle', 'ellipse', 'orthoLine', 'eraser'].includes(panelUISettings.tool)) panelUISettings.penLineWidth = newWidth;
      applySettingsToContext(panelUISettings);
  });
  annoHighlighterOpacitySlider.addEventListener('input', (e) => {
      panelUISettings.highlighterOpacity = e.target.value;
      applySettingsToContext(panelUISettings);
  });
  annoKeepDrawingsVisibleCheckbox.addEventListener('change', (e) => handleMenuKeepDrawingsToggle(e.target.checked));
  annoClearCanvasBtn.addEventListener('click', handleClearCanvasClick);
  [annoToolPenBtn, annoToolHighlighterBtn, annoToolCircleBtn, annoToolEllipseBtn, annoToolOrthoLineBtn, annoToolEraserBtn].forEach(btn => {
      if (btn) btn.addEventListener('click', handleAnnotationToolClick);
  });
  menuAnnoKeepDrawingsVisible.addEventListener('change', (e) => handleMenuKeepDrawingsToggle(e.target.checked));
  menuAnnoDrawingToggle.addEventListener('click', toggleDrawingFeature);
  menuAnnoSettingsPanelToggle.addEventListener('click', toggleAnnotationSettingsPanel);
  menuMemoAnnotationBtn.addEventListener('click', handleMenuMemoToggleClick);
  annotationCanvas.addEventListener('mousedown', startAnnotationDrawing);
  annotationCanvas.addEventListener('mousemove', drawAnnotation);
  annotationCanvas.addEventListener('mouseup', stopAnnotationDrawing);
  annotationCanvas.addEventListener('mouseout', (e) => { if (isDrawingAnnotation) stopAnnotationDrawing(e); });
  annotationCanvas.addEventListener('touchstart', (e) => { if(e.touches.length===1){e.preventDefault(); startAnnotationDrawing(e.touches[0]);}}, {passive:false});
  annotationCanvas.addEventListener('touchmove', (e) => { if(e.touches.length===1){e.preventDefault(); drawAnnotation(e.touches[0]);}}, {passive:false});
  annotationCanvas.addEventListener('touchend', (e) => { if(e.changedTouches.length===1){e.preventDefault(); stopAnnotationDrawing(e.changedTouches[0]);}});
  annotationCanvas.addEventListener('touchcancel', () => {
      if (isDrawingAnnotation) {
          if (previewImageData) { annotationCtx.putImageData(previewImageData, 0, 0); previewImageData = null; }
          isDrawingAnnotation = false; currentStroke = null;
      }
  });
  contentArea.addEventListener('click', function(event) {
      if (isMemoModeActive && document.body.classList.contains('true-fullscreen-active')) {
          if (event.target.closest('[data-editable-type], .text-annotation-memo, button, a, input, select, textarea, .item-controls')) return;
          if (event.detail === 0 && event.clientX === 0 && event.clientY === 0) return;
          const rect = contentArea.getBoundingClientRect();
          const x = event.clientX - rect.left + contentArea.scrollLeft;
          const y = event.clientY - rect.top + contentArea.scrollTop;
          createMemoAnnotation(x, y);
      }
      const deleteBtn = event.target.closest('.memo-delete-btn');
      if (deleteBtn) {
          event.stopPropagation();
          const memoDiv = deleteBtn.closest('.text-annotation-memo');
          if (memoDiv) memoDiv.remove();
      }
  });

  window.addEventListener('mousemove', resetIdleTimer);
  window.addEventListener('mousedown', resetIdleTimer);
  window.addEventListener('touchstart', resetIdleTimer);
  window.addEventListener('scroll', handleScrollForIdleReset, true);
  window.addEventListener('keydown', resetIdleTimer);
}

window.addEventListener('DOMContentLoaded', () => {
  document.body.classList.add('meeting-cursor');
  window.addEventListener('beforeunload', () => document.body.classList.remove('meeting-cursor'));
  
  // [MODIFIED] 타이머/시계/달력 기능 초기화
  initializeTimeAndDateFeature(initialTime);
  
  const emojiPalette = document.getElementById('emojiPalette');
  if (emojiPalette) {
      const emojis = ['😀','😂','😊','😍','🤔','👍','👎','⭐','❤️','✔','❌','✨','🎉','👀','👉','💡','❓','❗','➡️','⬅️','⬆️','⬇️','➕','➖','📁','📄'];
      emojis.forEach(emoji => {
          const btn = document.createElement('button');
          btn.type = 'button';
          btn.className = 'emoji-btn';
          btn.textContent = emoji;
          emojiPalette.appendChild(btn);
      });
  }

  if (typeof window.__SAVED_APP_STATE__ !== 'undefined' && window.__SAVED_APP_STATE__) {
      const state = window.__SAVED_APP_STATE__;
      try {
          if(state.monthlyNavigatorConfig) {
             weeklyNavigatorConfig.enabled = state.monthlyNavigatorConfig.enabled;
          } else {
             weeklyNavigatorConfig = state.weeklyNavigatorConfig || weeklyNavigatorConfig;
          }
          drawnStrokes = state.drawnStrokes || [];
          drawingSettings = state.drawingSettings || drawingSettings;
          keepDrawingsVisibleOnDeactivate = state.keepDrawingsVisibleOnDeactivate !== undefined ? state.keepDrawingsVisibleOnDeactivate : true;
          
          const savedEditMode = state.editIconsMode || 'off';
          const radioToCheck = document.querySelector(`input[name="editIconsMode"][value="${savedEditMode}"]`);
          if (radioToCheck) radioToCheck.checked = true;
          toggleEditIconsVisibility(savedEditMode);

      } catch (e) {
          console.error("저장된 상태 복원 오류:", e);
          updateDateTitles(); setAnnotationDefaults();
      }
  } else {
      updateDateTitles();
      setAnnotationDefaults();
      const radioOff = document.getElementById('editIconsModeOff');
      if(radioOff) radioOff.checked = true;
      toggleEditIconsVisibility('off');
  }
  
  initializeEventListeners();
  initializeWeeklyNavigator(); 

  elementsForMultiZoom = [];
  updateMultiZoomTriggerVisibility();
  if (pageTitle) { 
    generateItemControls(pageTitle); 
    pageTitle.addEventListener('input', () => { 
      requestAnimationFrame(adjustContainerPadding); 
      initializeWeeklyNavigator();
    }); 
  }
  contentArea.querySelectorAll('[data-editable-type]:not(.text-annotation-memo)').forEach(el => generateItemControls(el));
  contentArea.querySelectorAll('.text-annotation-memo').forEach(makeMemoDraggable);

  if (document.fonts) {
      document.fonts.ready.then(() => {
          requestAnimationFrame(() => {
              adjustContainerPadding();
              setupAnnotationCanvas();
              updateAnnotationDisplayToggleBtnStyle();
              fullscreenChangeHandler();
          });
      });
  } else {
      adjustContainerPadding();
      setupAnnotationCanvas();
      updateAnnotationDisplayToggleBtnStyle();
      fullscreenChangeHandler();
  }
  
  resetIdleTimer();
});

window.addEventListener('resize', () => {
  adjustContainerPadding();
  setupAnnotationCanvas();
});
</script>
</body>
</html>